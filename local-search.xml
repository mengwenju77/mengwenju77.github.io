<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2024/05/16/Linux/"/>
    <url>/2024/05/16/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Linux目录"><a href="#1-Linux目录" class="headerlink" title="1 Linux目录"></a>1 Linux目录</h1><h2 id="1-1-相对路径"><a href="#1-1-相对路径" class="headerlink" title="1.1 相对路径"></a>1.1 相对路径</h2><p>相对路径：相对于当前文件的路径。在Linux中有两个表示路径的特殊符号：</p><ul><li><code>./</code>：代表目前所在的目录，也可以使用<code>.</code>表示</li><li><code>../</code>：代表当前目录的上一层目录。也可以使用<code>..</code>表示</li></ul><h2 id="1-2-绝对路径"><a href="#1-2-绝对路径" class="headerlink" title="1.2 绝对路径"></a>1.2 绝对路径</h2><p>绝对路径：从系统磁盘起始节点开始描述的路径</p><ul><li>Llinux：起始节点为根目录。比如：<code>/root/work/mq</code></li></ul><h1 id="2-命令解析器"><a href="#2-命令解析器" class="headerlink" title="2 命令解析器"></a>2 命令解析器</h1><p><code>pwd</code>这个命令是怎么执行的？为什么<code>aabbcc</code>这个命令执行不了？</p><p>一个命令相当于一个可执行程序，在linux中输入<code>which pwd</code>，会出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/bin/pwd<br></code></pre></td></tr></table></figure><p>输入<code>echo $PATH</code>，会出现：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sbin:/u</span>sr<span class="hljs-regexp">/local/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/usr/</span>bin:<span class="hljs-regexp">/root/</span>bin<br></code></pre></td></tr></table></figure><p>输入<code>pwd</code>时，linux会在上述目录下一个一个搜索，搜到就执行，搜不到就不执行。pwd这个可执行程序是在<code>/usr/bin/pwd</code>目录下。</p><p>如果自己的可执行程序想要全局访问，那么把可执行程序放到PATH目录下即可</p><h1 id="3-文件类型"><a href="#3-文件类型" class="headerlink" title="3 文件类型"></a>3 文件类型</h1><p>在linux中，一共有7种文件类型，这7种文件类型是根据属性进行划分的，而不是根据后缀划分的</p><ul><li><code>-</code>：普通的文件</li><li><code>d</code>：目录（dirctory）</li><li><code>l</code>：软链接文件（link），相当于windows中的快捷方式</li><li><code>c</code>：字符设备（char）</li><li><code>b</code>：块设备（block）</li><li><code>p</code>：管道文件（pipe）</li><li><code>s</code>：本地套接字文件（socket）</li></ul><h1 id="4-文件权限"><a href="#4-文件权限" class="headerlink" title="4 文件权限"></a>4 文件权限</h1><p>linux中不同的用户可以对文件拥有不同的操作权限，权限一共有四种：<code>读权限、写权限、执行权限、没有任何权限</code></p><ul><li>读权限：使用<code>r</code>表示，即<code>read</code></li><li>写权限：使用<code>w</code>表示，即<code>write</code></li><li>执行权限：使用<code>x</code>表示，即<code>excute</code></li><li>没有任何权限：使用<code>-</code>表示</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240516110954877.png" alt="image-20240516110954877"></p><h1 id="5-文件查看"><a href="#5-文件查看" class="headerlink" title="5 文件查看"></a>5 文件查看</h1><p><strong>more</strong></p><p>more 文件名</p><ul><li>回车：显示下一行</li><li>空格：向下滚动一屏</li><li>b：返回上一屏</li><li>q：退出more</li></ul><p><strong>less</strong></p><p>less 文件名</p><ul><li>回车：显示下一行</li><li>空格：向下滚动一屏</li><li>b：返回上一屏</li><li>上下键：上下滚动</li><li>G：跳到最后一行</li><li>g：跳到第一行</li><li>q：退出less</li></ul><p><strong>head</strong>：使用该命令可以查看文件头部的若干信息。</p><ul><li>默认显示文件的前10行</li><li>head 文件名</li><li>指定显示头部的前多少行</li><li>head -行数 文件名</li></ul><p><strong>tail</strong>：使用该命令可以查看文件尾部的若干行信息</p><ul><li>默认显示文件的后10行</li><li>tail 文件名</li><li>指定显示尾部的多少行</li><li>tail -行数 文件名</li></ul><h1 id="6-修改文件权限"><a href="#6-修改文件权限" class="headerlink" title="6 修改文件权限"></a>6 修改文件权限</h1><p><strong>字母设定法</strong></p><p>语法格式：<code>chmod who [+ | - | =] 文件名</code></p><ul><li><p>who：</p><ul><li>u：user ，文件所有者</li><li>g：group，文件所属组用户</li><li>o：other，其它</li><li>a：all，以上三类人，u+g+o</li></ul></li><li><p>对权限的操作：</p><ul><li>+：添加权限</li><li>-：去除权限</li><li>&#x3D;：覆盖权限</li></ul></li><li><p>mod：权限</p><ul><li>r：read，读</li><li>w：write，写</li><li>x：execute，执行</li><li>-：没有权限</li></ul></li></ul><p><strong>数字设定法</strong></p><p>语法格式：<code>chomd [+ | - | =] mod文件名</code></p><ul><li><p>对权限的操作：</p><ul><li>+：添加权限</li><li>-：去除权限</li><li>&#x3D;：权限的覆盖，等号可以不写</li></ul></li><li><p>mod：权限描述，所有权限都放开是7</p><ul><li>4：read</li><li>2：write</li><li>1：execute</li><li>0：没有权限</li></ul></li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">chmod 567 a.txt<br>第一个数字是文件所有者权限，5代表4<span class="hljs-string">+1</span>，也就是对文件所有者开放：读+执行权限<br>第二个数字是文件所属组用户权限，6代表4<span class="hljs-string">+2</span>，也就是对文件所有者开放：读+写权限<br>第三个用户是其它人权限：7代表4<span class="hljs-string">+2</span><span class="hljs-string">+1</span>，也就是对其他人开放：读+写+执行权限<br></code></pre></td></tr></table></figure><h1 id="7-重定向"><a href="#7-重定向" class="headerlink" title="7 重定向"></a>7 重定向</h1><p>关于重定向使用最多的是<code>输出重定向</code>，就是修改输出的数据的位置。</p><ul><li><code>&gt;</code>：将文件内容写入到指定文件中，如果文件中已有数据，则会使用新数据覆盖原数据</li><li><code>&gt;&gt;</code>：将输出的内容追加到指定的文件尾部</li></ul><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">echo</span> 相当于在终端打印，类似printf，还有其它输出方式，比如 tail -f a.<span class="hljs-built_in">log</span><br><span class="hljs-built_in">echo</span> hello &gt; tmp  <span class="hljs-comment">// 如果tmp文件不存在，则创建，如果存在，则覆盖</span><br><span class="hljs-built_in">echo</span> <span class="hljs-number">123</span> &gt;&gt; tmp  <span class="hljs-comment">// 追加到尾部</span><br></code></pre></td></tr></table></figure><h1 id="8-用户添加和删除"><a href="#8-用户添加和删除" class="headerlink" title="8 用户添加和删除"></a>8 用户添加和删除</h1><p><strong>用户添加</strong></p><p>centos操作系统下：</p><p>sudo adduser 用户名</p><p><strong>用户删除</strong></p><p>userdel 用户名 -r</p><p>-r 可以一并删除用户的家目录，否则可能需要手动删除</p><p><strong>用户切换</strong></p><p><code>su 用户名</code>：su只切换用户，不切换当前工作目录</p><p><code>su - 用户名</code>：切换用户，并且把目录切换为当前用户的家目录</p><p><strong>修改用户密码</strong></p><p>修改自己的密码：<code>passwd</code></p><p>修改别人的密码：<code>passwd 用户名</code></p><p>普通用户修改别人的密码需要有sudo权限</p><p>centos给普通用户添加权限：</p><ul><li><p>在root用户下，执行 <code>visudo</code></p></li><li><p>找到：<code>root    ALL=(ALL)       ALL</code></p></li><li><p>在下面加一行：<code>用户名       ALL=(ALL)       ALL</code>保存退出即可</p></li></ul><h1 id="9-文件搜索"><a href="#9-文件搜索" class="headerlink" title="9 文件搜索"></a>9 文件搜索</h1><h2 id="9-1-find"><a href="#9-1-find" class="headerlink" title="9.1 find"></a><strong>9.1 find</strong></h2><p>根据文件的属性，查找对应的磁盘文件，常用的属性：文件名、文件类型、文件大小、文件的目录</p><p><strong>按文件名字搜索：-name</strong></p><p>搜索格式：<code>find 搜索的路径 -name 要搜索的文件名</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按文件名搜索 -name</span><br>find . -name *.cpp <span class="hljs-comment"># 在当前目录下搜索后缀名为cpp的文件</span><br></code></pre></td></tr></table></figure><p><strong>按文件类型搜索： -type</strong></p><table><thead><tr><th>文件类型</th><th>类型的字符描述</th></tr></thead><tbody><tr><td>普通的文件类型</td><td>f</td></tr><tr><td>目录类型</td><td>d</td></tr><tr><td>软连接类型</td><td>l</td></tr><tr><td>字符设备类型</td><td>c</td></tr><tr><td>块设备类型</td><td>b</td></tr><tr><td>管道类型</td><td>p</td></tr><tr><td>本地套接字类型</td><td>s</td></tr></tbody></table><p>搜索格式：<code>find 搜索的路径 -type 文件类型</code></p><p><strong>按文件大小搜索：-size</strong></p><p>语法格式：<code>find 搜索的路径 -size [+ | -]文件大小</code></p><ul><li>文件的大小需要加单位<ul><li>k（小写）</li><li>M（大写）</li><li>G（大写）</li></ul></li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">文件划分区间：<br>-size 4k：表示的区间为(4<span class="hljs-string">-1</span>k,4k]<br>-size <span class="hljs-string">-4</span>k：表示的区间[0k,4<span class="hljs-string">-1</span>k]<br>-size <span class="hljs-string">+4</span>k：表示的区间(4k,正无穷]<br></code></pre></td></tr></table></figure><p><strong>基于目录层级搜索</strong></p><ul><li><code>-maxdepth</code>：最多搜索到第多少层目录</li><li><code>-mindepth</code>：至少从第多少层开始搜索</li></ul><p>举例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">find</span> . -maxdepth <span class="hljs-number">5</span> -name <span class="hljs-regexp">*.cpp</span> <span class="hljs-comment"># 最多搜索5层</span><br>find . -mindepth <span class="hljs-number">5</span> -name <span class="hljs-regexp">*.cpp</span> <span class="hljs-comment"># 最少从第5层开始搜索</span><br></code></pre></td></tr></table></figure><p><strong>find高级用法</strong></p><p>如果想找到一个文件之后进行某些操作，比如查看信息，可以在正常的搜索之后加上：<code>-exec 操作命令 &#123;&#125; \;</code> 或者<code>-ok 操作命令 &#123;&#125; \;</code> </p><p><code>-exec</code>：不和用户交互</p><p><code>-ok</code>：和用户交互</p><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /work -name main.cpp -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -l &#123;&#125; \;  <br>find /work -name main.cpp -ok <span class="hljs-built_in">ls</span> -l &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>但上面这种写法比较繁琐，不好记，另外一种写法是 <code>|xargs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /work -name main.cpp |xargs <span class="hljs-built_in">ls</span> -l;  <br></code></pre></td></tr></table></figure><p><code>xargs</code>的效率比使用<code>-exec</code>的效率高</p><ul><li><code>-exec</code>：将<code>find</code>查询的结果逐条传递给后买你的<code>shell</code>命令</li><li><code>-xargs</code>：将<code>find</code>查询的结果一次性传递给后面的<code>shell</code>命令</li></ul><h2 id="9-2-grep"><a href="#9-2-grep" class="headerlink" title="9.2 grep"></a><strong>9.2 grep</strong></h2><p>grep命令用于查找文件里符合条件的字符串，常用参数：</p><ul><li><code>-r</code>：如果需要搜素目录中的文件内容，需要进行递归操作，必须指定该参数</li><li><code>-i</code>：对应要搜索的关键字，忽略字符大小写的差别</li><li><code>-n</code>：在显示符合样式的那一行之前，标示出该行的行号</li></ul><p>语法：<code>grep &quot;搜索的内容&quot; 搜索的路径/文件 参数</code></p><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&quot;include&quot;</span> ./ main.cpp -rn<br>grep <span class="hljs-string">&quot;include&quot;</span> main.cpp -rn<br></code></pre></td></tr></table></figure><h2 id="9-3-locate"><a href="#9-3-locate" class="headerlink" title="9.3 locate"></a><strong>9.3 locate</strong></h2><h1 id="10-静态库动态库"><a href="#10-静态库动态库" class="headerlink" title="10 静态库动态库"></a>10 静态库动态库</h1><h2 id="10-1-静态库"><a href="#10-1-静态库" class="headerlink" title="10.1 静态库"></a>10.1 静态库</h2><ul><li>在Linux中静态库以lib作为前缀, 以.a作为后缀, 中间是库的名字自己指定即可, 即: libxxx.a</li><li>在Windows中静态库一般以lib作为前缀, 以lib作为后缀, 中间是库的名字需要自己指定, 即: libxxx.lib</li></ul><p>源码：</p><p><code>add.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sub.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mult.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>div.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)a/b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>head.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _HEAD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _HEAD_H</span><br><span class="hljs-comment">// 加法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 减法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 乘法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">// 除法</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>测试程序<code>main</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a + b = %d\n&quot;</span>, <span class="hljs-built_in">add</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a - b = %d\n&quot;</span>, <span class="hljs-built_in">subtract</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a * b = %d\n&quot;</span>, <span class="hljs-built_in">multiply</span>(a, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a / b = %f\n&quot;</span>, <span class="hljs-built_in">divide</span>(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>|-- add.cpp<br>|-- div.cpp<br>|-- include<br>|   -- head.h<br>|-- main.cpp<br>|-- mult.cpp<br>-- sub.cpp<br></code></pre></td></tr></table></figure><p><strong>制作静态库</strong>：生成静态库，需要先对源文件进行汇编操作 (使用参数 -c) 得到二进制格式的目标文件 (.o 格式), 然后在通过 ar工具将目标文件打包就可以得到静态库文件了 (libxxx.a)。</p><ul><li>将源文件汇编，生成二进制文件。<code>g++ add.cpp sub.cpp mult.cpp div.cpp -c</code>，生成报错：找不到<code>head.h</code>的头文件，因为<code>head.h</code>和其它源代码文件不在同一个目录下，所以找不到，解决方法：指定头文件目录：<code>g++ add.cpp sub.cpp mult.cpp div.cpp -c -I ./include/</code>，汇编结束后会生成源文件对应的二进制<code>.o</code>文件</li><li>将生成的目标文件通过<code>ar</code>工具打包生成静态库，使用<code>ar</code>工具：<code>ar rcs libcalc.a *.o</code>，生成<code>libcalc.a</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ar工具的三个参数：</span><br>参数c：创建一个库，不管库是否存在，都将创建。<br>参数s：创建目标文件索引，这在创建较大的库时能加快时间。<br>参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块<br></code></pre></td></tr></table></figure><ul><li>发布静态库：静态库<code>libcalc.a</code>和库对应的头文件<code>head.h</code>一并发布</li></ul><p><strong>静态库的使用：</strong></p><p>得到一个可用的静态库之后，需要将其放到一个目录中，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>|-- add.cpp<br>|-- add.o<br>|-- div.cpp<br>|-- div.o<br>|-- include<br>|   `-- head.h<br>|-- mult.cpp<br>|-- mult.o<br>|-- sub.cpp<br>|-- sub.o<br>`-- <span class="hljs-built_in">test</span><br>    |-- head.h<br>    |-- libcalc.a<br>    `-- main.cpp<br></code></pre></td></tr></table></figure><ul><li>编译测试程序：<code>g++ main.cpp -o main</code>，出现错误：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">main.cpp:(.text+<span class="hljs-number">0x38</span>): undefined reference to `<span class="hljs-built_in">add</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#x27;<br>main.cpp:(.text+<span class="hljs-number">0x58</span>): undefined reference to `<span class="hljs-built_in">subtract</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#x27;<br>main.cpp:(.text+<span class="hljs-number">0x78</span>): undefined reference to `<span class="hljs-built_in">multiply</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#x27;<br>main.cpp:(.text+<span class="hljs-number">0x98</span>): undefined reference to `<span class="hljs-built_in">divide</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&#x27;<br></code></pre></td></tr></table></figure><p>这是因为程序在编译的时候没有找到这些函数的定义的位置，有引用但是没定义；解决方法：在编译的时候指定库文件的路径和名字：</p><p><code>g++ main.cpp -o main -I ./ -lcalc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译的时候指定库信息</span><br>-L: 指定库所在的目录(相对或者绝对路径)<br>-l: 指定库的名字, 掐头(lib)去尾(.a) ==&gt; calc<br><span class="hljs-comment"># -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc</span><br>$ g++ main.c -o app -L ./ -l calc<br></code></pre></td></tr></table></figure><ul><li>执行之后生成可执行程序<code>main</code></li></ul><h2 id="10-2-动态库"><a href="#10-2-动态库" class="headerlink" title="10.2 动态库"></a>10.2 动态库</h2><ul><li>在Linux中动态库以lib作为前缀, 以.so作为后缀, 中间是库的名字自己指定即可, 即: libxxx.so</li><li>在Windows中动态库一般以lib作为前缀, 以dll作为后缀, 中间是库的名字需要自己指定, 即: libxxx.dll</li></ul><p><strong>制作动态库</strong></p><p>生成动态链接库是直接使用gcc命令并且需要添加-fPIC（-fpic） 以及-shared 参数。</p><ul><li>对源文件进行汇编生成二进制文件：<code>g++ *.cpp -c -fpic -I ./include/</code>，得到源文件的<code>.o</code>文件</li><li>将得到的<code>.o</code>文件打包成动态库：<code>g++ -shared *.o -o libcalc.so</code>，得到动态库文件<code>libcalc.so</code></li><li>发布头文件和动态库</li></ul><p><strong>使用动态库</strong></p><p>目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>|-- head.h<br>|-- libcalc.so<br>`-- main.cpp<br></code></pre></td></tr></table></figure><p>执行：<code>g++ main.cpp -o main -L ./ -lcalc</code></p><p>报错：g++通过指定的动态库信息生成了可执行程序，但是可执行程序运行却提示无法加载到动态库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p>使用<code>ldd 可执行程序名</code>查看程序执行时能否找到所需要的动态库：<code>ldd main</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">linux-vdso.so.1 =&gt;  (0x00007ffec878b000)<br>libcalc.so =&gt; not found<br>libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f2b9fd84000)<br>libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f2b9fa82000)<br>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f2b9f86c000)<br>libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f2b9f49e000)<br>/lib64/ld-linux-x86-64.so.2 (0x00007f2ba008c000)<br></code></pre></td></tr></table></figure><p>可以看到只有<code>libcalc.so</code>找不到</p><p><strong>找不到的原因</strong></p><p>库的工作原理：</p><ul><li>静态库如何被加载？</li></ul><p>在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p><ul><li>动态库如何被加载？在程序编译的最后一个阶段也就是链接阶段：<ul><li>在gcc命令中虽然指定了库路径(使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</li><li>同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</li></ul></li></ul><p>可执行程序被执行起来之后</p><ul><li>程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息</li><li>当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载</li><li>动态库的检测和内存加载操作都是由动态连接器来完成的</li></ul><p>动态链接器：</p><p>动态链接器是一个独立于应用程序的进程, 属于操作系统, 当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L指定的路径。</p><p>那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.可执行文件内部的 DT_RPATH 段<br>2.系统的环境变量 LD_LIBRARY_PATH<br>3.系统动态库的缓存文件 /etc/ld.so.cache<br>4.存储动态库/静态库的系统目录 /lib/, /usr/lib等<br></code></pre></td></tr></table></figure><p>按照以上四个顺序, 依次搜索, 找到之后结束遍历, 最终还是没找到, 动态链接器就会提示动态库找不到的错误信息</p><p><strong>解决方法</strong></p><p>方案1：将库路径添加到环境变量 <code>LD_LIBRARY_PATH</code> 中</p><ul><li><p>找到相关的配置文件</p><ul><li>用户级别: ~&#x2F;.bashrc —&gt; 设置对当前用户有效</li><li>系统级别: &#x2F;etc&#x2F;profile —&gt; 设置对所有用户有效</li></ul></li><li><p>使用 vim 打开配置文件, 在文件最后添加一行：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库的绝对路径<br>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/work/dynamiclib/test<br></code></pre></td></tr></table></figure><p>然后执行<code>source .bashrc</code>使配置生效。使用命令 <code>echo $LD_LIBRARY_PATH</code> 可以查看环境变量的值</p><p>此时，再进入到<code>/work/dynamiclib/test</code>执行<code>main</code>文件就行了</p><p>方案2：更新 &#x2F;etc&#x2F;ld.so.cache 文件</p><ul><li><p>找到动态库所在的绝对路径（不包括库的名字）比如：<code>/work/dynamiclib/test</code></p></li><li><p>使用vim 修改 &#x2F;etc&#x2F;ld.so.conf 这个文件, 将上边的路径添加到文件中(独自占一行)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 打开文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ld.so.conf</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 添加动态库路径, 并保存退出</span><br></code></pre></td></tr></table></figure><ul><li>更新<code> /etc/ld.so.conf</code>中的数据到<code>/etc/ld.so.cache</code>中（这是个二进制文件，不能直接修改）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">必须使用管理员权限执行这个命令</span><br>sudo ldconfig <br></code></pre></td></tr></table></figure><p>方案3：拷贝动态库文件到系统库目录 <code>/lib/ </code>或者 <code>/usr/lib</code> 中 (或者将库的软链接文件放进去)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">库拷贝(不推荐)</span><br>sudo cp /xxx/xxx/libxxx.so /usr/lib<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建软连接</span><br>sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so<br></code></pre></td></tr></table></figure><h2 id="10-3-静态库和动态库的优缺点"><a href="#10-3-静态库和动态库的优缺点" class="headerlink" title="10.3 静态库和动态库的优缺点"></a>10.3 静态库和动态库的优缺点</h2><p><strong>静态库：</strong></p><ul><li>优点：<ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供依赖的静态库，移植方便</li></ul></li><li>缺点：<ul><li>相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存</li><li>库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间（链接时完整地拷贝至可执行文件中，被多次使用就有多分拷贝，如果库更新，那么需要重新编译应用程序，也就是重新链接拷贝）。</li></ul></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240520100532084.png" alt="image-20240520100532084"></p><p><strong>动态库：</strong></p><ul><li><p>优点</p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单, 只需要替换库文件, 无需重新编译应用程序</li><li>程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载</li></ul></li><li><p>缺点</p><ul><li>加载速度比静态库慢, 以现在计算机的性能可以忽略</li><li>发布程序需要提供依赖的动态库</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240520100743111.png" alt="image-20240520100743111"></p></li></ul><h1 id="11-压缩及解压缩"><a href="#11-压缩及解压缩" class="headerlink" title="11 压缩及解压缩"></a>11 压缩及解压缩</h1><p>用到再看</p><p><strong>参考：</strong></p><p><a href="https://www.bilibili.com/video/BV13U4y1p7kB?p=34&spm_id_from=pageDriver&vd_source=79a47c5035e6336414e7ccb0cf2a076d">https://www.bilibili.com/video/BV13U4y1p7kB?p=34&amp;spm_id_from=pageDriver&amp;vd_source=79a47c5035e6336414e7ccb0cf2a076d</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2024/05/14/makefile/"/>
    <url>/2024/05/14/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>从一个例子开始：</p><p><code>main.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functions.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printmain</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;This is main:&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The factorial of 5 is: &quot;</span> &lt;&lt; <span class="hljs-built_in">factorial</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>function.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functions.h&quot;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functions</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">functions</span>(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>printhello.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;functions.h&quot;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printhello</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello world&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>function.h</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _FUNCTIONS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _FUNCTIONS_H_</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printhello</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">|-- makefilelearn<br>|   |-- inc<br>|   |   `-- functions.h<br>|   |-- main.cpp<br>|   |-- main.o<br>|   `-- src<br>|       |-- functions.cpp<br>|       `-- printhello.cpp<br></code></pre></td></tr></table></figure><p><strong>编译方法1：使用命令分别编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># makefilelear目录下：</span><br>g++ main.cpp -c<br><span class="hljs-comment"># makefilelearn/src目录下：</span><br>g++ functions.cpp -c<br>g++ printhello.cpp -c<br></code></pre></td></tr></table></figure><p>生成3个<code>.o</code>文件，目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">|-- makefilelearn<br>|   |-- inc<br>|   |   |-- functions.h<br>|   |   `-- functions.h.gch<br>|   |-- main.cpp<br>|   |-- main.o<br>|   `-- src<br>|       |-- functions.cpp<br>|       |-- functions.o<br>|       |-- printhello.cpp<br>|       `-- printhello.o<br></code></pre></td></tr></table></figure><p>然后链接在一起：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">g++ main.o src/functions.o src/printhello.o -o main<br></code></pre></td></tr></table></figure><p>生成可执行程序<code>main</code>，运行：<code>./main</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello world<br>This is main:<br>The <span class="hljs-keyword">function</span> of 5 is: 120<br></code></pre></td></tr></table></figure><p>总结：虽然能编译，并且运行，但是文件多了的话，很麻烦</p><p><strong>注意：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ main.cpp -c   <span class="hljs-comment">#只编译不链接</span><br>g++ main.cpp -o   <span class="hljs-comment">#编译并链接</span><br></code></pre></td></tr></table></figure><p><strong>编译方法2：makefile–版本1</strong></p><p>目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">|-- makefilelearn<br>|   |-- inc<br>|   |   `-- functions.h<br>|   |-- main<br>|   |-- main.cpp<br>|   |-- Makefile<br>|   `-- src<br>|       |-- functions.cpp<br>|       `-- printhello.cpp<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># VERSION 1</span><br><span class="hljs-comment"># main为生成的可执行文件，依赖于后面的三个.cpp文件</span><br><span class="hljs-comment"># g++前面加一个TAB的空格</span><br>main: main.cpp src/printhello.cpp src/functions.cpp<br>g++ -o main main.cpp src/printhello.cpp src/functions.cpp<br></code></pre></td></tr></table></figure><p>编译好makefile文件之后使用<code>make</code>命令进行编译</p><p>缺点：全部编译，如果文件多，要编很久</p><p><strong>编译方法3：makefile–版本2</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># VERSION 2</span><br><span class="hljs-comment"># 定义变量</span><br>CXX = g++<br>TARGET = main<br>OBJ = main.o printhello.o functions.o<br><span class="hljs-comment"># make时执行g++ 先找TARGET，TARGET不存在找OBJ，OBJ不存在，编译三个.cpp文件生成.o文件</span><br><span class="hljs-comment"># 然后再编译OBJ文件，生成可执行文件hello</span><br>$(TARGET): $(OBJ)<br>$(CXX) -o $(TARGET) $(OBJ)<br><span class="hljs-comment"># main.o这样来的，编译main.cpp生成</span><br>main.o: main.cpp<br>$(CXX) -c main.cpp<br>printhello.o: src/printhello.cpp<br>$(CXX) -c src/printhello.cpp<br>functions.o: src/functions.cpp<br>$(CXX) -c src/functions.cpp<br></code></pre></td></tr></table></figure><p>好处就是只编译修改的文件，没修改的文件不编译</p><p><strong>编译方法4：makefile–版本3</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># VERSION 4</span><br>CXX = g++<br>TARGET = hello<br><span class="hljs-comment"># 所有当前目录的.cpp文件都放在SRC里面</span><br>SRC = $(wildcard *.cpp) $(wildcard src/*.cpp)<br><span class="hljs-comment"># 把SRC里面的.cpp文件替换为.o文件</span><br>OBJ = $(patsubst %.cpp, %.o,$(SRC))<br> <br>CXXLAGS = -c -Wall<br> <br>$(TARGET): $(OBJ)<br>$(CXX) -o <span class="hljs-variable">$@</span> $^<br> <br>%.o: %.cpp<br>$(CXX) $(CXXLAGS) $&lt; -o <span class="hljs-variable">$@</span><br> <br>.PHONY: clean<br>clean:<br><span class="hljs-built_in">rm</span> -f *.o $(TARGET)<br></code></pre></td></tr></table></figure><p>这样写更通用，添加一个文件后不需要修改makefile文件</p><blockquote><p>查看目录结构</p></blockquote><p>安装目录树结构命令(centos7系统)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y tree<br></code></pre></td></tr></table></figure><p>查看目录结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">查看当第N级目录和文件<br>tree -L N<br>比如：查看<span class="hljs-number">3</span>级目录<br>tree -L <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake_minimum_required(VERSION 2.8)<br>project(hello)<br><span class="hljs-comment"># C++11</span><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD 11)<br><span class="hljs-comment"># 添加头文件，如果不想在包含头文件的时候使用相对路径，可以使用在这里添加头文件路径，表示引用的头文件都是在inc目录下的</span><br>include_directories(inc)<br><span class="hljs-comment"># 添加源文件，给./src起个别名 DIR_SRCS</span><br>aux_source_directory(./src DIR_SRCS)<br><span class="hljs-comment"># 所有需要编译的可执行文件</span><br>add_executable(hello <span class="hljs-variable">$&#123;DIR_SRCS&#125;</span>)<br></code></pre></td></tr></table></figure><p>目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">|-- makefilelearn<br>|   |-- CMakeLists.txt<br>|   |-- inc<br>|   |   `-- functions.h<br>|   |-- main.cpp<br>|   `-- src<br>|       |-- functions.cpp<br>|       `-- printhello.cpp<br></code></pre></td></tr></table></figure><p>使用<code>CMakelists</code>文件编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先执行</span><br>cmake .<br><span class="hljs-comment"># 再执行</span><br>make<br></code></pre></td></tr></table></figure><p>但会生成很多文件，会比较乱，删起来也比较麻烦。可以创建一个目录<code>build</code>，在<code>build</code>目录下进行编译，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先执行</span><br>cmake ..<br><span class="hljs-comment"># 再执行</span><br>make<br></code></pre></td></tr></table></figure><p>此时，所有的文件都是在<code>build</code>目录下生成的，里面有个<code>hello</code>可执行文件，想删的话执行把<code>build</code>文件夹里的文件删掉就行了</p><p><strong>参考：</strong></p><p><a href="https://www.bilibili.com/video/BV188411L7d2/?spm_id_from=333.337.search-card.all.click&vd_source=79a47c5035e6336414e7ccb0cf2a076d">https://www.bilibili.com/video/BV188411L7d2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=79a47c5035e6336414e7ccb0cf2a076d</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程通信</title>
    <link href="/2024/05/13/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/05/13/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1 消息队列"></a>1 消息队列</h1><h2 id="消息队列解决了什么问题"><a href="#消息队列解决了什么问题" class="headerlink" title="消息队列解决了什么问题"></a>消息队列解决了什么问题</h2><p><strong>解耦</strong></p><p><strong>有序性</strong></p><p><strong>异步处理</strong></p><p><strong>削峰</strong></p><h2 id="写进程"><a href="#写进程" class="headerlink" title="写进程"></a>写进程</h2><p>消息队列通过<code>msgsnd</code>函数发送消息，其声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msg_sz, <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>int msgid</code>：消息队列标识符，由<code>msgget</code>函数返回</p><ul><li><p><code>msgget</code>函数：创建一个消息队列，返回以key命名的消息队列的标识符 <code>int msgget(key_t key, int msgflg);</code></p><ul><li><p><code>key</code>：某个消息队列的名字，<code>key</code>如何获取？</p><ul><li>通过宏定义<code>key</code>值</li><li>通过<code>ftok</code>函数生成<code>key</code>值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值</span><br><span class="hljs-comment">// ftok函数将通过对pathname的索引节点号（inode number）与proj_id进行异或操作生成一个唯一的键值。返回的键值类型是key_t，通常是一个长整型</span><br><span class="hljs-function"><span class="hljs-type">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span></span>;  <span class="hljs-comment">// 声明</span><br>key = <span class="hljs-number">123</span>;  <span class="hljs-comment">// 获取方法1</span><br>key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>);  <span class="hljs-comment">// 获取方法2</span><br></code></pre></td></tr></table></figure></li><li><p><code>msgflg</code>举例说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">IPC_CREAT如果消息队列对象不存在，则创建之，否则则进行打开操作<br>IPC_EXCL如果消息对象不存在则创建之，否则产生一个错误并返回<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>const void *msg_ptr</code>：是一个指针，指针指向准备发送的消息</p></li><li><p><code>size_t msg_sz</code>：是<code>msg_ptr</code>指向的消息长度，消息缓冲区结构体中<code>mtext</code>的大小,不包括数据的类型</p></li><li><p><code>int msgflg</code>：控制着当前消息队列满或到达系统上限时将要发生的事情</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">msgflg = IPC_NOWAIT 表示队列满不等待，返回EAGAIN错误<br></code></pre></td></tr></table></figure></li></ul><p>返回值：</p><ul><li>成功返回0</li><li>失败返回-1</li></ul><h2 id="读进程"><a href="#读进程" class="headerlink" title="读进程"></a>读进程</h2><p>使用<code>msgrcv</code>函数进行读数据，其声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype, <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>int msgid</code>：由<code>msgget</code>函数返回的消息队列标识码，<code>msgget</code>函数用法同写进程</li><li><code>void *msg_ptr</code>：是一个指针，指针指向准备接收的消息</li><li><code>size_t msgsz</code>：是<code>msg_ptr</code>指向的消息长度，消息缓冲区结构体中<code>mtext</code>的大小,不包括数据的类型</li><li><code>long int msgtype</code>：它可以实现接收优先级的简单形式<ul><li><code>msgtype=0</code>返回队列第一条信息</li><li><code>msgtype&gt;0</code>返回队列第一条类型等于<code>msgtype</code>的消息</li><li><code>msgtype&lt;0</code>返回队列第一条类型小于等于<code>msgtype</code>绝对值的消息</li></ul></li><li><code>int msgflg</code>：控制着队列中没有相应类型的消息可供接收时将要发生的事<ul><li><code>msgflg=IPC_NOWAIT</code>，队列没有可读消息不等待，返回<code>ENOMSG</code>错误。</li><li><code>msgflg=MSG_NOERROR</code>，消息大小超过<code>msgsz</code>时被截断</li></ul></li></ul><p>返回值：</p><ul><li>成功返回实际放到接收缓冲区里去的字符个数</li><li>失败，则返回-1</li></ul><h2 id="消息队列的控制函数"><a href="#消息队列的控制函数" class="headerlink" title="消息队列的控制函数"></a>消息队列的控制函数</h2><p>函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">int</span> command, strcut msqid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>msqid</code>： 由<code>msgget</code>函数返回的消息队列标识码</li><li><code>command</code>：是将要采取的动作,（有三个可取值）分别如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">IPC_STAT：获取消息队列的状态信息，将 msqid_ds 结构体填充到 buf 中。<br>IPC_SET：设置消息队列的权限，从 buf 结构体中读取权限信息。<br>IPC_RMID：删除消息队列，释放相关资源。<br></code></pre></td></tr></table></figure><ul><li><code>buf</code>：保存消息队列信息的结构体指针，通常是结构体 <code>msqid_ds</code> 的指针，用于传递或接收消息队列的属性信息。</li></ul><p>返回值：</p><ul><li>操作成功，返回0</li><li>失败，返回-1</li></ul><h2 id="查看消息队列"><a href="#查看消息队列" class="headerlink" title="查看消息队列"></a>查看消息队列</h2><ul><li><p><code>ipcs -q</code>：命令查看已经创建的消息队列，包括他的key值信息，id信息，拥有者信息，文件权限信息，已使用的字节数，和消息条数。</p></li><li><p><code>ipcrm -Q加消息队列的key值</code>，用来删除一个消息队列。</p></li></ul><h2 id="消息队列实验"><a href="#消息队列实验" class="headerlink" title="消息队列实验"></a>消息队列实验</h2><p>读进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span> </span><br>  <br><span class="hljs-comment">//消息结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mesg_buffer</span> &#123; <br>    <span class="hljs-type">long</span> mesg_type; <br>    <span class="hljs-type">char</span> mesg_text[<span class="hljs-number">100</span>]; <br>&#125; message; <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-type">key_t</span> key; <br>    <span class="hljs-type">int</span> msgid; <br>  <br>    <span class="hljs-comment">//函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值，称为IPC键值</span><br>    key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>); <br>  <br>    <span class="hljs-comment">// 创建一个新的或打开一个已经存在的消息队列，返回其id</span><br>    msgid = <span class="hljs-built_in">msgget</span>(key, <span class="hljs-number">0666</span> | IPC_CREAT); <br>  <br>    <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-built_in">msgrcv</span>(msgid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <br>  <br>    <span class="hljs-comment">// 显示消息 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;收到的消息为: %s \n&quot;</span>,  message.mesg_text); <br>  <br>    <span class="hljs-comment">// to destroy the message queue </span><br>    <span class="hljs-built_in">msgctl</span>(msgid, IPC_RMID, <span class="hljs-literal">NULL</span>); <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>写进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span>&#123;<br><span class="hljs-type">long</span> mesg_type;<br><span class="hljs-type">char</span> mesg_text[<span class="hljs-number">100</span>];<br>&#125;message;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">key_t</span> key; <br>    <span class="hljs-type">int</span> msgid; <br>  <br>    <span class="hljs-comment">//函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值</span><br>    key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>); <br>  <br>    <span class="hljs-comment">// msgget：创建一个消息队列，返回以key命名的消息队列的标识符</span><br>    msgid = <span class="hljs-built_in">msgget</span>(key, <span class="hljs-number">0666</span> | IPC_CREAT); <br>    message.mesg_type = <span class="hljs-number">1</span>; <br>  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入的数据为: &quot;</span>); <br>    <span class="hljs-built_in">gets</span>(message.mesg_text); <br>  <br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-built_in">msgsnd</span>(msgid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">0</span>); <br>  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;发送的消息为: %s \n&quot;</span>, message.mesg_text); <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>分别编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ read.cpp -o r.out<br>g++ write.cpp -o w.out<br></code></pre></td></tr></table></figure><p>得到两个文件：<code>r.out</code>和<code>w.out</code>，运行</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240513212522806.png" alt="image-20240513212522806"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器配置</title>
    <link href="/2024/05/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/05/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>Yum更新</strong></p><blockquote><p>yum update -y</p></blockquote><p><strong>Tab补全</strong></p><blockquote><p>yum -y install bash-completion</p></blockquote><p><strong>Wget</strong></p><blockquote><p>yum install -y wget</p></blockquote><p><strong>Vim</strong></p><blockquote><p>yum install -y vim-enhanced</p></blockquote><p><strong>网络工具</strong></p><blockquote><p>yum install -y net-tools.x86_64</p></blockquote><p>目前gcc版本是<code>4.8.5</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)<br>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)<br></code></pre></td></tr></table></figure><p>至此，已经能够编译C++文件，但是C++版本是C++98，并不是C++11</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">g++ -dM -E -x c++  /dev/null | grep -F __cplusplus<br>输出：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __cplusplus 199711L</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">C++ pre-C++98: __cplusplus is 1.<br>C++98: __cplusplus is 199711L.<br>C++98 + TR1: This reads as C++98 and there is no way to check that I know of.<br>C++11: __cplusplus is 201103L.<br>C++14: __cplusplus is 201402L.<br>C++17: __cplusplus is 201703L.<br>C++20: __cplusplus is 202002L.<br></code></pre></td></tr></table></figure><p><strong>设置免登录</strong></p><p>1、本地cmd，输入下面指令，一路回车不用输入内容，需要确认的话就确认</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>在<code>C:\Users\mengwenju\.ssh</code>文件夹里找到<code>id_rsa.pub</code>文件，里面就是密钥</p><p>2、在服务器<code>/root/.ssh\</code>找到<code>authorized_keys</code>文件，将上面<code>id_rsa.pub</code>中的密钥复制进去，如果原来<code>id_rsa.pub</code>已经有密钥了，往下再粘贴一个即可</p><p>3、至此，使用vscode或者bash连接都是免密码的</p><p><strong>Git Bash连接之后很快断开问题解决办法</strong></p><blockquote><p><a href="https://blog.csdn.net/weixin_42458562/article/details/105309176">https://blog.csdn.net/weixin_42458562/article/details/105309176</a></p></blockquote><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/m0_37613503/article/details/112160865">https://blog.csdn.net/m0_37613503/article/details/112160865</a></p><p><a href="https://blog.csdn.net/qq_39547794/article/details/130080464">https://blog.csdn.net/qq_39547794/article/details/130080464</a></p><p><a href="https://blog.csdn.net/qq_34902437/article/details/124329128">https://blog.csdn.net/qq_34902437/article/details/124329128</a></p><p><a href="https://www.bilibili.com/video/BV1GK4y1w7iU/?spm_id_from=333.337.search-card.all.click&vd_source=79a47c5035e6336414e7ccb0cf2a076d">https://www.bilibili.com/video/BV1GK4y1w7iU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=79a47c5035e6336414e7ccb0cf2a076d</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用头文件</title>
    <link href="/2024/04/23/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2024/04/23/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">//STL 通用算法</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span><span class="hljs-comment">//STL 位集容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span>         <span class="hljs-comment">//字符处理</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span>  <span class="hljs-comment">//定义错误??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cfloat&gt;</span> <span class="hljs-comment">//浮点数处??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ciso646&gt;</span>         <span class="hljs-comment">//对应各种运算符的??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span> <span class="hljs-comment">//定义各种数据类型最值的常量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;clocale&gt;</span> <span class="hljs-comment">//定义本地化函??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span> <span class="hljs-comment">//定义数学函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span> <span class="hljs-comment">//复数??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span>         <span class="hljs-comment">//信号机制支持</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csetjmp&gt;</span>         <span class="hljs-comment">//异常处理支持</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdarg&gt;</span>         <span class="hljs-comment">//不定参数列表支持</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span>         <span class="hljs-comment">//常用常量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  <span class="hljs-comment">//定义输入／输出函??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">//定义杂项函数及内存分配函??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">//字符串处??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span> <span class="hljs-comment">//定义关于时间的函??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cwchar&gt;</span>  <span class="hljs-comment">//宽字符处理及输入／输??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cwctype&gt;</span> <span class="hljs-comment">//宽字符分??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span> <span class="hljs-comment">//STL 双端队列容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span> <span class="hljs-comment">//异常处理??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">//文件输入／输??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span><span class="hljs-comment">//STL 定义运算函数（代替运算符??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>  <span class="hljs-comment">//定义各种数据类型最值常??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span><span class="hljs-comment">//STL 线性列表容??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span>         <span class="hljs-comment">//本地化特定信??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span> <span class="hljs-comment">//STL 映射容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>         <span class="hljs-comment">//STL通过分配器进行的内存分配</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;new&gt;</span>            <span class="hljs-comment">//动态内存分??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>         <span class="hljs-comment">//STL常用的数字操??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>  <span class="hljs-comment">//参数化输入／输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ios&gt;</span> <span class="hljs-comment">//基本输入／输出支??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iosfwd&gt;</span><span class="hljs-comment">//输入／输出系统使用的前置声明</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//数据流输入／输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;istream&gt;</span> <span class="hljs-comment">//基本输入??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span>        <span class="hljs-comment">//STL迭代??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span> <span class="hljs-comment">//基本输出??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//STL 队列容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> <span class="hljs-comment">//STL 集合容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span> <span class="hljs-comment">//基于字符串的??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span> <span class="hljs-comment">//STL 堆栈容器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">//标准异常??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;streambuf&gt;</span> <span class="hljs-comment">//底层输入/输出支持</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span><span class="hljs-comment">//字符串类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span>        <span class="hljs-comment">//运行期间类型信息</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>   <span class="hljs-comment">//STL 通用模板??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span>        <span class="hljs-comment">//对包含值的数组的操??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>   <span class="hljs-comment">//STL 动态数组容??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span> <span class="hljs-comment">// unordered_map头文??</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2024/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h1><h2 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1 什么是操作系统"></a>1 什么是操作系统</h2><p>操作系统（Operation System），简称OS，是管理计算机<strong>硬件</strong>与<strong>软件</strong>资源的计算机<strong>程序</strong>。</p><blockquote><p>操作系统是一个程序，用来管理计算机硬件与软件（是一个管理者的角色）</p></blockquote><p><img src="/../imgs/$%7Bfiilename%7D/image-20240415162339162.png" alt="image-20240415162339162"></p><p>计算机系统的构成</p><ul><li>用户</li><li>应用程序（应用程序都安装在了操作系统里）</li><li>操作系统（操作系统向应用程序提供服务（接口））</li><li>硬件（CPU、内存、键盘、鼠标）</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240415162449299.png" alt="image-20240415162449299"></p><p>虽然操作系统也是应用程序（软件），但是它和普通应用软件不一样，它是一种<strong>系统软件</strong>。</p><p>系统软件做了哪些事？</p><ul><li>与硬件交互</li><li>对硬件资源（CPU、内存）共享进行调度管理（多个应用程序都想访问硬件资源，由系统软件进行调度）</li><li>解决并发操作处理中存在的协调问题</li><li>数据结构复杂，外部接口多样化，便于用户反复使用</li></ul><p>既然操作系统是一种系统软件，那么操作系统做了哪些事？</p><ul><li>管理与配置内存</li><li>决定系统资源供给的优先次序</li><li>控制输入设备与输出设备</li><li>操作网络与管理文件系统等基本事务</li><li>提供一个让用户与系统交互的操作界面</li></ul><h2 id="2-操作系统的目标和功能"><a href="#2-操作系统的目标和功能" class="headerlink" title="2 操作系统的目标和功能"></a>2 操作系统的目标和功能</h2><h3 id="1-2-1-OS的目标"><a href="#1-2-1-OS的目标" class="headerlink" title="1.2.1 OS的目标"></a>1.2.1 OS的目标</h3><p><strong>管理系统资源</strong></p><ul><li>有效性<ul><li>提高系统资源利用率</li><li>提高系统的吞吐量</li></ul></li></ul><p><strong>方便用户使用</strong></p><ul><li>方便性</li></ul><p><strong>作为扩充机器</strong></p><ul><li>可扩充性（比如增加内存，随着硬件的法阵而发展，新的硬件也能支持）</li><li>开放性</li></ul><h3 id="1-2-2-OS的功能"><a href="#1-2-2-OS的功能" class="headerlink" title="1.2.2 OS的功能"></a>1.2.2 OS的功能</h3><p><strong>作为计算机系统硬件资源的管理者</strong></p><ul><li>处理器管理<ul><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>调度</li></ul></li><li>存储器管理<ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul></li><li>I&#x2F;O设备管理<ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ul></li><li>文件管理<ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读&#x2F;写管理和保护</li></ul></li></ul><p><strong>作为用户与计算机硬件系统之间的接口</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240415170357352.png" alt="image-20240415170357352"></p><ul><li>程序接口</li><li>命令接口</li><li>GUI(Graphical User Interface，图形用户接口)</li></ul><blockquote><p>应用程序访问操作系统的接口, 这一过程叫做系统调用</p></blockquote><p><strong>实现了对计算机硬件资源的抽象</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240415170416573.png" alt="image-20240415170416573"></p><ul><li>将具体的计算机硬件资源抽象成软件资源，方便用户使用</li><li>开放了简单的访问方式（操作系统对用户，对应用程序提供了接口），隐藏了实现细节（接口内部完成对硬件资源调用，这一过程不可见）<ul><li>举例：使用浏览器进行搜索</li></ul></li></ul><h2 id="3-操作系统的特征"><a href="#3-操作系统的特征" class="headerlink" title="3 操作系统的特征"></a>3 操作系统的特征</h2><h3 id="3-1-并发"><a href="#3-1-并发" class="headerlink" title="3.1 并发"></a>3.1 并发</h3><p><strong>OS的并发性</strong></p><p>同一时间间隔内执行和调度多个程序的能力</p><ul><li>宏观上，处理器同时执行多道程序</li><li>微观上，处理器在多道程序间高速切换（分时交替进行）</li><li>关注单个处理器同一时间段内处理任务数量的能力</li></ul><p>相似概念：并行</p><ul><li>并发：同一时间间隔（时间段）发生的事件数量</li><li>并行：同一时刻（时间点）发生的事件数量</li></ul><h3 id="3-2-共享"><a href="#3-2-共享" class="headerlink" title="3.2 共享"></a>3.2 共享</h3><p><strong>OS的共享性</strong></p><p>即硬件资源共享，系统中的资源供多个并发执行的应用程序共同使用</p><ul><li><p>同时访问方式：同一时间段允许多个程序同时访问共享资源</p></li><li><p>互斥共享方式：也叫独占式，允许多个程序在同一个共享资源上独立而互补干扰的工作</p></li><li><p>共享打印机、音频设备、视频设备</p></li></ul><blockquote><p>并发和共享互为前提</p><ul><li>共享性要求OS中同时运行着多道程序<ul><li>若只有单道程序正在运行，则不存在共享的可能</li></ul></li><li>并发性难以避免的导致多道程序同时访问同一个资源<ul><li>若多道程序无法共享部分资源（比如磁盘），则无法并发</li></ul></li></ul></blockquote><h3 id="3-3-虚拟"><a href="#3-3-虚拟" class="headerlink" title="3.3 虚拟"></a>3.3 虚拟</h3><p><strong>OS的虚拟技术</strong></p><p>使用某种技术把一个物理实体变成多个逻辑上的对应物。按两个维度：</p><ul><li>时分复用技术（TDM，Time Division Multiplexing）<ul><li>虚拟处理器技术：四核八线程</li><li>虚拟设备技术：虚拟打印机</li></ul></li><li>空分复用技术：（SDM，Space Division Multiplexing）<ul><li>虚拟磁盘技术：将一块硬盘虚拟出若干个卷</li><li>虚拟存储器技术</li></ul></li></ul><h3 id="3-4-异步"><a href="#3-4-异步" class="headerlink" title="3.4 异步"></a>3.4 异步</h3><p><strong>OS的异步性（Asynchronism）</strong></p><p>多道程序环境下，多个程序并发执行；</p><p>单处理器环境下，多个程序分时交替执行；</p><ul><li>程序执行的不可预知性<ul><li>获得运行的时机</li><li>因何暂停</li><li>每道程序需要多少时间</li><li>不同程序的性能，比如计算多少，I&#x2F;O多少</li></ul></li><li>宏观上“一气呵成”，微观上“走走停停”</li></ul><h2 id="4-操作系统的发展与分类"><a href="#4-操作系统的发展与分类" class="headerlink" title="4 操作系统的发展与分类"></a>4 操作系统的发展与分类</h2><p>五个阶段：</p><p><strong>手工操作阶段</strong></p><ul><li>人工操作方式</li><li>脱机输入&#x2F;输出方式</li></ul><p><strong>批处理阶段</strong></p><ul><li>单道批处理系统</li><li>多道批处理系统</li></ul><p><strong>分时操作系统</strong></p><p><strong>实时操作系统</strong></p><p><strong>微机操作系统的发展</strong></p><h2 id="5-操作系统的运行机制"><a href="#5-操作系统的运行机制" class="headerlink" title="5 操作系统的运行机制"></a>5 操作系统的运行机制</h2><p>几个基本概念：</p><p>内核程序 &lt;—&gt; 应用程序</p><p>核心态 &lt;—&gt; 用户态（CPU的运行模式。CPU从用户态切换到内核态只有一种方式：中断）</p><p>特权指令 &lt;—&gt; 非特权指令</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240415212912099.png" alt="image-20240415212912099"></p><h3 id="5-1-时钟管理"><a href="#5-1-时钟管理" class="headerlink" title="5.1 时钟管理"></a>5.1 时钟管理</h3><p><strong>计时：提供系统时间</strong></p><p><strong>时钟中断：比如进程切换</strong></p><h3 id="5-2-中断机制"><a href="#5-2-中断机制" class="headerlink" title="5.2 中断机制"></a>5.2 中断机制</h3><p><strong>作用：</strong>提高多道程序环境下CPU利用率</p><ul><li>举例：在执行某一个程序时，需要I&#x2F;O操作，在I&#x2F;O操作的过程中，可以让CPU去执行其它的程序。</li></ul><p><strong>分类：</strong></p><ul><li><p>外中断：中断信号来源于-&gt;外部设备</p></li><li><p>内中断：中断信号来源于-&gt;当前指令</p></li></ul><p>内中断的三种情况：内中断也叫做异常&#x2F;陷入&#x2F;例外</p><p>陷阱&#x2F;陷入（Trap）：由应用程序主动引发</p><p>故障（fault）：由错误条件引发</p><p>终止（abort）：由致命错误引发</p><p><strong>中断处理过程：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240416154654478.png" alt="image-20240416154654478"></p><h3 id="5-3-原语"><a href="#5-3-原语" class="headerlink" title="5.3 原语"></a>5.3 原语</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240416161746880.png" alt="image-20240416161746880"></p><ul><li>原语是一个程序段</li><li>由若干条指令组成</li><li>用来完成某个特定操作</li><li>执行过程不会被中断（原子性，即不可中断，不是不可再分）</li></ul><h3 id="5-4-系统数据结构"><a href="#5-4-系统数据结构" class="headerlink" title="5.4 系统数据结构"></a>5.4 系统数据结构</h3><p>进程管理：作业控制块、进程控制块</p><p>存储器管理：存储器分配与回收</p><p>设备管理：缓冲区、设备控制块</p><h3 id="5-5-系统调用"><a href="#5-5-系统调用" class="headerlink" title="5.5 系统调用"></a>5.5 系统调用</h3><p>由操作系统实现，给应用程序调用，即应用程序调用操作系统内核功能时进行的调用。</p><h2 id="6-操作系统的体系结构"><a href="#6-操作系统的体系结构" class="headerlink" title="6 操作系统的体系结构"></a>6 操作系统的体系结构</h2><h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1 什么是进程"></a>1 什么是进程</h2><h3 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 进程的概念</h3><p>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><blockquote><p>进程加载到内存中才会运行。</p></blockquote><ul><li><p>进程是<code>程序</code>的<code>一次执行</code></p><p>理解：程序没执行时没有进程，执行时才会产生进程。比如打开chrome浏览器，每打开一个页面都会产生一个进程。</p><blockquote><p>an instance of a computer program that is being executed</p></blockquote></li><li><p>进程是一个程序及其数据在处理器上顺序执行时所发生的<code>活动</code></p></li><li><p>进程是程序在一个<code>数据集合</code>上运行的过程</p></li><li><p>进程是系统进行<code>资源分配和调度</code>的一个<code>基本单位</code></p><blockquote><p>操作系统以进程为单位进行资源分配和调度。来一个进程，分配一些资源。</p></blockquote></li></ul><h3 id="1-2-进程的结构和特征"><a href="#1-2-进程的结构和特征" class="headerlink" title="1.2 进程的结构和特征"></a>1.2 进程的结构和特征</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240416172719140.png" alt="image-20240416172719140"> </p><p><strong>进程的结构：</strong></p><ul><li>控制块（PCB，Process Control Block）。进程唯一标识。在基站前台敲PCB，可以看到各个进程</li><li>数据段，存放原始数据，中间数据</li><li>程序段，存放在文本区域，可被多个进程共享（同一个应用程序的多个进程之间是共享程序段的。比如打开chrome开了多个页面，一些基础程序是相同的，进程之间可共享，就不用再分配内存了）</li></ul><p><strong>进程的特征：</strong></p><ul><li>动态性：由创建而生，由撤销而亡</li><li>并发性：多个进程同时运行</li><li>独立性：独立资源分配（CPU、内存、I&#x2F;O设备）</li><li>异步性：相互独立，互不干扰</li></ul><h3 id="1-3-进程与线程"><a href="#1-3-进程与线程" class="headerlink" title="1.3 进程与线程"></a>1.3 进程与线程</h3><p><strong>什么是线程？</strong></p><ul><li>Thread，进程的轻型实体，也叫“轻量级进程”，是一系列活动按事先设定好的顺序（代码顺序）依次执行的过程，是一系列指令的集合</li><li>是一条执行路径，不能单独存在，必须包含在进程中</li><li>线程是OS中运算调度的最小单位</li></ul><p>举例：比如360杀毒应用程序运行时是一个进程，但是其中包含了很多小功能，也就是一系列指令的集合，这些就是线程 </p><p><strong>为什么引入线程？</strong></p><p>为了提高OS的并发性。</p><blockquote><p>如果没有线程的概念，只有进程的概念的话：当某个应用程序运行时，如果这个应用程序想执行多个功能，那么就需要创建多个进程，成本很高</p></blockquote><p><strong>线程的属性？</strong></p><ul><li>轻型实体（相对于进程而言）</li><li>独立调度的基本单位</li><li>可并发执行</li><li>共享进程资源（线程的资源由进程管理）</li></ul><p><strong>进程和线程的比较：</strong></p><ul><li>调度：线程是资源调度的基本单位</li><li>拥有资源（CPU，寄存器，内存，I&#x2F;O设备等等）：资源是分配给进程的</li><li>并发性</li><li>系统开销：线程切换比进程切换的开销要小很多</li><li>地址空间和其它资源：同一个进程中的多个线程，共享进程的内存空间（寄存器不共享）</li><li>通信</li></ul><p><strong>线程的实现方式：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240416213847710.png" alt="image-20240416213847710"></p><ul><li>用户级线程：线程是在用户空间实现的（）</li><li>内核级线程：线程是在内核空间实现的</li></ul><p>线程的实现是什么意思？</p><p>进程有PCB，是进程的唯一标识。线程也有类似概念，线程控制块。线程的实现就是线程控制块在用户空间实现的还是在内核空间实现的。</p><h2 id="2-进程是怎么运行的"><a href="#2-进程是怎么运行的" class="headerlink" title="2 进程是怎么运行的"></a>2 进程是怎么运行的</h2><h3 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 进程的状态</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417155310763.png" alt="image-20240417155310763"></p><p><strong>就绪</strong>（Ready）</p><p>可运行但未运行：没有CPU使用权，内存准备好了</p><p><strong>执行</strong></p><p>举例：执行状态需要进行I&#x2F;O操作时会进入阻塞状态。可以理解为让其它硬件进行操作</p><p><strong>阻塞</strong></p><p>会有很多的阻塞队列，I&#x2F;O请求相关的阻塞队列，或者其它的阻塞队列</p><p>从阻塞状态不能直接到执行状态，会先到就绪状态</p><p><strong>创建和终止状态</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417160214462.png" alt="image-20240417160214462"></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>OS对进程实现有效的管理，包括创建新进程，撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过<code>原语</code>操作实现进程控制。</p><p><strong>原语的概念：</strong>由若干条指令组成，完成特定的功能，是一种<code>原子</code>操作</p><p><strong>原语的特点：</strong></p><ul><li><p>原子操作，要么全做，执行过程不会被中断</p></li><li><p>在内核态下执行，常驻内存，是内核程序</p></li><li><p>是内核三大支撑功能之一（中断处理、时钟管理、原语操作）</p></li></ul><p><strong>进程控制相关原语：</strong>可以看作是函数</p><ul><li>创建原语：<code>create</code></li><li>阻塞原语：<code>bolck</code></li><li>唤醒原语：<code>wakeup</code></li><li>撤销原语：<code>destroy</code></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417161838304.png" alt="image-20240417161838304"></p><p><strong>进程控制的操作：</strong>挂起与激活。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417162421668.png" alt="image-20240417162421668"></p><p>为了系统和用户用户观察和分析进程（查看CPU资源、内存等）</p><p><strong>挂起：</strong>把进程数据从内存放到外存（磁盘）</p><p>挂起原语：<code>suspend</code></p><ul><li>静止就绪：放外存，不调度</li><li>静止阻塞：等待事件</li></ul><p><strong>激活</strong></p><p>激活原语：<code>active</code></p><ul><li>活动就绪：等待调度</li><li>活动阻塞：等待唤醒</li></ul><h3 id="2-3-进程调度"><a href="#2-3-进程调度" class="headerlink" title="2.3 进程调度"></a>2.3 进程调度</h3><p>根据一定的算法和原则将处理器资源进行重新分配的过程</p><p><strong>前提：</strong>作业&#x2F;进程数远远大于处理器数</p><p><strong>目的：</strong>提高资源利用率，减少处理器空间时间</p><p><strong>调度程序：</strong>一方面要满足特定系统用户的需求（快速响应），另一方面要考虑系统整体效率（系统平均周转时间）和调度算法本身的开销</p><p><strong>调度的层次：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417164041803.png" alt="image-20240417164041803"></p><p>高级调度&#x2F;作业调度：把外存中的应用程序加载到内存中作为进程。比如执行 <code>.exe</code>文件</p><ul><li>把后备作业调入内存</li><li>只调入一次，调出一次</li></ul><p>中级调度&#x2F;内存调度</p><ul><li>将进程调至外存，条件合适再调入内存</li><li>在内、外存对换区进行进程对换</li></ul><p>低级调度&#x2F;进程调度</p><ul><li>从就绪队列选取进程分配给处理机</li><li>最基本的调度，频率非常高（相当于一个时间片完成）</li></ul><p><strong>调度方式</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417164839841.png" alt="image-20240417164839841"></p><p>剥夺式&#x2F;抢占式调度</p><ul><li>立即暂定当前进程</li><li>分配处理机给另一个进程</li><li>原则：优先权&#x2F;短进程优先&#x2F;时间片原则（同时多个遵循多个原则）</li></ul><p>非剥夺&#x2F;非抢占式调度</p><ul><li>若有进程请求执行</li><li>等待直到当前进程完成或阻塞</li><li>特点：适用于批处理系统，不适用分时&#x2F;实时系统</li></ul><p><strong>调度时机</strong></p><ul><li><p>进程运行完毕</p></li><li><p>进程时间片用完</p></li><li><p>进程要求I&#x2F;O操作</p></li><li><p>执行某种原语操作</p></li><li><p>高优先级进程申请运行（剥夺式调度）</p></li></ul><p><strong>调度过程</strong></p><ul><li>保存镜像：记录进程现场信息</li><li>调度算法：确定分配处理机的原则</li><li>进程切换：分配处理机给其它进程</li><li>处理机回收：从进程收回处理机</li></ul><p><strong>调度算法指标</strong></p><ul><li>CPU利用率：忙碌时间&#x2F;总时间</li><li>系统吞吐量：完成作业数&#x2F;总时间</li><li>周转时间</li><li>等待时间</li><li>响应时间</li></ul><h3 id="2-4-调度算法"><a href="#2-4-调度算法" class="headerlink" title="2.4 调度算法"></a>2.4 调度算法</h3><h2 id="3-进程之间是怎么协作的？"><a href="#3-进程之间是怎么协作的？" class="headerlink" title="3  进程之间是怎么协作的？"></a>3  进程之间是怎么协作的？</h2><h3 id="3-1-进程通信"><a href="#3-1-进程通信" class="headerlink" title="3.1 进程通信"></a>3.1 进程通信</h3><p>概念：进程通信即进程间的信息交换</p><ul><li>进程是资源分配的基本单位，各进程内存空间彼此独立</li><li>一个进程不能随意访问其它进程的地址空间</li></ul><p>同一个计算机内部有三种方式：</p><p><strong>共享存储</strong>：收发双方不可见，存在安全隐患</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417201640286.png" alt="image-20240417201640286"></p><ul><li><p>基于<code>共享数据结构</code>的通信方式</p><ul><li>多个进程供用某个数据结构（OS提供并控制）</li><li>由用户（程序员）负责同步处理</li><li>可以传递少量数据，效率低</li></ul></li><li><p>基于<code>共享存储区</code>的通信方式</p><ul><li>多个进程共用内存中的一块存储区域</li><li>由进程控制数据的形式和方式</li><li>可以传递大量数据，效率高</li></ul></li></ul><p><strong>消息传递</strong>：</p><ul><li><p>直接通信：点到点发送</p><ul><li>发送和接收时指明双方进程的ID</li><li>每个进程维护一个消息缓冲队列</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417201553901.png" alt="image-20240417201553901"></p></li><li><p>间接通信：广播信箱</p><ul><li>以信箱为媒介，作为中间实体</li><li>发进程将消息发送到信箱，收进程从信箱读取</li><li>可以广播，容易简历双向通信链</li></ul></li></ul><p><strong>管道通信</strong>：就是用一个pipe文件操作</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417202828028.png" alt="image-20240417202828028"></p><ul><li><p>用于连接读&#x2F;写进程的共享文件，pipe文件</p></li><li><p>本质是内存中固定大小的缓存区</p></li><li><p>同一时段只能单向通信（半双工通信），双工通信需要两个管道</p></li><li><p>以先进先出（FIFO）方式组织数据传输</p></li><li><p>通过系统调用read()&#x2F;write()函数进行读写操作</p></li></ul><blockquote><p>还有其它通信方式如Socket编程、套接字等用于不同计算机通信</p></blockquote><h3 id="3-2-进程同步"><a href="#3-2-进程同步" class="headerlink" title="3.2 进程同步"></a>3.2 进程同步</h3><p><strong>概念：</strong>协调进程间的相互制约关系，使他们按照预期的方式执行的过程</p><p><strong>前提：</strong></p><ul><li>进程是并发执行的，进程间存在着相互制约的关系</li><li>并发的进程对系统共享资源进行竞争</li><li>进程通信，过程中相互发送的信号称为消息或事件</li></ul><p><strong>两种相互制约形式：</strong></p><ul><li>间接相互制约关系（互斥）：进程排他性地访问共享资源</li><li>直接相互制约关系（同步）：进程间的合作，比如管道通信</li></ul><p><strong>互斥访问过程</strong>：互斥的访问临界资源</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240417210558701.png" alt="image-20240417210558701"></p><ul><li>进入区：尝试进入临界区，成功则加锁(lock)</li><li>临界区：访问共享资源</li><li>退出区：解锁(unlock)，唤醒其它阻塞进程</li><li>剩余区：其它代码</li></ul><blockquote><p>临界区&#x2F;临界资源：输入机&#x2F;打印机&#x2F;磁带机;消息缓冲队列&#x2F;变量&#x2F;数组&#x2F;缓冲区</p></blockquote><p><strong>互斥的访问原则</strong></p><ul><li>空闲让进：临界区空闲，允许一个进程进入</li><li>忙则等待：临近区已有进程，其它进程等待，操作系统操作的是进程的PCB，此处是把进程的PCB放进队列（阻塞状态，阻塞队列）</li><li>有限等待：处于等待的进程，等待时间有限</li><li>让权等待：等待时应让出CPU执行权，防止”忙等待“（虽然在等待，但是没有让出CPU的执行权）</li></ul><p>实现同步的方式：</p><p><strong>信号量</strong></p><p>PV操作：</p><ul><li>P操作：wait原语，进程等待</li><li>V操作：signal原语，唤醒等待线程</li></ul><p>整型信号量：违背”让权等待“，会发生忙等</p><p>记录型信号量：进程进入阻塞状态，不会忙等（加一个标志位，记录剩余资源数量）</p><p><strong>管程</strong></p><p>“管理进程”，即用于实现进程同步的工具。是由代表共享资源的数据结构和一组过程（进行PV操作的函数）组成的管理程序（封装）</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419095329787.png" alt="image-20240419095329787"></p><p>管程的组成：</p><ul><li>管程名称</li><li>局部于莞城内部的共享数据结构</li><li>对该数据结构操作的一组过程（函数）</li><li>管程内共享数据的初始化语句</li></ul><p>管程的特征：</p><ul><li>是一个模块化的基本程序单位，可以单独编译</li><li>是一种抽象数据类型（类），包含数据和操作</li><li>信息掩蔽（封装），共享数据只能被管程内的过程访问</li></ul><h2 id="4-如何处理死锁问题"><a href="#4-如何处理死锁问题" class="headerlink" title="4 如何处理死锁问题"></a>4 如何处理死锁问题</h2><h3 id="4-1-死锁的概念"><a href="#4-1-死锁的概念" class="headerlink" title="4.1 死锁的概念"></a>4.1 死锁的概念</h3><p><strong>定义</strong>：多个进程由于竞争资源而造成的阻塞现象，若无外力作用，这些进程将无法继续推进</p><p><strong>相似概念</strong>：饥饿</p><p>等待时间过长以至于给进程推进和响应带来明显影响，“饿而不死”</p><p><strong>死锁产生的原因</strong>：</p><ul><li>系统资源的竞争：多个进程竞争共享资源</li><li>进程推进顺序非法</li></ul><p><strong>死锁产生的必要条件：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419101606486.png" alt="image-20240419101606486"></p><ul><li>互斥条件：共享资源的排他性访问</li><li>不剥夺条件：访问时该共享资源不会被剥夺</li><li>请求并保持条件：保持当前资源时请求另一个资源</li><li>循环等待条件：存在共享资源的循环等待链</li></ul><h3 id="4-2-死锁的预防与处理"><a href="#4-2-死锁的预防与处理" class="headerlink" title="4.2 死锁的预防与处理"></a>4.2 死锁的预防与处理</h3><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><p><strong>破坏互斥条件</strong></p><ul><li>将只能互斥访问的资源改为同时共享访问</li><li>将独占锁改为共享锁</li><li>注意：不是所有资源都能改成共享的</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419102649641.png" alt="image-20240419102649641"></p><p><strong>破坏不剥夺条件</strong></p><ul><li>请求新资源无法满足时必须释放已有资源</li><li>由OS协助强制剥夺某些进程持有的资源</li><li>实现复杂，代价高。此操作过多会导致原进程任务无法推进（原进程请求另一个资源时获取不到，会释放当前已有资源。等到下次执行时，会重新获取上一次已有的资源，这样就导致上一次的操作浪费，增加系统开销）</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419103554896.png" alt="image-20240419103554896"></p><p><strong>破坏请求并保持条件</strong></p><ul><li><p>进程开始运行时一次性申请所需资源</p><ul><li>资源浪费</li><li>进程饥饿</li></ul></li><li><p>阶段性请求和释放资源</p></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419104026340.png" alt="image-20240419104026340"></p><p><strong>破坏循环等待条件</strong></p><ul><li>对所有资源现行排序，按序号请求资源<ul><li>请求时先低再高</li><li>释放时先高再低</li></ul></li><li>对资源的编号应相对稳定，限制了新设备增加</li><li>进程使用资源的顺序可能与系统编号顺序不同</li><li>限制了用户编程</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419104319567.png" alt="image-20240419104319567"></p><h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><p>系统安全状态</p><ul><li>安全状态一定不会出现死锁</li><li>不安全状态可能出现死锁</li></ul><p>安全性算法：<strong>银行家算法</strong></p><ul><li>系统预判进程请求是否导致不安全状态</li><li>是则拒绝请求，否则答应请求</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419104927807.png" alt="image-20240419104927807"></p><h3 id="4-3-死锁的检测与解除"><a href="#4-3-死锁的检测与解除" class="headerlink" title="4.3 死锁的检测与解除"></a>4.3 死锁的检测与解除</h3><p><strong>死锁的检测</strong></p><ul><li><p>需要一种数据结构，保存有关资源的请求和分配信息</p></li><li><p>提供一种算法，利用这些信息检测是否形成了死锁</p></li></ul><p>资源分配图：两种资源、两种节点</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419111127529.png" alt="image-20240419111127529"></p><p>死锁定理：死锁状态的充分条件</p><ul><li>当且仅当此状态下资源分配图是<code>不可完全简化</code>的</li><li>简化过程类似于图的拓扑排序算法</li></ul><p><strong>死锁解除</strong></p><ul><li>资源剥夺<ul><li>挂起死锁进程</li><li>剥夺其资源</li><li>将资源分配给其它（死锁）进程</li></ul></li><li>撤销进程</li><li>进程回退<ul><li>回退到足以避免死锁的地步</li><li>需要记录进程历史信息，设置还原点</li></ul></li></ul><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="1-什么是内存管理"><a href="#1-什么是内存管理" class="headerlink" title="1 什么是内存管理"></a>1 什么是内存管理</h2><h3 id="1-1-存储器的多层结构"><a href="#1-1-存储器的多层结构" class="headerlink" title="1.1 存储器的多层结构"></a>1.1 存储器的多层结构</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419122518374.png" alt="image-20240419122518374"></p><ul><li>CPU寄存器</li><li>高速缓存（独立硬件，不是内存条的一部分，效率比寄存器低，比主存储器高）</li><li>主存储器（内存条）</li><li>硬盘缓存（缓冲地带，做临时存储，从物理上是属于硬盘的一部分，进程suspend后放在外存，就是这里）</li><li>固定磁盘（磁盘）</li><li>可移动存储介质（U盘）</li></ul><h3 id="1-2-进程运行的基本原理"><a href="#1-2-进程运行的基本原理" class="headerlink" title="1.2 进程运行的基本原理"></a>1.2 进程运行的基本原理</h3><p>用户程序-&gt;进程：编译、链接、装入</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419123510656.png" alt="image-20240419123510656"></p><p><strong>编译</strong></p><p>程序员完成，将代码编译成二进制指令</p><p><strong>链接</strong></p><p>将编译生成的各个模块和底层函数库进行打包封装，生成可装入模块</p><ul><li>静态链接</li><li>装入时动态链接</li><li>运行时动态链接</li></ul><p><strong>装入</strong></p><ul><li>绝对装入</li><li>可重定位装入</li><li>动态运行时装入</li></ul><p>两个细节</p><ul><li>逻辑地址（代码的地址）与物理地址（内存中的地址）：前面有程序已经装入了，但是写程序时是按0地址开始的，这样就导致在装入时需要加上起始量</li><li>内存保护（装入过程中，保护当前地址不受其它应用程序影响）</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419125447669.png" alt="image-20240419125447669"></p><h2 id="2-内存的分配"><a href="#2-内存的分配" class="headerlink" title="2 内存的分配"></a>2 内存的分配</h2><h3 id="2-1-连续分配方式"><a href="#2-1-连续分配方式" class="headerlink" title="2.1 连续分配方式"></a>2.1 连续分配方式</h3><p><strong>单一连续分配</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419131352084.png" alt="image-20240419131352084"></p><p>只有一个用户进程</p><p><strong>优点：</strong></p><ul><li>实现简单</li><li>无外部碎片</li><li>不一定需要内存保护</li></ul><p><strong>缺点：</strong></p><ul><li><p>只能用于单用户、单任务OS</p></li><li><p>有内部碎片</p></li><li><p>存储器利用率低</p></li></ul><p><strong>固定分区分配</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419132750864.png" alt="image-20240419132750864"></p><p>优点：</p><ul><li>实现简单</li><li>无外部碎片</li></ul><p>缺点：</p><ul><li>较大用户程序时，需要采用覆盖技术，降低了性能</li><li>会产生内部碎片，利用率低</li></ul><p><strong>动态分区分配</strong></p><ul><li>怎么记录内存中的使用情况<ul><li>空闲分区表</li><li>空闲分区链</li></ul></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419151250104.png" alt="image-20240419151250104"></p><ul><li><p>选择哪个分区给新进程</p><p>常用算法：</p><ul><li>首次适应算法：从低地址查找合适空间</li><li>最佳适应算法：优先使用最小空闲空间</li><li>最大适应算法：优先使用最大连续空间</li><li>临近适应算法：从上次查找出向后查找</li></ul></li><li><p>已使用的分区怎么回收</p></li></ul><h3 id="2-2-非连续分配方式"><a href="#2-2-非连续分配方式" class="headerlink" title="2.2 非连续分配方式"></a>2.2 非连续分配方式</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419153327503.png" alt="image-20240419153327503"></p><p><strong>基本分页存储管理方式</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419153638000.png" alt="image-20240419153638000"></p><p><strong>将内存分为大小相等的分区：页&#x2F;页框</strong></p><ul><li><p>页框号从0开始</p></li><li><p>OS以页框为基本单位分配内存</p></li><li><p>不会产生外部碎片，但会产生内部碎片，但一般一个进程产生的内部碎片大小不超过半个页框的大小，此处就是2K</p></li><li><p>逻辑地址和物理地址的对于关系存在于页表中，页表存在于进程的PCB中，使用基本地址变换机构进行逻辑地址和物理地址的转换</p></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419155350962.png" alt="image-20240419155350962"></p><p><strong>基本分段存储管理方式</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419160543977.png" alt="image-20240419160543977"></p><p><strong>段页式管理方式</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419162018902.png" alt="image-20240419162018902"></p><h2 id="3-虚拟内存管理"><a href="#3-虚拟内存管理" class="headerlink" title="3 虚拟内存管理"></a>3 虚拟内存管理</h2><h3 id="3-1-虚拟内存的基本概念"><a href="#3-1-虚拟内存的基本概念" class="headerlink" title="3.1 虚拟内存的基本概念"></a>3.1 虚拟内存的基本概念</h3><p>具有请求调入和置换功能，从逻辑上对内存容量加以扩充的一种存储器系统</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240419163046746.png" alt="image-20240419163046746"></p><p>局部性原理：</p><ul><li>时间局部性</li><li>空间局部性</li></ul><p>虚拟内存的特征</p><ul><li>多次性</li><li>对换性</li><li>虚拟性</li></ul><h3 id="3-2-虚拟内存的实现"><a href="#3-2-虚拟内存的实现" class="headerlink" title="3.2 虚拟内存的实现"></a>3.2 虚拟内存的实现</h3><p><strong>请求分页存储管理</strong></p><p><strong>请求分段存储管理</strong></p><p><strong>请求段页式存储管理</strong></p><h1 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h1><h2 id="1-什么是操作系统-1"><a href="#1-什么是操作系统-1" class="headerlink" title="1 什么是操作系统"></a>1 什么是操作系统</h2><p>操作系统是一种运行在<code>内核态</code>的软件</p><p>它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-eee82952-c96f-45c9-835e-29db37c0f6d8.png" alt="操作系统主要功能"></p><h2 id="2-操作系统有哪些功能"><a href="#2-操作系统有哪些功能" class="headerlink" title="2 操作系统有哪些功能"></a>2 操作系统有哪些功能</h2><p>操作系统最主要的功能： </p><ul><li>处理器(cpu)管理：CPU的管理和分配，主要是指进程管理</li><li>内存管理：内存的分配和管理，主要利用了虚拟内存的方式</li><li>外存管理：外存（磁盘等）的分配和管理</li><li>I&#x2F;O管理：对输入&#x2F;输出设备的统一管理</li></ul><p>除此之外，还有防止非法操作和入侵的安全性管理。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-eee82952-c96f-45c9-835e-29db37c0f6d8.png" alt="操作系统主要功能"></p><h2 id="3-什么是内核"><a href="#3-什么是内核" class="headerlink" title="3 什么是内核"></a>3 什么是内核</h2><p>内核是计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容（CPU、内存、硬盘等硬件）</p><h2 id="4-内核态和用户态"><a href="#4-内核态和用户态" class="headerlink" title="4 内核态和用户态"></a>4 内核态和用户态</h2><p>内核具有很高的权限，可以控制CPU、内存、硬盘等硬件，考虑到权限控制，大多数操作系统把内存分成了两个区域：</p><ul><li>内核空间：这个内存空间只有内核程序可以访问</li><li>用户空间：这个内存空间专门给应用程序使用，权限比较小</li></ul><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。所以，当程序使用用户空间时，就说该程序在<code>用户态</code>执行，当程序使用内核空间时，程序在<code>内核态</code>执行。</p><h2 id="5-内核态和用户态切换"><a href="#5-内核态和用户态切换" class="headerlink" title="5 内核态和用户态切换"></a>5 内核态和用户态切换</h2><p>用户态进入到内核态有三种情况：</p><ul><li>系统调用（主动请求）：当应用程序使用系统调用时，会产生一个中断。发生中断后，CPU会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把CPU执行权限交回给用户程序，回到用户态继续工作。</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/os-b358cdae-18b6-45d4-8a5b-4ea3a7cfc273.png" alt="用户态&amp;内核态切换"></p><ul><li>异常（被动）：当程序在用户态下运行时，发生了某些异常，这时会从用户程序切换到内核中处理该异常的程序，也就是切换到了内核态</li><li>外设产生中断（被动）：外设发出中断信号，当中断发生后，当前运行的进程暂停运行，并且操作系统内核对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态切换到了内核态。<ul><li>举例：硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作</li></ul></li></ul><h2 id="6-外中断和异常有什么区别？"><a href="#6-外中断和异常有什么区别？" class="headerlink" title="6 外中断和异常有什么区别？"></a>6 外中断和异常有什么区别？</h2><p>外中断是指由CPU执行指令以外的事件引起，如I&#x2F;O完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p><p>异常是由CPU产生的，如非法操作码、地址越界、算术溢出、除0等。</p><h2 id="6-并行和并发"><a href="#6-并行和并发" class="headerlink" title="6 并行和并发"></a>6 并行和并发</h2><p><strong>并发：</strong>并发就是在一段时间内，多个任务都会被处理；但是在某一时刻，只有一个任务在执行。</p><ul><li>单核处理器做到的并发，其实就是利用时间片的轮转。例如有两个进程A和B，A运行一个时间片后，切换到B，B运行一个时间片后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</li></ul><p><strong>并行：</strong>在同一时刻，有多个任务在执行。</p><ul><li>如果是在一个处理器：这需要多核处理器才能完成，在微观上就能同时执行多个任务。</li><li>如果是在不同处理器：这个是物理上的多个进程同时进行</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/os-fb7891d8-8330-494b-9bc1-cf829b5cc82d.png" alt="并发和并行"></p><h2 id="7-进程的上下文切换"><a href="#7-进程的上下文切换" class="headerlink" title="7 进程的上下文切换"></a>7 进程的上下文切换</h2><p>对于单核单线程CPU来说，在某一时刻只能执行一条CPU指令。上下文切换就是一种将CPU资源从一个进程分配给另一个进程的机制。在切换的过程中，操作系统需要先存储当前进程的状态（包括内存空间的指针，当前执行完的指令等等），再读入下一个进程的状态，然后执行此进程。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-187d1cf9-971d-4395-b888-5e6eaf2be5f1.png" alt="进程上下文切换"></p><h2 id="8-进程有哪些状态"><a href="#8-进程有哪些状态" class="headerlink" title="8 进程有哪些状态"></a>8 进程有哪些状态</h2><p>当一个进程开始运行时，它可能会经历下面这几种状态：</p><ul><li>运行态：该时刻进行占用CPU；</li><li>就绪态：可运行，由于其它进程处于运行态而暂时停止运行</li><li>阻塞态：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时即使给它CPU控制权，它也无法运行</li><li>创建状态：进程正在被创建时的状态</li><li>结束状态：进程正在从系统中消失时的状态</li></ul><p>注意：</p><ul><li><p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；运行状态的进程在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。</p></li><li><p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态。</p></li></ul><p><img src="/../imgs/$%7Bfiilename%7D/os-ae17a9dc-f555-481a-ba4a-caca06120be7.png" alt="进程5种状态"></p><h2 id="9-进程如何控制"><a href="#9-进程如何控制" class="headerlink" title="9 进程如何控制"></a>9 进程如何控制</h2><p>操作系统对进程的进行控制，包括创建新进程，撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。通过<code>原语</code>操作实现进程控制。</p><p>原语：由若干条指令组成，完成特定的功能，是一种原子操作（做就全做，执行过程不会被中断）</p><p>进程控制相关原语：</p><ul><li>创建：<code>create</code></li><li>阻塞：<code>bolck</code></li><li>唤醒：<code>wakeup</code></li><li>撤销：<code>destroy</code></li></ul><h2 id="10-僵尸进程"><a href="#10-僵尸进程" class="headerlink" title="10 僵尸进程"></a>10 僵尸进程</h2><p>僵尸进程是已完成且处于终止状态，但在进程表中仍然存在的进程。</p><p>僵尸进程一般发生在有父子关系的进程中，一个子进程的进程描述符在子进程中退出时不会释放，只有当父进程通过<code>wait()</code>或<code>waitpid()</code>获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用<code>wait()</code>或<code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，此时子进程就是一个僵尸进程。</p><h2 id="11-孤儿进程"><a href="#11-孤儿进程" class="headerlink" title="11 孤儿进程"></a>11 孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被<code>init</code>进程（进程ID为1的进程）所收养，并由<code>init</code>进程对它们完成状态收集工作。因为孤儿进程会被<code>init</code>进程收养，所以孤儿进程不会对系统造成危害</p><h2 id="12-进程有哪些调度算法"><a href="#12-进程有哪些调度算法" class="headerlink" title="12 进程有哪些调度算法"></a>12 进程有哪些调度算法</h2><p><strong>先来先服务</strong></p><p>也成为先进先出（FIFO）。进程按照请求CPU的顺序进行调度。这种方式易于实现，但可能会导致较短的进程等待较长进程执行完成，从而产生”饥饿“现象。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-93088d03-80c9-46c5-9eaf-eead2adb6e12.png" alt="先来先服务"></p><p><strong>短作业优先</strong></p><p>选择预计运行时间最短的进程优先执行。这种方式可以减少平均等待时间和响应时间，但缺点是很难准确预知进程的执行时间，并且可能因为短作业一直在执行，导致长作业持续被推迟执行。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-517e8392-64fe-4de3-9e1c-b3a944822aba.png" alt="短作业优先"></p><p><strong>优先级调度</strong></p><p>在这种调度方式中，每个进程都被分配一个有优先级。CPU首先分配给优先级最高的进程。优先级调度可以是抢占式或非抢占式的。在非抢占式优先级调度中，进程一旦开始执行将一直运行直到完成。在抢占式优先级调度中，更高优先级的进程可以中断正在执行的低优先级进程。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-7c4441cf-7b8c-4660-8ba8-29b8076e2da1.png" alt="优先级调度"></p><p><strong>时间片轮转</strong></p><p>时间片轮转调度为每个进程分配一个固定的时间端，成为时间片，进程可以在这个时间片内运行。如果进程在时间片结束时还没有完成，它将被放回队列的末尾。时间片轮转是公平的调度方式，可以保证所有的进程得到公平的CPU时间，适用于共享系统。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-ad224c3a-8ac9-4230-84e4-ec434d5b49f9.png" alt="时间片轮转"></p><p><strong>最短剩余时间优先</strong></p><p>短作业优先的一种改进形式，它是抢占式的。即如果一个新进程的预计执行时间比当前运行进程的剩余时间短，调度器将暂停当前的进程，并切换到新进程。这种方法也可以最小化平均等待时间，但同样面临预测执行时间的困难。</p><p><strong>多级反馈队列</strong></p><h2 id="13-进程间通信方式"><a href="#13-进程间通信方式" class="headerlink" title="13 进程间通信方式"></a>13 进程间通信方式</h2><p>管道、信号、消息队列、共享内存、信号量、套接字</p><p><img src="/../imgs/$%7Bfiilename%7D/os-20240314073226.png" alt="进程间通信"></p><p><strong>管道：</strong>管道可以理解成不同进程之间的传话筒，一方发声，一方接受。</p><p>进程间的管道就是内核中的一串缓存。从管道的一端写入数据，另一端读取。数据只能单向流动，遵循先进先出的原则。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-20240314073535.png" alt="管道"></p><ul><li>匿名管道（内存文件）：数据只能单向流动，且只能具有亲缘关系的进程（如父子进程）进行通信。</li><li>命名管道（FIFO文件）：允许无亲缘关系的进程通信，通过在文件系统中创建一个FIFO的文件来实现。</li></ul><p>缺点：管道的效率低，不适合进程间频繁地交换数据。</p><p><strong>信号：</strong>信号可以理解成以前的BB机，用于通知接收进程某件事情发生了，主要用于处理异步事件。</p><p>比如<code>kill -9 1050</code>就表示给PID为1050的进程发送<code>SIGKIL</code>信号。</p><p><strong>消息队列：</strong>消息队列是保存在内核中的消息链表，按照消息的类型进行消息传递，具有较高的可靠性和稳定性。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-20240314075045.png" alt="消息队列"></p><p>缺点：消息体有一个最大长度的限制，不适合比较大的数据传输；存在用户态于内核态之间的数据拷贝开销。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-20240314075326.png" alt="消息队列"></p><p><strong>共享内存：</strong>允许两个或多个进程共享一个给定的内存区，一个进程写入的东西，其它进程马上就能看到。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-d9e3cfaf-01e7-42ff-9290-94ef4a5c7d5e.png" alt="共享内存"></p><p>缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题。</p><p><strong>信号量：</strong>信号量可以理解为红绿灯，红灯停（信号量为零），绿灯行（信号量非零）。它本质上是一个计数器，用来控制对共享资源的访问数量。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-5fb765af-918c-4037-a3ad-4cad4d985e16.png" alt="信号量"></p><p><strong>Socket：</strong>提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信</p><p><img src="/../imgs/$%7Bfiilename%7D/os-20240314082438.png" alt="Socket"></p><h2 id="14-异步和同步"><a href="#14-异步和同步" class="headerlink" title="14 异步和同步"></a>14 异步和同步</h2><p><strong>同步：</strong>同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。</p><p><strong>异步：</strong>异步和同步是相对的，异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><h2 id="15-阻塞和非阻塞"><a href="#15-阻塞和非阻塞" class="headerlink" title="15 阻塞和非阻塞"></a>15 阻塞和非阻塞</h2><p><strong>阻塞：</strong>简单说就是发出一个请求不能立刻返回响应，要等所有的逻辑全处理完才能返回响应。</p><p><strong>非阻塞：</strong>发出一个请求立刻返回应答，不用等处理完所有逻辑。</p><p>阻塞与非阻塞指的是<code>单个线程内</code>遇到同步等待时，是否在原地不做任何操作。</p><p>简单理解概念：</p><ul><li>同步阻塞：只有一个线程，而且该线程处于阻塞状态</li><li>同步非阻塞：只有一个线程，而且该线程处于运行状态</li><li>异步阻塞：有多个线程，所有线程都处于阻塞状态</li><li>异步非阻塞：有多个线程，所有线程都在正常运行</li></ul><h2 id="16-进程和线程的联系-区别"><a href="#16-进程和线程的联系-区别" class="headerlink" title="16 进程和线程的联系&#x2F;区别"></a>16 进程和线程的联系&#x2F;区别</h2><p><strong>进程：</strong>进程是程序的一次执行，是系统进行资源分配和的一个基本单位。</p><p><strong>线程：</strong>线程是进程当中的一条执行流程</p><p><strong>联系：</strong>同一个进程内多个线程之间共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-271e450b-66ef-4f6c-b823-8e0b73347825.png" alt="多线程"></p><p><strong>区别：</strong></p><ul><li>调度：进程是资源（内存、打开的文件等）分配的单位，线程是CPU调度的单位；</li><li>资源：进程拥有一个完整的资源平台，而线程只独享必不可少的的资源，如寄存器和栈</li><li>状态：线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>系统开销：线程能减少并发执行的时间和空间开销—创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间、I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ul><h2 id="17-线程的上下文切换"><a href="#17-线程的上下文切换" class="headerlink" title="17 线程的上下文切换"></a>17 线程的上下文切换</h2><p>线程的上下文切换得看是不是属于同一个进程：</p><ul><li>当两个线程不属于同一个进程：则切换的过程和进程上下文切换一样</li><li>当两个线程属于同一个进程：因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ul><h2 id="18-线程的实现方式"><a href="#18-线程的实现方式" class="headerlink" title="18 线程的实现方式"></a>18 线程的实现方式</h2><p>主要有三种线程的实现方式：</p><p><strong>内核态线程实现：</strong>在内核空间实现的线程，由内核直接管理线程</p><p><img src="/../imgs/$%7Bfiilename%7D/os-30b84285-8027-4720-b50b-3b0fb18c756f.png" alt="内核态线程实现"></p><p><strong>用户态线程实现：</strong>在用户空间实现线程，不需要内核的参与，内核对线程无感知</p><p><img src="/../imgs/$%7Bfiilename%7D/os-57886181-56fe-42bf-85e1-4d062455788a.png" alt="用户态线程"></p><p><strong>混合线程实现：</strong>用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程时的切换。即同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-1597d159-1b07-48ae-ac86-7e9b9cb85876.png" alt="混合线程实现"></p><h2 id="19-线程间如何同步"><a href="#19-线程间如何同步" class="headerlink" title="19 线程间如何同步"></a>19 线程间如何同步</h2><p>同步解决的是多线程操作共享资源的问题。目的是不管线程之间的执行如何穿插，最后的结果都是正确的。</p><p><strong>临界区：</strong>把对共享资源访问的程序片段称为<code>临界区</code>，我们希望这段代码是<code>互斥</code>的，保证在某时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该阻止进入临界区。</p><p>临界区不仅针对线程，还针对进程。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-48a5b48b-2474-4460-ac5b-9502883b353f.png" alt="临界区互斥"></p><p><strong>锁</strong>：使用加锁操作和解锁操作可以解决并发线程&#x2F;进程的互斥问题</p><p>任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。</p><p>加锁和解锁锁住的是什么呢？可以是<code>临界区对象</code>，也可以是一个简单的<code>互斥量</code>，例如互斥量是<code>0</code>无锁，<code>1</code>表示加锁。</p><p>根据锁的实现不同，可以分为<code>忙等待锁</code>和<code>无忙等待锁</code></p><ul><li>忙等待锁（自旋锁）：加锁失败的线程，会不断尝试获取锁，会一直占用CPU</li><li>无忙等待锁：加锁失败的线程，会进入阻塞状态，放弃CPU使用权，等待被调度。</li></ul><p><strong>信号量：</strong>信号量是操作系统提供的⼀种协调共享资源访问的⽅法。通常信号量表示资源的数量，对应的变量是一个整型(sem)变量。</p><p>另外，还有两个原子操作的系统调用函数来控制信号量的，分别是：</p><ul><li>P操作：当进程希望获取资源时，它会执行 P 操作。如果sem的值大于 0，表示有资源可用，信号量的值减 1，进程继续执行。如果sem的值为 0，表示没有可用资源，进程进入等待状态，直到sem的值变为大于 0；</li><li>V操作：当进程释放资源时，它会执行 V 操作，sem的值加 1。如果有其他进程因为等待该资源而被阻塞，这时会唤醒其中一个进程。</li></ul><p>P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。</p><h2 id="20-什么是死锁"><a href="#20-什么是死锁" class="headerlink" title="20 什么是死锁"></a>20 什么是死锁</h2><p>在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或者它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无期限的阻塞、相互等待的一种状态。</p><p><img src="/../imgs/$%7Bfiilename%7D/os-e0069c37-d758-4df0-a2fd-3722ec93c61a.png" alt="死锁"></p><h2 id="21-死锁产生的条件"><a href="#21-死锁产生的条件" class="headerlink" title="21 死锁产生的条件"></a>21 死锁产生的条件</h2><p>死锁产生需要<strong>同时</strong>满足四个条件：</p><ul><li>互斥条件：共享资源的排他性访问</li><li>不可剥夺条件：访问时该共享资源不会被剥夺</li><li>请求并保持条件：保持当前资源时请求另一个资源</li><li>循环等待条件：存在共享资源的循环等待链</li></ul><h2 id="22-如何避免死锁"><a href="#22-如何避免死锁" class="headerlink" title="22 如何避免死锁"></a>22 如何避免死锁</h2><p>产生死锁有四个必要条件，避免死锁，破坏其中的任何一个就可以</p><p><strong>消除互斥条件：</strong>将独享的资源改成共享的，但是很多情况下，资源是无法改成共享的。</p><p><strong>消除不可剥夺条件：</strong>占用部分资源的线程进一步申请其它资源时，如果申请不到，可以主动释放它占有的资源</p><p><strong>消除请求并保持条件：</strong>一个线程一次请求其所需要的所有资源&#x2F;或者阶段性请求释放资源</p><p><strong>消除循环等待条件：</strong>对资源按序申请。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在循环了。</p><h2 id="23-几种典型的锁"><a href="#23-几种典型的锁" class="headerlink" title="23 几种典型的锁"></a>23 几种典型的锁</h2><p><strong>活锁：</strong>在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活锁组的线程无法推进。</p><p>举例：活锁可以用两个人过一条很窄的小桥来比喻：为了让对方先过，两个人都往旁边让，但两个人总是让到 同一边。这样，虽然两个人的状态一直在变化，但却都无法往前推进。</p><p><strong>饥饿锁：</strong>这里的饥饿指的是资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进，就像一个人因为饥饿无法成长。</p><p><strong>读写锁：</strong></p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><p><strong>互斥锁</strong>：</p><p>一次只能一个线程拥有互斥锁，其它线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</p><p><strong>自旋锁：</strong></p><p>如果进程如法取得锁，线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</p><p>如果别的线程长时间占有锁，那么自旋锁就是在做无用功，因此自旋锁适用于加锁时间很短的场景。</p><h2 id="24-存储器的结构"><a href="#24-存储器的结构" class="headerlink" title="24 存储器的结构"></a>24 存储器的结构</h2><img src="../imgs/${fiilename}/image-20240419122518374.png" alt="image-20240419122518374" style="zoom: 50%;" /><ul><li>CPU寄存器</li><li>高速缓存（独立硬件，不是内存条的一部分，效率比寄存器低，比主存储器高）</li><li>主存储器（内存条）</li><li>硬盘缓存（缓冲地带，做临时存储，从物理上是属于硬盘的一部分，进程suspend后放在外存，就是这里）</li><li>固定磁盘（磁盘）</li><li>可移动存储介质（U盘）</li></ul><h2 id="25-什么是虚拟内存"><a href="#25-什么是虚拟内存" class="headerlink" title="25 什么是虚拟内存"></a>25 什么是虚拟内存</h2><img src="../imgs/${fiilename}/image-20240419163046746.png" alt="image-20240419163046746" style="zoom:50%;" /><p>如果两个进程都直接操作物理内存，这种情况下同时运行两个程序是不可能的，如果第一个程序在0x1234位置上写入了数据，将会擦掉另一个程序在该位置上写入的数据。如何避免？</p><p>可以把进程所使用的地址隔离开来，即让操作系统为每个进程分配独立的一套虚拟地址，互不干涉。操作系统负责虚拟地址和物理内存的映射。</p><p><strong>虚拟内存：</strong>操作系统的一种机制，将不同进程的虚拟内存地址和不同内存的物理内存地址映射起来</p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，就不会冲突了。</p><ul><li>虚拟内存地址：程序所使用的内存地址</li><li>物理内存地址：实际存在硬件里面的空间地址</li></ul><p><strong>操作系统是如何管理虚拟地址与物理地址之间的关系？</strong></p><p>主要有两种方式：内存分段、内存分页</p><h2 id="26-内存分段"><a href="#26-内存分段" class="headerlink" title="26 内存分段"></a>26 内存分段</h2><p>程序是由若干个逻辑分段组成的，可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成：段选择因子和段内偏移量</p><img src="../imgs/${fiilename}/a9ed979e2ed8414f9828767592aadc21.png" alt="img" style="zoom: 50%;" /><p>段选择因子：保存在段寄存器里面。段选择因子里面最重要的就是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。</p><p>段内偏移量应该位于0和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成4个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址：</p><img src="../imgs/${fiilename}/c5e2ab63e6ee4c8db575f3c7c9c85962.png" alt="img" style="zoom:50%;" /><p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500。</p><p>分段的缺点：</p><ul><li>内存碎片的问题</li><li>内存交换的效率低的问题</li></ul><p><strong>为什么会产生内存碎片问题？</strong></p><p>举个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p><ul><li>游戏占用了 512MB 内存</li><li>浏览器占用了 128MB 内存</li><li>音乐占用了 256 MB 内存。</li></ul><p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。</p><p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序</p><img src="../imgs/${fiilename}/6142bc3c917e4a6298bdb62936e0d332.png" alt="img" style="zoom:50%;" /><p>内存碎片主要分为：内部内存碎片、外部内存碎片</p><ul><li><p>内部内存碎片：内部碎片是由于系统分配给进程的空间大于其所申请的大小，处于区域内部的内存，占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块内存时，系统无法利用它。直到进程释放它或进程结束时，系统才有可能利用这块内存。</p></li><li><p>外部内存碎片：外部碎片是指还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p></li></ul><p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大内存，所以不会出现内部内存碎片。</p><p>但是由于每个段的长度不固定，所以多个段未必能刚好使用所有的内存空间，会产生多个不连续的内存，导致新的程序无法被装载，所以会出现外部内存碎片的问题。</p><p>解决外部内存碎片问题的方法就是内存交换。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p><p><strong>分段为什么会导致内存交换效率低的问题？</strong></p><p>因为硬盘的访问速度要比内存慢多了，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。</p><p>为了解决内存分段的外部内存碎片和内存交换效率低的问题，就出现了内存分页</p><blockquote><p>理解：把内存分成代码段、数据段、堆段、栈段，每一次执行程序时就分别申请各个段的一部分</p></blockquote><h2 id="27-内存分页"><a href="#27-内存分页" class="headerlink" title="27 内存分页"></a>27 内存分页</h2><h2 id="28-虚拟技术"><a href="#28-虚拟技术" class="headerlink" title="28 虚拟技术"></a>28 虚拟技术</h2><p>虚拟技术就是把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术（时间）、空分复用技术（空间）</p><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术：它将物理内存抽象为逻辑上的地址空间，每个进程都有自己的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><p>虚拟内存的目的：虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间，每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><blockquote><p>虚拟内存可以实现程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行。</p></blockquote><h2 id="29-逻辑地址和物理地址"><a href="#29-逻辑地址和物理地址" class="headerlink" title="29 逻辑地址和物理地址"></a>29 逻辑地址和物理地址</h2><p>举例：编译时只需要确定变量x存放的相对地址是100（相对于进程在内存中的起始地址而言的地址）。CPU想要访问x在内存中的实际存放位置，只需要用进程的起始地址+100即可。相对地址又称为逻辑地址，绝对地址又称为物理地址。</p><h2 id="30-内存覆盖"><a href="#30-内存覆盖" class="headerlink" title="30 内存覆盖"></a>30 内存覆盖</h2><p>由于程序运行时并非任何时候都要访问程序及数据的所有部分，所以可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其它段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p><p>特点：无须将一个进程的全部信息装入内存中才能运行。但是当同时运行的代码量大于主存时仍不能运行。</p><h2 id="31-内存交换"><a href="#31-内存交换" class="headerlink" title="31 内存交换"></a>31 内存交换</h2><p>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外村中某些已具备运行条件的进程换入内存。（进程在内存与磁盘空间动态调度）</p><p><strong>什么时候会进行内存交换：</strong></p><p>内存交换通常在许多进程运行且内存紧张时进行，系统负荷降低时暂停。</p><p><strong>内存交换和覆盖有什么区别</strong></p><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一进程或程序中。</p><p>参考：</p><p><a href="https://segmentfault.com/a/1190000022478666">https://segmentfault.com/a/1190000022478666</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2024/03/28/C++/"/>
    <url>/2024/03/28/C++/</url>
    
    <content type="html"><![CDATA[<h1 id="1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1 在main执行之前和之后执行的代码可能是什么？"></a>1 在main执行之前和之后执行的代码可能是什么？</h1><p><strong>main函数执行之前执行的代码</strong></p><ul><li>全局对象初始化，在main之前调用构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>A a;　　<span class="hljs-comment">//调用构造函数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>A<br>main<br></code></pre></td></tr></table></figure><ul><li>将main函数的参数argc、argv传给main函数，才算真正调用main函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; 函数体 &#125;  <span class="hljs-comment">//写法1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123; 函数体 &#125; <span class="hljs-comment">//写法2</span><br></code></pre></td></tr></table></figure><ul><li><code>__attribute__((constructor))</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>__attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beforeMainToRun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>beforeMainToRun  <br>main<br></code></pre></td></tr></table></figure><p><strong>main函数执行之后执行的代码</strong></p><ul><li>可以注册一个<code>atexit</code>函数，注册的函数会在main之后运行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-built_in">atexit</span>(func);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>main<br>func<br><br></code></pre></td></tr></table></figure><ul><li><code>__attribute__((destructor))</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">__attribute__((destructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">afterMainToRun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其它，如全局对象的析构函数</li></ul><h1 id="2-内存对齐问题？"><a href="#2-内存对齐问题？" class="headerlink" title="2 内存对齐问题？"></a>2 内存对齐问题？</h1><h2 id="1-什么是内存对齐"><a href="#1-什么是内存对齐" class="headerlink" title="1 什么是内存对齐"></a><strong>1 什么是内存对齐</strong></h2><p>元素是按照声明顺序一个一个放到内存中去的，但并不是紧密排列的。元素放置的地址一定会在自己宽度的整数倍上开始，即内存对齐。</p><blockquote><p>如果结构体是按8字节对齐的，处理器在读取这个结构体的数据时就是按8字节读取的。如果下一个结构体是按4字节对齐的，那么处理器读取下一个结构体时就是按4字节读取的。</p></blockquote><h2 id="2-为什么需要内存对齐？"><a href="#2-为什么需要内存对齐？" class="headerlink" title="2 为什么需要内存对齐？"></a><strong>2 为什么需要内存对齐？</strong></h2><p><strong>结论：</strong></p><ul><li>对齐与否会影响读取效率。</li><li>合理地利用对齐规则可以节省空间</li></ul><p><strong>a. 处理器是如何读取内存的？</strong></p><p>如果把内存看做是简单的字节数组，比如在C语言中，char *就可表示一块内存。那么它的内存读取方式可以按照1byte顺序读取：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165000175.png" alt="image-20240326165000175"></p><p>然而，尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的，这取决于数据类型和处理器的设置；它一般会以双字节,4字节,8字节,16字节甚至32字节的<code>块</code>来存取内存，这些存取单位称为<code>内存存取粒度</code></p><p><strong>b. 内存对齐、内存不对齐对比</strong></p><p>现在假设一个整型变量(4字节)不是自然对齐的，它的起始地址落在0x00000002（图中蓝色区域），处理器想要访问它的值，按照4字节的块进行读取，从图中的0x0起读，读取4字节大小，读到0x3</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165233475.png" alt="image-20240326165233475"></p><p>这样的一次读取之后，并不能取到要访问的整型数据，紧接着处理器会继续再往下读，偏移4个字节，从0x4开始，读到0x7</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165247530.png" alt="image-20240326165247530"></p><p>到这里，处理器才能读取到了需要访问的内存数据，这中间还存在剔除与合并的过程，读了两次才读到想要的数据。</p><p>如果是自然对齐的：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165431867.png" alt="image-20240326165431867"></p><p>读取一次就能读到想要的数据。<strong>对齐与否会影响读取效率。</strong></p><p><strong>c. 合理地利用对齐规则可以节省空间</strong></p><p>比如下列情况，结构体所占的字节数为24</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-type">int</span>   a;  <span class="hljs-comment">//4</span><br>  <span class="hljs-type">double</span>  b;  <span class="hljs-comment">//8</span><br>  <span class="hljs-type">short</span> c;  <span class="hljs-comment">//2</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl;  <span class="hljs-comment">// 24</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果把b和c交换一下位置，那么结构体所占的字节数为16</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-type">int</span>   a;  <span class="hljs-comment">//4</span><br>  <span class="hljs-type">short</span> c;  <span class="hljs-comment">//2</span><br>  <span class="hljs-type">double</span>  b;  <span class="hljs-comment">//8</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-内存对齐规则"><a href="#3-内存对齐规则" class="headerlink" title="3 内存对齐规则"></a>3 内存对齐规则</h2><ul><li>各成员变量存放的起始地址， 相对于结构体的起始地址的偏移量 ，必须为该变量的类型所占用的字节数的倍数；</li><li>各成员变量在存放的时候根据在结构体中声明的顺序依次申请空间， 同时按照上面的对齐方式调整位置， 空缺的字节自动填充</li><li>同时为了确保结构的大小为结构体的size最大成员的倍数，所以在为最后一个成员变量申请空间后 还会根据需要自动填充空缺的字节</li></ul><h2 id="4-影响内存对齐的因素"><a href="#4-影响内存对齐的因素" class="headerlink" title="4 影响内存对齐的因素"></a>4 影响内存对齐的因素</h2><p><strong>1.<code>#pragma pack(n)</code></strong></p><p>程序员可以通过预编译命令<code>#pragma pack(n)</code>，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是要指定的“对齐系数”。这里规定的是上界，只影响对齐单元大于n的成员，对于对齐字节不大于n的成员没有影响。</p><p>通过预编译命令<code>#pragma pack()</code>取消自定义字节对齐方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2) <span class="hljs-comment">//让编译器对这个结构作2字节对齐</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span><br>&#123;<br><span class="hljs-type">char</span> x1;  <span class="hljs-comment">//1</span><br><span class="hljs-type">short</span> x2; <span class="hljs-comment">//2</span><br><span class="hljs-type">float</span> x3; <span class="hljs-comment">//4</span><br><span class="hljs-type">char</span> x4; <span class="hljs-comment">//1</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack() <span class="hljs-comment">//取消1字节对齐，恢复为默认4字节对齐</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.alignas</strong></p><ul><li>C++11以后引入两个关键字 <code>alignas</code>与 <code>alignof</code>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// alignas生效的情况：设置的值大于等于size最大成员所占的字节数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">16</span>) Info2 &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// alignas失效的情况：设置的值小size最大成员所占的字节数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) Info3 &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 24  8 + 8 + 8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 8</span><br><br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 32  16 + 16</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 16</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info3) &lt;&lt; std::endl;   <span class="hljs-comment">// 24  8 + 8 + 8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info3) &lt;&lt; std::endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">24</span><br><span class="hljs-number">8</span><br><span class="hljs-number">32</span><br><span class="hljs-number">16</span><br><span class="hljs-number">24</span><br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>参考：</p><blockquote><p><a href="https://juejin.cn/post/6870162226032934926">https://juejin.cn/post/6870162226032934926</a></p></blockquote><h1 id="3-指针和引用的区别"><a href="#3-指针和引用的区别" class="headerlink" title="3 指针和引用的区别"></a>3 指针和引用的区别</h1><ul><li>指针是一个变量，存储的是一个地址；引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以为空，而引用在定义的时候必须初始化</li><li>指针可以有多级，引用只有一级</li><li>指针在初始化之后可以改变指向，而引用在初始化之后不可改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>　　<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>　　p=&amp;a;<br>　　cout&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">test</span>(p);<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>    cout&lt;&lt;<span class="hljs-string">&quot;指针p为NULL&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果为：</span><br><span class="hljs-comment">//0x61fddc 1</span><br><span class="hljs-comment">//指针p为NULL</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPTR</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>p = &amp;a;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testREFF</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p)</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>p = a;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* b = &amp;a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;before: &quot;</span> &lt;&lt;  b &lt;&lt; endl; <span class="hljs-comment">// before: 0x61fe14</span><br><span class="hljs-built_in">testPTR</span>(b); <span class="hljs-comment">//相当于值传递，函数外实际上没改变指针</span><br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 10</span><br>cout &lt;&lt; *b &lt;&lt; endl;<span class="hljs-comment">// 10</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;after: &quot;</span> &lt;&lt;  b &lt;&lt; endl; <span class="hljs-comment">// after: 0x61fe14</span><br><br>a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">testREFF</span>(a);<br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">//12</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h1><ul><li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* myArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];  <span class="hljs-comment">// 在堆上分配内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        myArray[i] = i * i;  <span class="hljs-comment">// 初始化数组</span><br>    &#125;<br>    <span class="hljs-comment">// 返回一个指向堆内存的指针</span><br>    <span class="hljs-keyword">return</span> myArray;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* squareArray = <span class="hljs-built_in">createArray</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        std::cout &lt;&lt; squareArray[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 输出数组</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">delete</span>[] squareArray;  <span class="hljs-comment">// 释放数组所占的内存</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><ul><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式，传引用有以下特点：<ul><li><strong>避免拷贝</strong>：使用引用可以避免当对象作为参数传递时的潜在的拷贝操作，特别是对于大型对象，这可以显著提高性能。</li><li><strong>保持对原始对象的修改</strong>：如果需要在函数内部修改类对象并反映到外部的原始对象，使用引用允许你直接在原始对象上操作，而不是在其副本上操作。</li><li><strong>语义清晰</strong>：当通过引用传递参数时，它告诉使用函数的开发者，这个函数可能会修改传入的对象。</li></ul></li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= vec.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 基线条件</span><br>    &#125;<br>    <span class="hljs-comment">// 做一些处理...</span><br>    <span class="hljs-built_in">recursiveFunction</span>(vec, index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largeVector</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">42</span>)</span></span>; <span class="hljs-comment">// 大型向量</span><br>    <span class="hljs-built_in">recursiveFunction</span>(largeVector, <span class="hljs-number">0</span>); <span class="hljs-comment">// 通过引用传递</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-堆和栈的区别"><a href="#5-堆和栈的区别" class="headerlink" title="5 堆和栈的区别"></a>5 堆和栈的区别</h1><ul><li>申请方式不同<ul><li>栈是由系统自动分配</li><li>堆是自己申请的，比如new对象 int myArray &#x3D; new int[size];</li></ul></li><li>申请大小限制不同<ul><li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li></ul></li><li>申请效率不同。<ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul><table><thead><tr><th></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td></tr><tr><td><strong>空间大小</strong></td><td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td><td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）</td></tr><tr><td><strong>碎片问题</strong></td><td>对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td></tr><tr><td><strong>生长方向</strong></td><td>堆向上，向高地址方向增长。</td><td>栈向下，向低地址方向增长。</td></tr><tr><td><strong>分配方式</strong></td><td>堆都是动态分配（没有静态分配的堆）</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td><strong>分配效率</strong></td><td>堆由C&#x2F;C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table><p><strong>形象的比喻</strong></p><p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p><p>堆就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><h1 id="6-堆快还是栈快"><a href="#6-堆快还是栈快" class="headerlink" title="6 堆快还是栈快"></a>6 堆快还是栈快</h1><p>栈快 </p><ul><li><p>操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率较高也比较快。</p></li><li><p>而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p></li></ul><h1 id="7-区别以下指针类型？"><a href="#7-区别以下指针类型？" class="headerlink" title="7 区别以下指针类型？"></a>7 区别以下指针类型？</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>] <span class="hljs-comment">//指针数组，强调数组概念，一共有10个变量，每个数组元素都是一个指向 int 类型数据的指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>] <span class="hljs-comment">//数组指针，强调指针概念，只有一个变量，是指针类型， 它指向一个具有10个整数的数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-comment">// 函数声明，函数名是p，参数类型是int类型，返回值是int*类型</span></span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-comment">// 函数指针，强调是指针，该指针指向的函数具有int类型参数，返回值也是int类型</span></span><br></code></pre></td></tr></table></figure><h1 id="8-new-delete-与-malloc-free的异同"><a href="#8-new-delete-与-malloc-free的异同" class="headerlink" title="8 new&#x2F;delete 与 malloc&#x2F;free的异同"></a>8 new&#x2F;delete 与 malloc&#x2F;free的异同</h1><p>相同点：</p><ul><li>都可用于内存的动态申请和释放</li></ul><p>不同点：</p><ul><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li><li><p>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p></li><li><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，所以new是类型安全的。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p></li></ul><h1 id="9-new和delete是如何实现的？"><a href="#9-new和delete是如何实现的？" class="headerlink" title="9 new和delete是如何实现的？"></a>9 new和delete是如何实现的？</h1><ul><li>new的实现：<ul><li>首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；</li><li>接下来运行该类型的一个构造函数，用指定初始化构造对象；</li><li>最后返回指向新分配并构造后的的对象的指针</li></ul></li><li>delete的实现：<ul><li>销毁对象：对指针指向的对象运行适当的析构函数；（编译器会自动选择合适的析构函数，析构函数可以被重载，但不建议）</li><li>释放对象对应的内存：通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li><li>delete的作用：销毁给定的指针指向的对象；释放对应的内存</li></ul></li></ul><h1 id="10-被free回收的内存是立即返还给操作系统吗？"><a href="#10-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="10 被free回收的内存是立即返还给操作系统吗？"></a>10 被free回收的内存是立即返还给操作系统吗？</h1><p>不是的，内存通常会被添加到可用内存池中，并由程序的内存管理系统维护。</p><p>这些内存可能在之后的内存分配中再次被使用，以避免频繁地向操作系统请求内存。</p><p>当程序结束时，这些内存才会被彻底返回给操作系统。</p><p>同时，ptmalloc会尝试把小块的内存合并，避免过多的内存碎片</p><h1 id="11-x-和-x的过程"><a href="#11-x-和-x的过程" class="headerlink" title="11 x++和++x的过程"></a>11 x++和++x的过程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// x++</span><br><span class="hljs-type">int</span> tmp = x;<br>x = x + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> tmp;<br><br><span class="hljs-comment">// ++x</span><br>x = x + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><h1 id="13-define和函数有何区别？"><a href="#13-define和函数有何区别？" class="headerlink" title="13 define和函数有何区别？"></a>13 define和函数有何区别？</h1><ul><li>处理时机不同<ul><li>宏在预处理阶段完成替换，运行时不存在函数调用，执行起来更快</li><li>函数需要等待后面的编译–汇编–链接操作，最终变成可执行文件</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//替换前</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> p() printf(<span class="hljs-string">&quot;macro\n&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">p</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//替换后</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>安全性不同<ul><li>有参宏函数在传参的时候也只是简单的参数替换，不涉及类型</li><li>不同函数的形参有类型限制，所以更加安全一点，如果参数不合法，编译的时候就会体现</li></ul></li><li>宏定义属于在结构中插入代码，没有返回值，函数调用具有返回值</li></ul><h1 id="14-define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#14-define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="14 define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>14 define、const、typedef、inline的使用方法？他们之间有什么区别？</h1><p><strong>define和typedef区别</strong></p><ul><li>typedef主要用于类型别名，#define不只是可以为类型取别名，还可以定义常量、变量等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有两种方法可以定义类型别名：</span><br><span class="hljs-comment">//方法一：typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-comment">// wages 是 double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base;<span class="hljs-comment">// base 是double 的同义词</span><br><br><span class="hljs-comment">//方法二（新标准）：别名声明</span><br><span class="hljs-keyword">using</span> SI = <span class="hljs-type">int</span><span class="hljs-comment">// SI 是 int 的同义词</span><br>    <br><span class="hljs-comment">// 类型别名和类型的名字等价，有类型的名字出现的地方，都可以替换为别名</span><br>wages hourly, weekly <span class="hljs-comment">// 等价于 double houtly, weekly</span><br>SI item<span class="hljs-comment">//等价于 int item</span><br><br>    <br><span class="hljs-comment">// 宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 99</span><br></code></pre></td></tr></table></figure><ul><li>宏替换发生在预处理阶段，而typedef发生在编译阶段</li><li>宏定义不检查数据类型，typedef要检查数据类型</li><li>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</li><li>宏不是语句，不在最后面添加分号，typedef是语句，要以分号结束</li></ul><p><strong>define和const的区别</strong></p><p>编译阶段</p><ul><li>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、链接的时候起作用</li></ul><p>安全性</p><ul><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p>内存占用</p><ul><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份</li></ul><p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p><p><strong>define和inline的区别</strong></p><ul><li>宏在预编译时进行，只做简单的字符串替换，内联函数可以做参数类型检查</li><li>内联函数在编译时直接将函数代码嵌入到函数调用处，省去了函数调用的开销来提高执行效率，可以实现重载</li></ul><h1 id="15-声明变量和定义的区别"><a href="#15-声明变量和定义的区别" class="headerlink" title="15 声明变量和定义的区别"></a>15 声明变量和定义的区别</h1><ul><li>变量只能在一处定义，但是可以在多处声明<ul><li>声明：一个文件如果想使用其它地方定义的变量，就必须声明它</li><li>定义：定义负责创建与名字关联的实体</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i <span class="hljs-comment">// 声明i并非定义i</span><br><span class="hljs-type">int</span> j<span class="hljs-comment">// 声明并定义j</span><br></code></pre></td></tr></table></figure><ul><li>任何包含了显示初始化的声明即成为了定义，能给 <code>extern</code>修饰的变量赋一个初始值，但这也抵消了<code>entern</code>的作用，将其变成了一个定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<span class="hljs-comment">// 定义</span><br></code></pre></td></tr></table></figure><h1 id="16-strlen和sizeof的区别"><a href="#16-strlen和sizeof的区别" class="headerlink" title="16 strlen和sizeof的区别"></a>16 strlen和sizeof的区别</h1><ul><li><code>sizeof</code>是运算符不是函数，<code>strlen</code>是字符处理的库函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sizeof用法</span><br><span class="hljs-comment">// sizeof运算符返回一条表达式或一个类型名字所占的字节数</span><br><span class="hljs-built_in">sizeof</span>(type)  <br><span class="hljs-keyword">sizeof</span> express   <span class="hljs-comment">// 返回表达式结果类型的大小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> a, *p;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> a &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> p &lt;&lt; endl; <span class="hljs-comment">// 8  指针p的大小</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> *p &lt;&lt; endl; <span class="hljs-comment">// 1  p所指向的对象的类型大小，即char的大小</span><br>&#125;<br>    <br><span class="hljs-comment">// strlen用法</span><br><span class="hljs-comment">// strlen 是一个用来计算字符串长度的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(str)); <span class="hljs-comment">//8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">//6 取的是这个字符串的长度，不包含结尾的 \0。大小是6</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)); <span class="hljs-comment">// 7 ，包含结尾的\0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><code>sizeof</code>参数可以是任何数据类型或者数据；<code>strlen</code> 的参数只能是字符指针</p></li><li><p><code>sizeof</code>的值在编译时确定。</p></li></ul><h1 id="17-一个指针占多少字节？"><a href="#17-一个指针占多少字节？" class="headerlink" title="17 一个指针占多少字节？"></a>17 一个指针占多少字节？</h1><ul><li>64位的编译环境下的指针的占用大小为8字节</li><li>32位的编译环境下的指针的占用大小为4字节</li></ul><h1 id="18-常量指针和指针常量的区别"><a href="#18-常量指针和指针常量的区别" class="headerlink" title="18 常量指针和指针常量的区别"></a>18 常量指针和指针常量的区别</h1><ul><li>常量指针：指针本身是不可变的，即指向的地址不能改变，但指向的内容可以改变。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;value; <span class="hljs-comment">// ptr是一个常量指针</span><br>*ptr = <span class="hljs-number">6</span>; <span class="hljs-comment">// 合法，可以改变ptr指向的值</span><br>ptr = &amp;some_other_value; <span class="hljs-comment">// 非法，ptr的值不能改变</span><br></code></pre></td></tr></table></figure><ul><li>指针常量：指针指向的内容是不可变的，即指向的值不能改变，但指针本身可以改变指向其他内容。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>* ptr_to_const = &amp;value; <span class="hljs-comment">// ptr_to_const是一个指针常量</span><br>*ptr_to_const = <span class="hljs-number">6</span>; <span class="hljs-comment">// 非法，不能改变指向的内容</span><br>ptr_to_const = &amp;some_other_value; <span class="hljs-comment">// 合法，可以改变ptr_to_const的值</span><br></code></pre></td></tr></table></figure><h1 id="19-a和-a有什么区别"><a href="#19-a和-a有什么区别" class="headerlink" title="19 a和&amp;a有什么区别"></a>19 a和&amp;a有什么区别</h1><ul><li><code>a</code> 是一个变量，代表该变量存储的值。</li><li><code>&amp;a</code> 是取地址操作符，用于获取变量 <code>a</code> 的内存地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// a是变量名，值为5</span><br><span class="hljs-comment">// &amp;a是a在内存中的地址</span><br></code></pre></td></tr></table></figure><h1 id="20-C-中struct和class的区别"><a href="#20-C-中struct和class的区别" class="headerlink" title="20 C++中struct和class的区别"></a>20 C++中struct和class的区别</h1><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li></ul><p><strong>不同点</strong></p><ul><li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li><li>class默认是private继承， 而struct默认是public继承</li></ul><h1 id="21-printf函数的实现原理"><a href="#21-printf函数的实现原理" class="headerlink" title="21 printf函数的实现原理"></a>21 printf函数的实现原理</h1><h1 id="22-C-的顶层const和底层const"><a href="#22-C-的顶层const和底层const" class="headerlink" title="22 C++的顶层const和底层const"></a>22 C++的顶层const和底层const</h1><ul><li>顶层const：指针本身是一个常量（常量指针，就是 * 号的右边），指针本身不能修改指向别的地址，但是所指的对象的值可以修改</li><li>底层const：指针所指的对象是一个常量（指针常量，就是 * 号的左边），指针所指的对象不能修改，但是指针可以指向别的地址</li></ul><h1 id="23-static关键字"><a href="#23-static关键字" class="headerlink" title="23 static关键字"></a>23 static关键字</h1><p><strong>static成员变量：</strong></p><ul><li><p>类的所有对象共用一份数据</p></li><li><p>在编译阶段分配内存</p></li><li><p>在类内声明，类外初始化</p><ul><li>原因：因为静态成员属于整个类，而不属于某个对象，如果在类内进行初始化，会导致每个对象都包含该静态成员，这是矛盾的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>static成员常量：</strong></p><p>可以在类内声明，类外初始化。也可以在类内定义的时候直接初始化（因为是常量，在类内初始化时对象也无法改变其值），但是不能使用成员初始化列表进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类内声明，类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num; <span class="hljs-comment">// 类内声明</span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 类外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br><br><span class="hljs-comment">// 类内直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>static成员函数：</strong></p><ul><li>static成员函数只能访问static成员变量，访问不了非静态成员变量</li><li>类的所有对象都可以访问static成员函数</li></ul><h1 id="24-C-从代码到可执行程序经历了什么"><a href="#24-C-从代码到可执行程序经历了什么" class="headerlink" title="24 C++从代码到可执行程序经历了什么"></a>24 C++从代码到可执行程序经历了什么</h1><p><strong>预编译</strong></p><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p><ul><li>删除所有的#define，展开所有的宏定义。</li><li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li><li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</li></ul><p><strong>编译</strong></p><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><ul><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li></ul><p><strong>汇编</strong></p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p><p><strong>链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ul><li>静态链接</li></ul><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快</p><ul><li>动态链接</li></ul><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><p><strong>视频中看到的资料：</strong></p><ul><li><p>预编译（预处理）：在这个阶段主要做了三件事：<code>展开头文件</code>、<code>宏替换</code>、<code>去掉注释行</code></p><ul><li>这个阶段需要GCC调用预处理器来完成，最终得到的还是源文件，文本格式，只不过头文件、宏、注释相关的内容发发生了变化</li></ul></li><li><p>编译：这个阶段需要GCC调用<code>编译器</code>对文件进行编译，最终得到一个汇编文件</p></li><li><p>汇编：这个阶段需要GCC调用<code>汇编器</code>对文件进行汇编，最终得到一个二进制文件</p></li><li><p>链接：这个阶段需要GCC调用<code>链接器</code>对程序需要调用的库进行链接，最终得到一个可执行的二进制文件</p><table><thead><tr><th>过程</th><th>说明</th><th>gcc参数</th><th>得到的文件名后缀</th></tr></thead><tbody><tr><td></td><td>源文件</td><td>无</td><td><code>.c</code></td></tr><tr><td>预编译</td><td>预处理后得到C文件（还是源文件，只是宏、注释、头文件变了）</td><td><code>-E</code></td><td><code>.i</code></td></tr><tr><td>编译</td><td>编译之后得到汇编语言的源文件</td><td><code>-s</code></td><td><code>.s</code></td></tr><tr><td>汇编</td><td>汇编后得到二进制文件</td><td><code>-c</code></td><td><code>.O</code></td></tr><tr><td>链接</td><td>链接后得到可执行文件</td><td>无</td><td>无</td></tr></tbody></table><p>举例：</p><p>Demo.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_COUNT 3</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 这是一个注释</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++)<br>    &#123;<br>      cout &lt;&lt; __cplusplus &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>预编译：<code>g++ Demo.cpp -E -o Demo.i</code>，生成<code>Demo.i</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Demo.i的一部分</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;Demo.cpp&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-comment">//头文件展开，从根目录开始</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> <span class="hljs-number">2</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;Demo.cpp&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/c++/4.8.2/iostream&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br># <span class="hljs-number">36</span> <span class="hljs-string">&quot;/usr/include/c++/4.8.2/iostream&quot;</span> <span class="hljs-number">3</span><br>...<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 去掉注释</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) <span class="hljs-comment">// 宏替换</span><br>    &#123;<br>      cout &lt;&lt; <span class="hljs-number">199711L</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：<code>g++ Demo.i -S -o Demo.s</code>，生成汇编文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 汇编文件一部分</span><br>.file<span class="hljs-string">&quot;Demo.cpp&quot;</span><br>.local_ZStL8__ioinit<br>.comm_ZStL8__ioinit,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>.text<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB971:<br>.cfi_startproc<br>...<br></code></pre></td></tr></table></figure><p>汇编：<code>g++ Demo.s -c -o Demo.o</code>，生成二进制文件（打不开）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ELF<br></code></pre></td></tr></table></figure><p>链接：<code>g++ Demo.o -o Demo</code>，生成可执行文件，执行后结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">199711<br>199711<br>199711<br></code></pre></td></tr></table></figure></li></ul><h1 id="25-构造函数与析构函数"><a href="#25-构造函数与析构函数" class="headerlink" title="25 构造函数与析构函数"></a>25 构造函数与析构函数</h1><p><strong>构造函数：</strong>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</p><p><strong>析构函数：</strong>主要作用在于对象销毁前系统自动调用，执行一些清理工作</p><p><strong>构造函数的语法：</strong><code>类名()&#123;&#125;</code></p><ul><li>构造函数没有返回值也不写<code>void</code></li><li>函数名称与类型相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在创建对象时候会自动调用构造函数，无须手动调用，而且只会调用一次</li></ul><p><strong>析构函数的语法：</strong><code>~类名()&#123;&#125;</code></p><ul><li>析构函数，没有返回值也不写void</li><li>函数名称与类型相同，在名称前面加上符号 <code>~</code></li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Person p;   <span class="hljs-comment">// 创建对象调用构造函数</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-comment">// return 0 之前也就是函数结束之前也就是对象销毁前，调用析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br>constructor<br>请按任意键继续. . . <br>destructor <br><br></code></pre></td></tr></table></figure><h1 id="26"><a href="#26" class="headerlink" title="26"></a>26</h1><h1 id="27-深拷贝和浅拷贝的区别"><a href="#27-深拷贝和浅拷贝的区别" class="headerlink" title="27 深拷贝和浅拷贝的区别"></a>27 深拷贝和浅拷贝的区别</h1><p>在有指针的情况下，</p><ul><li><p>浅拷贝只是增加了一个指针指向已经存在的内容</p></li><li><p>深拷贝就是增加一个指针，并且申请一块新的内存，使这个增加的指针指向这个新的内存</p></li></ul><p>采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height)<br>    &#123;<br>        m_Age = age;<br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height);  <span class="hljs-comment">// 在堆区开辟的内存，由程序员手动开辟和释放（在析构函数中释放）</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parametric construction&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自己实现拷贝构造，解决浅拷贝带来的问题</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)  <br>    &#123;<br>        m_Age = p.m_Age;<br>        <span class="hljs-comment">// m_height = p.m_height;  不写这行</span><br>        <span class="hljs-comment">// 深拷贝操作</span><br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_height); <span class="hljs-comment">// 自己的成员m_height 指向新开辟的内存，存放的内容就是解引用之后*p.m_height的值</span><br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-comment">// 析构代码，将堆区开辟的数据做释放操作</span><br>        <span class="hljs-keyword">if</span>(m_height != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_height;<br>            m_height = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_Age;<br>    <span class="hljs-type">int</span> *m_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">160</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1 age: &quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="hljs-string">&quot;, height: &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <br>    cout &lt;&lt; <span class="hljs-string">&quot;p2 age: &quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="hljs-string">&quot;, height: &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br>Parametric construction<br>p1 age: <span class="hljs-number">18</span>, height: <span class="hljs-number">160</span><br>p2 age: <span class="hljs-number">18</span>, height: <span class="hljs-number">160</span><br>destructor  <br><span class="hljs-comment">// 程序在调用完第一个析构函数后崩溃，原因是 p2调用的是默认的拷贝构造函数，也就是相当于下面的代码：</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)<br>&#123;<br>    m_Age = p.m_Age;<br>    m_height = p.m_height;  <span class="hljs-comment">// 本行会导致指向堆区开辟的指针与原指针p1的m_height指向同一个地址，那么一个指针执行了释放操作后，就会导致另一个指针指向空。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="28-vector相关"><a href="#28-vector相关" class="headerlink" title="28 vector相关"></a>28 vector相关</h1><h2 id="vector基类介绍"><a href="#vector基类介绍" class="headerlink" title="vector基类介绍"></a>vector基类介绍</h2><p><code>vector</code>声明：两个模板参数，第一个是数据类型，第二个std::allocator是标准库中动态内存分配器，最终其实是调用了new运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;<br>  <span class="hljs-keyword">class</span> vector : <span class="hljs-keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;<br>  &#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>vecotor</code>继承了<code>_Vector_base</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_base</span><br>    &#123;<br>  ...<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_impl</span> <br>      : <span class="hljs-keyword">public</span> _Tp_alloc_type<br>      &#123;<br>pointer _M_start;<br>pointer _M_finish;<br>pointer _M_end_of_storage;<br><br>_Vector_impl()<br>: _Tp_alloc_type(), _M_start(<span class="hljs-number">0</span>), _M_finish(<span class="hljs-number">0</span>), _M_end_of_storage(<span class="hljs-number">0</span>)<br>&#123; &#125;<br><br>_Vector_impl(_Tp_alloc_type <span class="hljs-type">const</span>&amp; __a)<br>: _Tp_alloc_type(__a), _M_start(<span class="hljs-number">0</span>), _M_finish(<span class="hljs-number">0</span>), _M_end_of_storage(<span class="hljs-number">0</span>)<br>&#123; &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>_Vector_impl(_Tp_alloc_type&amp;&amp; __a)<br>: _Tp_alloc_type(std::<span class="hljs-built_in">move</span>(__a)),<br>  _M_start(<span class="hljs-number">0</span>), _M_finish(<span class="hljs-number">0</span>), _M_end_of_storage(<span class="hljs-number">0</span>)<br>&#123; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br>      &#125;; <span class="hljs-comment">// _Vector_impl 结束</span><br>      <br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-keyword">typedef</span> _Alloc allocator_type;<br><br>  ...<br><br>      <span class="hljs-comment">// 一些构造函数</span><br>      _Vector_base()<br>      : _M_impl() &#123; &#125;<br><br>      _Vector_base(<span class="hljs-type">const</span> allocator_type&amp; __a)<br>      : _M_impl(__a) &#123; &#125;<br><br>      _Vector_base(<span class="hljs-type">size_t</span> __n)<br>      : _M_impl()<br>      &#123; _M_create_storage(__n); &#125;<br><br>      _Vector_base(<span class="hljs-type">size_t</span> __n, <span class="hljs-type">const</span> allocator_type&amp; __a)<br>      : _M_impl(__a)<br>      &#123; _M_create_storage(__n); &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>      _Vector_base(_Tp_alloc_type&amp;&amp; __a)<br>      : _M_impl(std::<span class="hljs-built_in">move</span>(__a)) &#123; &#125;<br><br>      _Vector_base(_Vector_base&amp;&amp; __x)<br>      : _M_impl(std::<span class="hljs-built_in">move</span>(__x._M_get_Tp_allocator()))<br>      &#123; <span class="hljs-keyword">this</span>-&gt;_M_impl._M_swap_data(__x._M_impl); &#125;<br><br>      _Vector_base(_Vector_base&amp;&amp; __x, <span class="hljs-type">const</span> allocator_type&amp; __a)<br>      : _M_impl(__a)<br>      &#123;<br>  ...<br>      &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ...<br><br>    <span class="hljs-keyword">public</span>:<br>      _Vector_impl _M_impl;<br><br>   ...<br>    &#125;;<br></code></pre></td></tr></table></figure><p><code>_Vector_base</code>基类的功能：</p><ul><li>保存容器开始位置、结束位置以及所申请内存空间的的下一个位置；</li><li>申请动态内存空间</li></ul><p>注：</p><p>1、对于形如<code>vector&lt;int&gt; vec</code>这样的声明，vector其实就是调用了这个基类的无参构造函数，<strong>此时也没有申请动态内存</strong>。</p><p>无参构造为什么没有申请动态内存：涉及到节约资源的原则，假设申请了一块动态内存，但是后面却没有使用这个vector，那这个申请和释放这块动态内存的动作就产生了时间和空间的浪费。</p><p>2、如果vector在构造的时候给基类传入元素大小n，这时就会调用成员函数<code>_M_create_storage</code>，申请动态内存和给成员变量赋值。</p><h2 id="在最后插入一个元素-push-back"><a href="#在最后插入一个元素-push-back" class="headerlink" title="在最后插入一个元素: push_back()"></a>在最后插入一个元素: push_back()</h2><p><strong>对空的vector最后插入一个元素</strong></p><p>空的vector没有申请动态内存，使用pop_back()插入元素流程如下：</p><ul><li>得到一个长度，这个长度第一次插入时为1，后续如果超出容器所申请的空间，则在之前基础上乘以2，然后申请新的内存空间；</li><li>把待插入的元素插入到相应的位置；</li><li>把原来旧内存中元素全部拷贝到新的内存中来；</li><li>调用旧内存中所有元素的析构，并销毁旧的内存</li></ul><p>根据以上逻辑，也就是说，对一个无空间的vector插入一个元素实际上是会先申请1个元素的空间，并把这个元素插入到vector。</p><blockquote><p>根据以上，其实如果能确定vector必定会被使用且有数据时，我们应该在声明的时候指定元素个数，避免最开始的时候多次申请动态内存消耗资源，进而影响性能。</p></blockquote><p><strong>vector当前内存用完时在最后插入插入元素</strong></p><ul><li>当前空间基础上乘以2</li><li>把原来内存空间中所有数据拷贝到新的内存中</li><li>最后把当前要插入的数据插入到最后一个元素的下一个位置。</li><li>调用旧内存中所有元素的析构，并销毁旧的内存</li></ul><h2 id="在中间插入一个元素-insert"><a href="#在中间插入一个元素-insert" class="headerlink" title="在中间插入一个元素: insert()"></a>在中间插入一个元素: insert()</h2><p><strong>在空间足够时插入元素</strong></p><p>把当前要插入元素的位置后面的元素向后移动，然后把待插入元素插入到相应的位置。</p><p><strong>在空间不足时插入元素</strong></p><p>先申请内存，把元素放到新内存中，再执行插入</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h2><p><strong>从容器最后删除：pop_back()</strong></p><p>直接把最后一个元素位置向前移一位，然后把最后一个元素销毁掉即可。</p><p><strong>从中间删除：</strong></p><ul><li><strong>erase(const_iterator pos)</strong>   删除迭代器指向的元素：把这个元素后面的所有元素向前移动一位，且这是一个拷贝的动作，然后把容器结束位置向前移动一位，并返回指向当前位置的迭代器。</li><li><strong>erase(const_iterator start, const_iterator end)</strong>  删除迭代器从start到end之间的元素</li></ul><blockquote><p><strong>删除元素不会释放现有已经申请的动态内存。</strong></p></blockquote><h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><p>vector只能先删除，然后再插入，这样干，效率会很低。</p><h2 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h2><p><strong>at(int idx);</strong>返回索引idx所指的数据。at函数就是调用的operator[]函数，只是多了一个检查是否越界的动作</p><p><strong>operator[];</strong>   重载的中括号，返回中括号中所指的数据。直接跳转位置访问元素，所以速度是很快的，从时间复杂度看，是O(1)</p><h2 id="释放vector内存"><a href="#释放vector内存" class="headerlink" title="释放vector内存"></a>释放vector内存</h2><p>什么情况下vector大小为0呢，就是作为一个空容器的时候，所以要想快速的释放内存，可以参考swap函数机制，用一个空的vector与当前vector进行交换，使用形如<code>vector&lt;int&gt;().swap(v)</code>这样的代码，将v这个vector变量所代表的内存空间与一个空vector进行交换，这样v的内存空间等于被释放掉了，而这个空vector因为是一个临时变量，它在这行代码结束以后，会自动调用vector的析构函数释放动态内存空间，这样，一个vector的动态内存就被迅速的释放掉了。</p><ul><li>不能使用reverse(0)进行释放内存。这个函数只有在传入大小比原有内存大时才会有动作，否则不进行任何动作。</li><li>也不能通过resize或者clear函数释放内存。这些函数都只会对当前已保存在容器中的所有元素进行析构，但对容器本身所在的内存空间是不会进行释放的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vector是一个动态数组，它维护了一段连续的动态内存空间，然后有三个成员变量分别保存开始位置、当前已使用位置、申请的动态内存的最后一个位置的下一个位置，每当当前所申请的动态内存已经使用完时，它按照原有空间大小双倍重新申请，并把原来的元素都拷贝过去。</p><p>对于vector操作的时间复杂度：</p><ul><li>访问元素，时间复杂度为O(1);</li><li>在末尾插入或者删除元素，时间复杂度也为O(1);</li><li>在中间插入或者删除元素，时间复杂度为O(n)</li></ul><h2 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;"></a>&#x3D;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>默认构造</li><li>通过区间方式构造</li><li>指定n个元素及其值构造</li><li>拷贝构造</li><li>还有其它的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 默认构造</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br>    <span class="hljs-comment">// 通过区间方式构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;<br><br>    <span class="hljs-comment">// 指定n个元素及其值构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul><li>用操作符 <code>=</code> 赋值</li><li>assign(begin, end);</li><li>assign(n, elem);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v);<br><br>    <span class="hljs-comment">// 使用操作符 = 赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;  <br>    v1 = v; <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">// assign(begin, end)赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    v2.<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">// assign(n, elem)赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>    v3.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 100 100 100 100 100 100 100 100 100 100</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h2><ul><li><code>empty();</code>判断容器是否为空</li><li><code>capactiy()</code>     容器的容量</li><li><code>size()</code>            返回容器中元素的个数</li><li><code>resize(num)</code>   重新指定容器的长度为num，如果容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</li><li><code>resize(int num, elem)</code>   重新指定容器的长度为num，如果容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// empty();// 判断容器是否为空</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// capacity()  // 返回容器的容量</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 10</span><br><br>    <span class="hljs-comment">// 重新指定容器的长度为num，如果容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 5</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4</span><br><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">8</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 0 0 0</span><br><br><span class="hljs-comment">// 重新指定容器的长度为num，如果容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 0 0 0 1 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p><code>push_back(ele)</code>&#x2F;&#x2F; 尾部插入元素ele</p><p><code>pop_back()</code>&#x2F;&#x2F; 删除最后一个元素</p><p><code>insert(const_iterator pos, ele)</code>&#x2F;&#x2F; 迭代器指向位置pos插入元素ele</p><p><code>insert(const_iterator pos, int count, ele)</code> &#x2F;&#x2F; 迭代器指向位置pos插入count个元素ele</p><p><code>erase(const_iterator pos)</code>&#x2F;&#x2F; 删除迭代器指向的元素</p><p><code>erase(const_iterator start, const_iterator end)</code>&#x2F;&#x2F; 删除迭代器从start到end之间的元素</p><p><code>clear()</code> &#x2F;&#x2F; 删除容器中所有的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    v.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">88</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 88 0 1 2 3 4 5 6 7 8 </span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">99</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 88 0 1 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 100 88 0 1 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 100 88 0 1 100 100 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 88 0 1 100 100 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 88 1 100 100 2 3 4 5 6 7 8 99 </span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h2><p><code>at(int idx);</code> &#x2F;&#x2F;返回索引idx所指的数据</p><p><code>operator[];</code>&#x2F;&#x2F;重载的中括号，返回索引idx所指的数据</p><p><code>front();</code>&#x2F;&#x2F; 返回容器中第一个元素</p><p><code>back()</code> &#x2F;&#x2F; 返回容器中最后一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">//返回索引idx所指的数据</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 重载的中括号，返回索引idx所指的数据</span><br>    cout &lt;&lt; v[<span class="hljs-number">2</span>] &lt;&lt; endl; <span class="hljs-comment">// 2</span><br><br>    <span class="hljs-comment">// 返回容器中第一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">front</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// 返回容器中最后一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">back</span>() &lt;&lt; endl; <span class="hljs-comment">// 9</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="互换容器"><a href="#互换容器" class="headerlink" title="互换容器"></a>互换容器</h2><p><code>swap(vec)</code> &#x2F;&#x2F; 将vec与本身的元素互换，用途可以收缩内存空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;before: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 16384, size: 10000</span><br><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;after resize: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 16384, size: 3</span><br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);  <span class="hljs-comment">// vector&lt;int&gt;(v) 匿名对象  .swap(v) 容器交换，之后匿名对象的内存空间被自动释放</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;after swap: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 3, size: 3  </span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h2><p><code>reserve(int len);</code> 容器预留len个元素长度，预留位置不初始化，元素不可访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开辟内存空间的次数</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])<br>        &#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl; <span class="hljs-comment">// num = 18;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开辟内存空间的次数</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])<br>        &#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>     <br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;  <span class="hljs-comment">// num = 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="29"><a href="#29" class="headerlink" title="29"></a>29</h1><h1 id="30-野指针和悬空指针"><a href="#30-野指针和悬空指针" class="headerlink" title="30 野指针和悬空指针"></a>30 野指针和悬空指针</h1><p>都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p><ul><li>野指针：指的是未初始化过的指针，未初始化就被调用<ul><li>产生原因：指针变量未初始化</li><li>解决方法：将指针变量初始化或者置空</li></ul></li><li>悬空指针：指针最初指向的内存已经被释放的一种指针<ul><li>产生原因：指针free或者delete之后没有及时置空，指针仍然保存着已经释放了的内存的地址</li><li>解决方法：释放操作后立即置空</li></ul></li></ul><h1 id="31-拷贝初始化和直接初始化"><a href="#31-拷贝初始化和直接初始化" class="headerlink" title="31 拷贝初始化和直接初始化"></a>31 拷贝初始化和直接初始化</h1><ul><li>如果不使用等号，则执行的是直接初始化。直接初始化直接调用与实参匹配的构造函数</li><li>如果使用等号(&#x3D;)初始化一个变量，实际上执行的是拷贝初始化。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象上</li></ul><blockquote><p>拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的</p></blockquote><h1 id="32-赋值和初始化的区别"><a href="#32-赋值和初始化的区别" class="headerlink" title="32 赋值和初始化的区别"></a>32 赋值和初始化的区别</h1><p>初始化：创建变量时赋予其一个初始值</p><p>赋值：把对象的当前值擦除，并且以一个新值来替代</p><h1 id="33-虚函数和纯虚函数"><a href="#33-虚函数和纯虚函数" class="headerlink" title="33 虚函数和纯虚函数"></a>33 虚函数和纯虚函数</h1><p><strong>虚函数：</strong></p><p>为什么要有虚函数：对于某些函数，基类希望它的派生类各自定义合适自身的版本，基类就可以将这些函数声明为虚函数。实现动态绑定，也就是在程序运行时，函数根据传入的实参确定调用基类还是某个派生类中被重写过的虚函数。</p><blockquote><p>理解：定义一个函数为virtual虚函数是为了在函数运行进行调用时，根据传入的实参确定要调用基类的函数还是派生类的函数</p></blockquote><p>伪代码：场景：购买书籍，超过一定数量时打折</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quote</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回书籍的ISBN号。该操作不涉及派生类的特殊性，因此只定义在基类中</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回书籍的实际价格，前提是用户购买该书的数量达到一定标准，这个操作是类型相关的</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_Quote</span> : <span class="hljs-keyword">public</span> Quote<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">print_total</span><span class="hljs-params">(<span class="hljs-type">const</span> Quote&amp; item, <span class="hljs-type">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> ret = item.<span class="hljs-built_in">net_price</span>(n);  <span class="hljs-comment">// 父类的引用指向子类的对象</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Quote basic;<br>    Bulk_Quote bulk;<br>    <span class="hljs-comment">//发生了动态绑定，函数直到运行时根据具体传入的实参知道要调用基类还是派生类的函数</span><br>    <span class="hljs-built_in">print_total</span>(basic, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">print_total</span>(bulk, <span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>派生类必须在其内部对所有覆盖的函数进行声明</p></blockquote><ul><li>任何构造函数以外的非静态函数都可以是虚函数</li><li>虚函数一般都是要被重写的，如果没被重写，则该虚函数在基类中类似于其它的普通成员，派生类会直接继承其在基类中的版本（这种情况下，就没必要写成虚函数了）</li><li>虚函数需要在基类中加上<code>virtual</code>修饰符，因为<code>virtual</code>会被隐式继承，所以子类中相同的函数都是虚函数当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li></ul><p><strong>纯虚函数</strong></p><p>定义一个函数为纯虚函数是为了实现一个接口，起到一个规范的作用。</p><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用<code>=0</code>。</p><p>既然是虚函数，它的函数指针会被存放在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p><p>纯虚函数语法：<code>virtual 返回值类型 函数名（参数列表）= 0；</code></p><p>当类有了一个纯虚函数，这个类也称为抽象类</p><p>抽象类特点：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p>引入原因：</p><ul><li><p>为了方便使用多态特性，我们常常需要在基类中定义纯虚函数。</p></li><li><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 报错，不允许使用抽象类类型Son对象，即Base为抽象类的话，其子类继承Base，如果不重写父类中的纯虚函数的话，自己也变成了抽象类，无法实例化</span><br>    Base * b = <span class="hljs-keyword">new</span> Son;<br>    b-&gt;<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ==========正确的写法============</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 父类指针指向子类对象</span><br>    Base * b = <span class="hljs-keyword">new</span> Son;<br>    b-&gt;<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="34-友元"><a href="#34-友元" class="headerlink" title="34 友元"></a>34 友元</h1><p>友元的目的就是让一个函数或者类访问另一个类中私有成员，实现数据共享，节省开销</p><p>友元的三种实现：</p><ul><li>全局函数做友元（非成员函数）</li><li>类做友元：如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在在内的所有成员</li><li>成员函数做友元</li></ul><p>注意点：</p><ul><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li><li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li></ul><p><strong>全局函数做友元：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Building * build)</span></span>;  <span class="hljs-comment">// 将func声明为友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Building * build)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; build-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; build-&gt;bedRoom &lt;&lt; endl; <span class="hljs-comment">// 报错，不可访问， 如果想让全局函数func访问Building类的私有成员，需要将func设置为友元函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Building build;<br>    <span class="hljs-built_in">func</span>(&amp;build);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类做友元：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span>; <span class="hljs-comment">// 将Visit类作为Building的友元类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Visit</span>() <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>        building = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Building</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br>    Building * building;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;bedRoom &lt;&lt; endl;  <span class="hljs-comment">// 报错，不可访问，如果想访问需要将Visit类作为Building的友元类</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Visit visit;<br>    visit.<span class="hljs-built_in">visit</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>成员函数做友元</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Visit</span>(); <span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>;<br>    Building * building;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br>&#125;;<br><br>Visit::<span class="hljs-built_in">Visit</span>() <span class="hljs-comment">// Visit的构造函数</span><br>&#123;<br>    building = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Building</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;bedRoom &lt;&lt; endl;  <span class="hljs-comment">// 报错，不可访问，如果想访问需要将成员函数visit作为Building的友元函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit2 &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;visit2 &quot; &lt;&lt; building-&gt;bedRoom &lt;&lt; endl; // 报错，不可访问，如果想访问需要将成员函数visit2作为Building的友元函数</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Visit visit;<br>    visit.<span class="hljs-built_in">visit</span>();<br>    visit.<span class="hljs-built_in">visit2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="36-重载、重写"><a href="#36-重载、重写" class="headerlink" title="36 重载、重写"></a>36 重载、重写</h1><ul><li>重载：指函数名相同，参数列表不同</li><li>重写：是指派生类重写基类的函数<ul><li>与基类有相同的参数个数</li><li>与基类有相同的参数类型</li><li>与基类有相同的返回值类型</li></ul></li></ul><h1 id="37-cout和printf有什么区别"><a href="#37-cout和printf有什么区别" class="headerlink" title="37 cout和printf有什么区别"></a>37 cout和printf有什么区别</h1><h1 id="38-public、protected和private访问权限"><a href="#38-public、protected和private访问权限" class="headerlink" title="38 public、protected和private访问权限"></a>38 public、protected和private访问权限</h1><ul><li>public的变量和函数在类的内部外部都可以访问。</li><li>protected的变量和函数只能在类的内部和其派生类中访问。</li><li>private修饰的元素只能在类内访问。</li></ul><table><thead><tr><th>访问权限</th><th>外部</th><th>派生类</th><th>内部</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>×</td><td>√</td><td>√</td></tr><tr><td>private</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 类内访问</span></span><br><span class="hljs-function">    </span>&#123;<br>        a = <span class="hljs-number">1</span>;<br>        b = <span class="hljs-number">2</span>;<br>        c = <span class="hljs-number">3</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func called&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 类外只能访问func()和成员变量a</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a.a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="39-public、protected和private继承权限"><a href="#39-public、protected和private继承权限" class="headerlink" title="39 public、protected和private继承权限"></a>39 public、protected和private继承权限</h1><p><strong>public继承</strong></p><p>基类的公有成员成员和保护成员成员作为派生类的成员时，都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p><p><strong>protected继承</strong></p><p>基类的公有成员和保护成员都作为派生类的保护成员，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p><p><strong>private继承</strong></p><p>基类的公有成员和保护成员都作为派生类的私有成员，并不被它的派生类访问，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p><h1 id="40"><a href="#40" class="headerlink" title="40"></a>40</h1><h1 id="41-静态变量什么时候初始化"><a href="#41-静态变量什么时候初始化" class="headerlink" title="41 静态变量什么时候初始化"></a>41 静态变量什么时候初始化</h1><ul><li>全局变量、静态类成员变量在编译时进行前初始化；</li><li>局部变量中的静态变量在第一次运行到对象定义语句时初始化，并且直到程序终止才被销毁，再次期间即使对象所在的函数执行结束也不会对它有影响。</li></ul><h1 id="42-数据类型所占的字节数"><a href="#42-数据类型所占的字节数" class="headerlink" title="42 数据类型所占的字节数"></a>42 数据类型所占的字节数</h1><table><thead><tr><th>类型</th><th>32位操作系统（字节数）</th><th>64位操作系统（字节数）</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>8</td></tr><tr><td>long long</td><td>8</td><td>8</td></tr><tr><td>char*</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><h1 id="43-const关键字的作用有哪些"><a href="#43-const关键字的作用有哪些" class="headerlink" title="43 const关键字的作用有哪些?"></a>43 const关键字的作用有哪些?</h1><ul><li>修饰变量。防止一个变量的值被改变</li><li>修饰指针。对指针来说，如果指针本身为const，那么指针便不能改变其指向</li><li>修饰形参。在一个函数声明中，const可以修饰形参，表示该参数在函数中不能被改变</li></ul><p>注意点：</p><ul><li><p>由于const对象一旦创建后其值就不能再改变，所以const对象必须初始化</p></li><li><p>const int 和普通的int一样都能参与算术运算，也都能转换成一个布尔值</p></li><li><p>默认状态下，const对象仅在文件内有效，如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字</p></li></ul><h1 id="44-全局对象-局部对象-局部静态对象的生命周期"><a href="#44-全局对象-局部对象-局部静态对象的生命周期" class="headerlink" title="44 全局对象&#x2F;局部对象&#x2F;局部静态对象的生命周期"></a>44 全局对象&#x2F;局部对象&#x2F;局部静态对象的生命周期</h1><p><strong>全局对象：</strong>在程序启动时分配，在程序结束时销毁</p><p><strong>局部对象：</strong>当进入其定义所在的程序块时被创建，在离开块时销毁</p><p><strong>局部static对象：</strong>在第一次使用前分配，在程序结束时销毁</p><h1 id="45-成员初始化列表的概念，为什么用它会快一些？"><a href="#45-成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="45 成员初始化列表的概念，为什么用它会快一些？"></a>45 成员初始化列表的概念，为什么用它会快一些？</h1><p><strong>概念</strong></p><p>在类的构造函数中，不存在函数体内对成员赋值，而是在函数名的后面、花括号的前面使用<code>:</code>和成员初始化列表对成员赋值</p><p><strong>效率</strong></p><p>对于内置类型，效率没有差别</p><p>对于其它类型，使用成员初始化列表会少一次调用构造函数的过程；而在函数体内使用直接赋值会多一次调用默认构造函数的过程（先初始化再赋值）</p><p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化</p><p><strong>注意点</strong></p><p>如果成员是<code>const</code>、引用、或者属于某种未提供默认构造函数的类类型，必须使用初始化列表为这些成员提供初值</p><blockquote><p>随着构造函数体一开始执行，初始化就完成了，构造函数体内是赋值的操作</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;default constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>    &#123;<br>        value = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        b = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>        c = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    A a;<br>    A b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br>a: <span class="hljs-number">1</span><br><span class="hljs-keyword">default</span> constructor<br>a: <span class="hljs-number">2</span>C<br></code></pre></td></tr></table></figure><ul><li><p>对于<code>a</code>，使用成员列表初始化，对a直接赋值</p></li><li><p>对于<code>b</code>，在进入构造函数之前，会先调用一次默认构造函数，再进行一次赋值操作(对象已存在)</p></li><li><p>对于<code>c</code>，为基本类型，直接对<code>c</code>进行赋值</p></li></ul><h1 id="46-值传递、指针传递、引用传递的区别和效率"><a href="#46-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46 值传递、指针传递、引用传递的区别和效率"></a>46 值传递、指针传递、引用传递的区别和效率</h1><ul><li>值传递：有形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，耗费时间和空间比较大。</li><li>指针传递：本质上是值传递。向函数所属的栈拷贝指针，指针指向是实参的地址</li><li>引用传递：被调函数的形参也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">valuePass</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">valuePass</span>(num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 50，因为值传递不会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 指针传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointerPass</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span> </span>&#123;<br>    *x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">pointerPass</span>(&amp;num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 100，因为指针传递会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">referencePass</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">referencePass</span>(num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 100，因为引用传递会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="47-形参与实参？"><a href="#47-形参与实参？" class="headerlink" title="47 形参与实参？"></a>47 形参与实参？</h1><ul><li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 </li><li>实参和形参在数量上，类型上，顺序上应严格一致。</li><li>值传递时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束时形参被释放，实参内容不会改变。</li><li>实参是形参的初始值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 二者等价，空形参列表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="48-创建对象时内存区发生了什么"><a href="#48-创建对象时内存区发生了什么" class="headerlink" title="48 创建对象时内存区发生了什么"></a>48 创建对象时内存区发生了什么</h1><p>C++中利用<code>new</code>操作符在堆区开辟内存</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放操作符<code>delete</code></p><p>语法：<code>new 数据类型</code></p><p>利用<code>new</code>创建的数据，会返回该数据类型对应类型的<strong>指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 创建一个整型变量，返回一个整型指针。在堆区开辟一块内存，用于存放10，在栈种开辟一块内存，存放指针，指向堆区的内存</span><br>    cout &lt;&lt; *a &lt;&lt; endl; <span class="hljs-comment">// 10， 对指针解引用，堆区内存种的值</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0x1e1600，指针保存的值，即指针所指向的堆中的地址</span><br>cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针本身在栈中的地址</span><br>    <br>    <span class="hljs-keyword">delete</span> a;<span class="hljs-comment">// delete 释放的是堆中的内存</span><br>    cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针本身在栈中所栈的内存没有变，也没有释放，</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0x1e1600， 指针所指向的堆中的内存地址没有变，只是现在被释放了</span><br>    <br>    a =<span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0  ，现在指针所指向的堆中的内存为0</span><br>    cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针所在的栈中的内存没有变，也没有释放，栈中的内存会在程序运行结束后系统自动释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="49-类成员初始化方式？"><a href="#49-类成员初始化方式？" class="headerlink" title="49 类成员初始化方式？"></a>49 类成员初始化方式？</h1><ul><li>直接初始化、拷贝初始化、成员列表初始化</li><li>赋值初始化，即构造函数内赋值，如果<code>x</code>和<code>y</code>是内置类型，二者没区别，如果是其它自定义类类型，在进入构造函数之前，会先调用该类的默认构造函数，再进行一次赋值的操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <br>    &#123;<br>        x = a;<br>        y = b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>列表初始化，纯粹的赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="50-const-char-与string之间的关系"><a href="#50-const-char-与string之间的关系" class="headerlink" title="50 const char* 与string之间的关系"></a>50 const char* 与string之间的关系</h1><p><code>string</code>是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用<code>const char*</code>给<code>string</code>类初始化</p><p><code>string</code>可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间<code>(2*n)</code>，然后将原字符串拷贝过去，并加上新增的内容。</p><p>转换方式如下：转成<code>char*</code> 的时候都是用<code>char*</code> 指向一个字符数组，转成 <code>const char*</code>的时候，就是一个字符串</p><p><strong>string 转 const char</strong>*：使用<code>c_str()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* c = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><p><em><em>const char</em> 转string</em>*：直接转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* c = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(c)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>string 转 char</strong>*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">char</span>* c = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(c, s.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><p><strong>char*转 string</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* c = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(c)</span></span>;<br></code></pre></td></tr></table></figure><p><em><em>const char</em> 转 char</em>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpc = <span class="hljs-string">&quot;abc&quot;</span>; <br><span class="hljs-type">char</span>* pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cpc)+<span class="hljs-number">1</span>]; <br><span class="hljs-built_in">strcpy</span>(pc,cpc);<br></code></pre></td></tr></table></figure><p><em><em>char</em> 转 const char</em>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* pc = “abc”; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpc = pc;<br></code></pre></td></tr></table></figure><h1 id="51-什么是内存泄露，如何避免"><a href="#51-什么是内存泄露，如何避免" class="headerlink" title="51 什么是内存泄露，如何避免"></a>51 什么是内存泄露，如何避免</h1><p><strong>内存泄漏：</strong></p><p>一般常说的内存泄漏是指堆内存的泄漏。如果程序中分配了内存空间但未释放，失去了对该段内存的控制，这些内存空间将被程序持有，直到程序结束时才会被释放，这可能导致系统中的可用内存逐渐减少，最终耗尽系统资源。这称为内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memoryLeakExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 分配内存空间</span><br>    <span class="hljs-comment">// 这里发生了某些条件下的提前返回或异常，导致未释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>new</code> 运算符为 <code>ptr</code> 分配了内存，但在函数返回之前未使用 <code>delete</code> 运算符释放这块内存。如果函数在中间的某个点提前返回，那么这块内存将无法被释放，从而导致内存泄漏。</p><p><strong>内存泄漏的后果</strong></p><p>性能下降到内存逐渐用完</p><p><strong>避免内存泄漏</strong></p><ul><li>对象数组的释放一定要用<code>delete []</code></li><li>有<code>new</code>就有<code>delete</code>，有<code>malloc</code>就有<code>free</code>，保证它们一定成对出现</li><li>使用智能指针</li></ul><h1 id="52-面向对象的三大特征"><a href="#52-面向对象的三大特征" class="headerlink" title="52 面向对象的三大特征"></a>52 面向对象的三大特征</h1><p>封装、继承、多态</p><p><strong>封装</strong></p><p>封装是指将对象的状态（数据）和行为（方法）捆绑在一起，通过接口对外部提供访问权限。对象的内部细节对外部是隐藏的，外部程序只能通过对象的公共接口来与对象进行交互。封装可以帮助保护对象的数据，防止外部直接访问对象的内部数据，提高了代码的可维护性和可重用性。</p><blockquote><p>举例：操作系统封装了对硬件的访问方式，向应用程序或者用户提供了简单的访问方式，即接口，接口内部的实现应用程序和用户不可见</p></blockquote><p><strong>继承</strong></p><p>让某种类型对象获得另一个类型对象的属性和方法。它可以使用现有类的所有功能，并且可以增加新的成员变量和成员函数。</p><ul><li>子类对象可以当作父类对象使用，也就是调用子类的对象调用父类的方法</li></ul><p>如果子类中自己定义了析构函数，那么在销毁对象时会调用自己的析构函数。</p><p>如果子类中没有定义析构函数，那么子类会自动继承父类的析构函数，这样，子类在销毁对象时会先调用自己的析构函数，再调用父类的析构函数</p><p><strong>多态</strong></p><p>多态是指同一操作作用于不同的对象，可以产生不同的行为。即一个函数在不同的对象上拥有不同的行为。</p><p>多态有两种形式：</p><ul><li>静态多态，重载：是指函数名相同，参数列表不同</li><li>动态多态，覆盖（重写）：是指子类重新定义父类的虚函数。</li></ul><p>多态如何实现？</p><p>在基类的函数前加上 <code>virtual</code>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际对象类型（基类&#x2F;派生类）来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。如果基类没有重写基类的虚函数，会调用父类的虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; Base::func()&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> : <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; Son1::func()&quot;</span> &lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span> : <span class="hljs-keyword">public</span> Base&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base* base = <span class="hljs-keyword">new</span> Son1;<br>base-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// Son1::func()</span><br>base = <span class="hljs-keyword">new</span> Son2;<br>base-&gt;<span class="hljs-built_in">fun</span>();<span class="hljs-comment">// Base::func()</span><br><span class="hljs-keyword">delete</span> base;<br>base = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// Son1::func()</span><br><span class="hljs-comment">// Base::func()</span><br><br></code></pre></td></tr></table></figure><h1 id="53-多态的底层原理"><a href="#53-多态的底层原理" class="headerlink" title="53 多态的底层原理"></a>53 多态的底层原理</h1><p><strong>虚函数表（虚表 vtable</strong>）：类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。虚表是一个一维数组，存储了虚函数的入口地址。</p><p><strong>虚表指针（vptr）</strong>：在含有虚函数的类实例化对象时，对象地址的前4个或8个字节存储的指向虚表的指针。在构造时，根据对象的类型区初始化须知真vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。</p><blockquote><p>虚函数表不是对象的一部分，虚表指针是对象的一部分</p></blockquote><p>在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，以确保父类的部分被正确初始化，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；再调用子类的构造函数，编译器会修改虚表指针，令它指向子类的虚表。</p><p>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表。当派生类中有自己的虚函数时，再自己的虚表中将此虚函数地址添加再后面</p><p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p><p><strong>基类的虚函数表存放在内存的什么区？</strong></p><p>内存一般分为5个区域：栈区、堆区、代码区（存放函数体等二进制代码）、全局静态区、常量区</p><p>虚函数表的特征：</p><ul><li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li><li>虚函数表类似一个数组，类对象存储虚表指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码区</li><li>虚函数表存储的是虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小是在编译时期确定，不必动态分配内存空间存储虚函数表，因此不在堆中。</li></ul><p>根据以上特征推断，虚函数表类似于类中静态成员变量，静态成员变量也是全局共享，大小确定。因此最有可能存在全局数据区。</p><blockquote><p><strong>虚函数表在Linux&#x2F;Unix存放在可执行文件的只读数据段中(.rodata)，也就是C++内存模型的常量区，而虚函数位于代码段(.text)，也就是C++内存模型中的代码区</strong></p></blockquote><p><strong>虚表指针vptr的初始化时间</strong></p><p>对函数虚表的类进行初始化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p><h1 id="54-C-函数调用的压栈过程"><a href="#54-C-函数调用的压栈过程" class="headerlink" title="54 C++函数调用的压栈过程"></a>54 C++函数调用的压栈过程</h1><p><strong>代码层面</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; n &lt;&lt; endl;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> param1, <span class="hljs-type">int</span> param2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> var1 = param1;<br><span class="hljs-type">int</span> var2 = param2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var1=%d,var2=%d&quot;</span>, <span class="hljs-built_in">f</span>(var1), <span class="hljs-built_in">f</span>(var2));<span class="hljs-comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//var1=1,var2=2</span><br><br></code></pre></td></tr></table></figure><p>（1）当函数入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p><p>（2）当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p><p>（3）当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再f()将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p><p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p><p><strong>文字描述</strong></p><p>函数的调用过程</p><p>（1）从栈空间分配存储空间</p><p>（2）从实参的存储空间复制值到形参栈空间</p><p>（3）进行运算</p><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不会被销毁也不能被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p><h1 id="55-GDB"><a href="#55-GDB" class="headerlink" title="55  GDB"></a>55  GDB</h1><p>core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息</p><p><strong>产生coredump的情况：</strong></p><ul><li><p>数组越界</p></li><li><p>使用空指针</p></li><li><p>堆栈溢出（使用大量的局部变量）</p></li></ul><p><strong>使用gdb进行调试：</strong></p><ul><li>l(list) ，显示源代码，并且可以看到对应的行号；</li><li>b(break)x，x是行号，表示在对应的行号位置设置断点；</li><li>p(print)x，x是变量名，表示打印变量x的值</li><li>r(run)，启动程序或重新开始程序的执行</li><li>s(step)，逐行执行代码（遇到函数进入）</li><li>n(next)，逐行执行代码（遇到函数不进入）</li><li>finish，跳出当前函数</li><li>c(continue)，跳过当前断点，继续程序执行，直到遇到下一个断点或程序结束</li><li>q(quit)，表示退出gdb</li></ul><h2 id="1-调试准备"><a href="#1-调试准备" class="headerlink" title="1 调试准备"></a>1 调试准备</h2><p><strong>调试程序：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 10</span><br><br><span class="hljs-comment">// argc, argv 是命令行参数</span><br><span class="hljs-comment">// 启动应用程序的时候</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;参数个数: %d\n&quot;</span>, argc);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;argc; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, NUM);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;参数 %d: %s\n&quot;</span>, i, argv[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>命令行传参</strong></p><ul><li>第一步: 编译出带条信息的可执行程序，如果不加<code>-o</code>，会默认输出<code>a.out</code>可执行程序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ GdbDebug.cpp -o app -g<br></code></pre></td></tr></table></figure><ul><li>第二步: 启动gdb进程, 指定需要gdb调试的应用程序名称</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb app<br>(gdb) <br></code></pre></td></tr></table></figure><ul><li>第三步: 在启动应用程序 app之前设置命令行参数。gdb中设置参数的命令叫做set args …，查看设置的命令行参数命令是 show args。 语法格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置的时机: 启动gdb之后, 在应用程序启动之前</span><br>(gdb) <span class="hljs-built_in">set</span> args 参数1 参数2 .... ...<br><span class="hljs-comment"># 查看设置的命令行参数</span><br>(gdb) show args<br></code></pre></td></tr></table></figure><p><strong>gdb中启动程序</strong></p><p>两种方式：在整个 gdb 调试过程中，启动应用程序的命令只能使用一次。</p><ul><li>run: 可以缩写为 r, 如果程序中设置了断点会停在第一个断点的位置, 如果没有设置断点, 程序就执行完了</li><li>start: 启动程序, 最终会阻塞在main函数的第一行，等待输入后续其它 gdb 指令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 两种方式</span><br><span class="hljs-comment"># 方式1: run == r </span><br>(gdb) run  <br><br><span class="hljs-comment"># 方式2: start</span><br>(gdb) start<br></code></pre></td></tr></table></figure><h2 id="2-查看代码"><a href="#2-查看代码" class="headerlink" title="2 查看代码"></a>2 查看代码</h2><p><strong>当前文件</strong>：（main函数对应的文件）</p><ul><li>从第一行开始显示：(gdb) list</li><li>列值这行号对应的上下文代码, 默认情况下只显示10行内容：(gdb) list 行号</li><li>显示这个函数的上下文内容, 默认显示10行：(gdb) list 函数名</li></ul><p><code>l</code>和<code>list</code>等价</p><p><strong>切换文件</strong></p><p>在list命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件（多个文件要一起编译，生成可执行程序）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定的文件，并列出这行号对应的上下文代码, 默认情况下只显示10行内容</span><br>(gdb) l 文件名:行号<br><br><span class="hljs-comment"># 切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行</span><br>(gdb) l 文件名:函数名<br></code></pre></td></tr></table></figure><p><strong>设置显示的行数</strong></p><p>默认通过list只能一次查看10行代码，如果想显示更多，可以通过set listsize设置, 同样如果想查看当前显示的行数可以通过 show listsize查看, 这里的listsize可以简写为 list。具体语法格式如下: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下两个命令中的 listsize 都可以写成 list</span><br>(gdb) <span class="hljs-built_in">set</span> listsize 行数<br><br><span class="hljs-comment"># 查看当前list一次显示的行数</span><br>(gdb) show listsize<br></code></pre></td></tr></table></figure><h2 id="3-断点操作"><a href="#3-断点操作" class="headerlink" title="3 断点操作"></a>3 断点操作</h2><p>想要通过gdb调试某一行或者得到某个变量在运行状态下的实际值，就需要在在这一行设置断点，程序指定到断点的位置就会阻塞，就可以通过gdb的调试命令得到我们想要的信息了。</p><p>设置断点的命令叫做break可以缩写为b。</p><p><strong>设置断点</strong></p><p>设置断点有两种方式：</p><ul><li>普通断点：程序只要运行到这个位置就会被阻塞</li><li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li></ul><p>调试程序的断点可以设置到某个具体的行, 也可以设置到某个函数上，具体的设置方式如下：</p><p>设置普通断点到当前文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前文件的某一行上设置断点</span><br><span class="hljs-comment"># break == b</span><br>(gdb) b 行号<br>(gdb) b 函数名<span class="hljs-comment"># 停止在函数的第一行</span><br></code></pre></td></tr></table></figure><p>设置普通断点到非当前文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在非当前文件的某一行上设置断点</span><br>(gdb) b 文件名:行号<br>(gdb) b 文件名:函数名<span class="hljs-comment"># 停止在函数的第一行</span><br></code></pre></td></tr></table></figure><p>设置条件断点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 必须要满足某个条件, 程序才会停在这个断点的位置上</span><br><span class="hljs-comment"># 通常情况下, 在循环中条件断点用的比较多</span><br>(gdb) b 行数 <span class="hljs-keyword">if</span> 变量名==某个值<br></code></pre></td></tr></table></figure><p><strong>查看断点</strong></p><p>断点设置完毕之后，可以通过 info break命令查看设置的断点信息，其中info可以缩写为i</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># info == i</span><br><span class="hljs-comment"># 查看设置的断点信息</span><br>(gdb) i b   <span class="hljs-comment">#info break</span><br><br><span class="hljs-comment"># 举例</span><br>Num     Type           Disp Enb Address            What<br>1       breakpoint     keep y   0x000000000040056c <span class="hljs-keyword">in</span> main(int, char**)<br>                                                   at GdbDebug.cpp:14<br>2       breakpoint     keep y   0x000000000040056c <span class="hljs-keyword">in</span> main(int, char**)<br>                                                   at GdbDebug.cpp:14<br></code></pre></td></tr></table></figure><p>断点属性信息：</p><ul><li>Num: 断点的编号, 删除断点或者设置断点状态的时候都需要使用</li><li>Enb: 当前断点的状态, y表示断点可用, n表示断点不可用</li><li>What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上</li></ul><p><strong>删除断点</strong></p><ul><li>delete 断点编号</li></ul><p>删除断点的方式有两种: 删除(一个或者多个)指定断点或者删除一个连续的断点区间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># delete == del == d</span><br><span class="hljs-comment"># 需要 info b 查看断点的信息, 第一列就是编号</span><br>(gdb) d 断点的编号1 断点编号2 ...<br><span class="hljs-comment"># 举例: </span><br>(gdb) d 1          <span class="hljs-comment"># 删除第1个断点</span><br>(gdb) d 2 4 6      <span class="hljs-comment"># 删除第2,4,6个断点</span><br><br><span class="hljs-comment"># 删除一个范围, 断点编号 num1 - numN 是一个连续区间</span><br>(gdb) d num1-numN<br><span class="hljs-comment"># 举例, 删除第1到第5个断点</span><br>(gdb) d 1-5<br></code></pre></td></tr></table></figure><p><strong>设置断点状态</strong></p><p>如果某个断点只是临时不需要了，可以将其设置为不可用状态, 设置命令为disable 断点编号，当需要的时候再将其设置回可用状态，设置命令为 enable 断点编号。</p><ul><li>设置断点无效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="hljs-comment"># disable == dis</span><br><span class="hljs-comment"># 设置某一个或者某几个断点无效</span><br>(gdb) dis 断点1的编号 [断点2的编号 ...]<br><br><span class="hljs-comment"># 设置某个区间断点无效</span><br>(gdb) dis 断点1编号-断点n编号<br><br></code></pre></td></tr></table></figure><ul><li>让无效的断点生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># enable == ena</span><br><span class="hljs-comment"># 设置某一个或者某几个断点有效</span><br>(gdb) ena 断点1的编号 [断点2的编号 ...]<br><br><span class="hljs-comment"># 设置某个区间断点有效</span><br>(gdb) ena 断点1编号-断点n编号<br></code></pre></td></tr></table></figure><h2 id="4-调试命令"><a href="#4-调试命令" class="headerlink" title="4 调试命令"></a>4 调试命令</h2><p><strong>继续运行gdb</strong></p><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用continue命令。程序会继续运行, 直到遇到下一个有效的断点。continue可以缩写为 c。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># continue == c</span><br>(gdb) <span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><p><strong>手动打印信息</strong></p><p>当程序被某个断点阻塞之后, 可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。</p><ul><li>打印变量值</li></ul><p>在gdb调试的时候如果需要打印变量的值， 使用的命令是 print, 可缩写为 p。如果打印的变量是整数还可以指定输出的整数的格式, 格式化输出的整数对应的字符表如下：</p><table><thead><tr><th>格式化字符(&#x2F;fmt)</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;x</td><td>以十六进制的形式打印出整数。</td></tr><tr><td>&#x2F;d</td><td>以有符号、十进制的形式打印出整数。</td></tr><tr><td>&#x2F;u</td><td>以无符号、十进制的形式打印出整数。</td></tr><tr><td>&#x2F;o</td><td>以八进制的形式打印出整数。</td></tr><tr><td>&#x2F;t</td><td>以二进制的形式打印出整数。</td></tr><tr><td>&#x2F;f</td><td>以浮点数的形式打印变量或表达式的值。</td></tr><tr><td>&#x2F;c</td><td>以字符形式打印变量或表达式的值。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># print == p</span><br>(gdb) p 变量名<br><br><span class="hljs-comment"># 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span><br>(gdb) p/fmt 变量名<br></code></pre></td></tr></table></figure><ul><li>打印变量类型</li></ul><p>如果在调试过程中需要查看某个变量的类型, 可以使用命令ptype, 语法格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 语法格式</span><br>(gdb) ptype 变量名<br></code></pre></td></tr></table></figure><p><strong>自动打印信息</strong></p><ul><li>设置变量名自动显示</li></ul><p>和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动打印出来，而 print 命令则不会。因此，当想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式，常用的语法格式如下 2 种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)</span><br>(gdb) display 变量名<br><br><span class="hljs-comment"># 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令</span><br>(gdb) display/fmt 变量名<br><br></code></pre></td></tr></table></figure><ul><li>查看自动显示列表</li></ul><p>对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行info dispaly命令，可以打印出这张表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># info == i</span><br>(gdb) info display<br>Auto-display expressions now <span class="hljs-keyword">in</span> effect:<br>Num Enb Expression<br>1:   y  i<br>2:   y  array[i]<br>3:   y  /x array[i]<br></code></pre></td></tr></table></figure><p>在展示出的信息中, 每个列的含义如下:</p><p>Num : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号<br>Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。<br>Expression ：被自动打印值的变量或表达式的名字。</p><ul><li>取消自动显示</li></ul><p>对于不需要再打印值的变量或表达式，可以将其删除或者禁用。</p><p>删除自动显示列表中的变量或表达式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span><br>(gdb) undisplay num [num1 ...]<br><span class="hljs-comment"># num1 - numN 表示一个范围</span><br>(gdb) undisplay num1-numN<br><br>(gdb) delete display num [num1 ...]<br>(gdb) delete display num1-numN<br></code></pre></td></tr></table></figure><ul><li>禁用自动显示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span><br>(gdb) <span class="hljs-built_in">disable</span> display num [num1 ...]<br><span class="hljs-comment"># num1 - numN 表示一个范围</span><br>(gdb) <span class="hljs-built_in">disable</span> display num1-numN<br></code></pre></td></tr></table></figure><ul><li>启用已禁用的自动显示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span><br>(gdb) <span class="hljs-built_in">enable</span>  display num [num1 ...]<br><span class="hljs-comment"># num1 - numN 表示一个范围</span><br>(gdb) <span class="hljs-built_in">enable</span> display num1-numN<br></code></pre></td></tr></table></figure><p><strong>单步调试</strong></p><ul><li>step</li></ul><p>step命令可以缩写为s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序<code>会</code>进入到函数体内部。</p><ul><li>next</li></ul><p>next命令和step命令功能是相似的，只是在使用next调试程序的时候<code>不会</code>进入到函数体内部，next可以缩写为 n</p><ul><li>finish</li></ul><p>如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体， 可以执行finish命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</p><ul><li>until</li></ul><p>通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出, 必须要满足以下的条件，否则命令不会生效：</p><p>要跳出的循环体内部不能有有效的断点<br>必须要在循环体的开始&#x2F;结束行执行该命令</p><p>coredump程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = *p;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(p);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="56-移动构造函数"><a href="#56-移动构造函数" class="headerlink" title="56 移动构造函数"></a>56 移动构造函数</h1><p><strong>移动构造函数的初衷：</strong></p><p>使用对象<code>a</code>初始化对象<code>b</code>后对象<code>a</code>就不在使用了，但是对象<code>a</code>的内存还在，如果是拷贝构造函数的话，是将对象<code>a</code>的内容复制一份到对象<code>b</code>中，那么能否直接使用对象<code>a</code>的内存呢，这样就避免了内存的重新分配，降低了构造的成本。</p><p><strong>规则：</strong></p><p>对于拷贝构造函数，是采用深拷贝，对于移动构造函数，采用浅拷贝，但是就会有一个问题，浅拷贝之后两个指针<code>a</code>、<code>b</code>指向同一块内存，如果在析构函数中把a释放掉，那么访问<code>b</code>的时候就会出现异常，解决方法就是将指针<code>a</code>置为<code>null</code>，这样在调用析构函数的时候，由于有判断指针是否为空的语句，析构<code>a</code>的时候并不会回收<code>a</code>指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">Person</span>()<br>&#123;<br>    <span class="hljs-comment">// 析构代码，将堆区开辟的数据做释放操作</span><br>    <span class="hljs-keyword">if</span>(m_height != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_height;<br>        m_height = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参数</strong></p><p>拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</p><p>move语句，就是将一个左值变成一个右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>():<span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>))&#123; cout &lt;&lt; <span class="hljs-string">&quot;construct!&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">demo</span>()&#123;&#125;<br><br>    <span class="hljs-comment">/// 拷贝构造</span><br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">const</span> demo &amp;rhs) : <span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*rhs.num))&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;copy construct!&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    <span class="hljs-comment">/// 移动构造（指针进行浅拷贝，内部重置num为null）</span><br>    <span class="hljs-built_in">demo</span>(demo &amp;&amp;rhs) : <span class="hljs-built_in">num</span>(rhs.num)&#123;<br>        rhs.num = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move construct!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *num;<br>&#125;;<br><br><span class="hljs-function">demo <span class="hljs-title">GetDemo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">demo</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    demo a = <span class="hljs-built_in">GetDemo</span>();  <span class="hljs-comment">// 普通构造</span><br>    <span class="hljs-function">demo <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;<span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-function">demo <span class="hljs-title">c</span><span class="hljs-params">(move(a))</span></span>; <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br>construct!     <br>copy construct!<br>move construct!<br></code></pre></td></tr></table></figure><h1 id="57-C-中将临时变量作为返回值时的处理过程"><a href="#57-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="57 C++中将临时变量作为返回值时的处理过程"></a>57 C++中将临时变量作为返回值时的处理过程</h1><p><strong>函数返回值存在的位置</strong></p><ul><li>在C语言中，函数返回值通常会被<strong>存储在寄存器中</strong>（如ax、eax等），而不是堆栈中。这样设计的目的是为了提高执行效率，避免频繁的堆栈操作。</li><li>在函数调用结束后，返回值<strong>仍然保留在寄存器中</strong>，并且在函数退出时不会被销毁。这意味着返回值可以被调用函数使用，即使临时变量已经被销毁。</li></ul><p><strong>临时变量的生命周期</strong></p><p>临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p><strong>函数返回值的使用</strong></p><p>如果需要返回值，一般使用赋值语句就可以。</p><h1 id="58-程序的内存模型"><a href="#58-程序的内存模型" class="headerlink" title="58 程序的内存模型"></a>58 程序的内存模型</h1><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将<strong>内存</strong>大方向划分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li></ul><p>内存分区的意义：</p><p>不同区域存放的数据，赋予不同的生命周期，可以更灵活的进行编程</p><h2 id="2-程序运行前"><a href="#2-程序运行前" class="headerlink" title="2 程序运行前"></a>2 程序运行前</h2><p>在程序编译后，生成了<code>exe</code>可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p><strong>代码区：</strong></p><ul><li>存放CPU执行的机器指令</li><li>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</li></ul><p><strong>全局区</strong></p><ul><li>存放全局变量、静态变量、字符串常量、const修饰的全局变量</li><li>该区域的数据在程序结束后由操作系统释放</li></ul><h2 id="3-程序运行后"><a href="#3-程序运行后" class="headerlink" title="3 程序运行后"></a>3 程序运行后</h2><p><strong>栈区</strong></p><p>由编译器自动分配释放，存放函数的形参，局部变量，返回值等</p><p>注意：尽量不要返回局部遍量的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> &amp;a;   <span class="hljs-comment">// warning: address of local variable &#x27;a&#x27; returned</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* b = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; *b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆区</strong></p><p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; *a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="59-全局变量和局部变量有什么区别"><a href="#59-全局变量和局部变量有什么区别" class="headerlink" title="59 全局变量和局部变量有什么区别"></a>59 全局变量和局部变量有什么区别</h1><p><strong>生命周期不同：</strong>全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p><strong>使用方式不同：</strong>通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p><h1 id="60-怎样判断两个浮点数是否相等"><a href="#60-怎样判断两个浮点数是否相等" class="headerlink" title="60 怎样判断两个浮点数是否相等"></a>60 怎样判断两个浮点数是否相等</h1><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错。</p><p>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值.</p><p>浮点数与0的比较也应该注意。与浮点数的表示方式有关</p><h1 id="61-方法调用的原理（栈，汇编）"><a href="#61-方法调用的原理（栈，汇编）" class="headerlink" title="61 方法调用的原理（栈，汇编）"></a>61 方法调用的原理（栈，汇编）</h1><h1 id="62-如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#62-如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="62 如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>62 如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p><p>所以必须定义而非声明。</p><h1 id="63-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#63-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="63 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>63 继承机制中对象之间如何转换？指针和引用之间如何转换？</h1><ul><li><p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p></li><li><p>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p></li></ul><p>在C++中，基类的成员函数可以选择性地进行定义。通常情况下，如果基类的成员函数是纯虚函数，那么它必须在基类中进行声明，并且通常是没有函数体的。</p><p>然而，如果基类的成员函数不是纯虚函数，那么它可以在基类中提供具体的实现，也可以选择在派生类中进行覆盖或重载。如果在基类中提供了实现，派生类可以选择性地覆盖这些成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 基类成员函数的声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 虚函数可以没有具体的实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">anotherFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 非虚函数可以在基类中提供具体实现</span><br>&#125;;<br><br><span class="hljs-comment">// 基类成员函数的定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 基类成员函数的实现</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::anotherFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 基类另一个成员函数的实现</span><br>&#125;<br><br><span class="hljs-comment">// 派生类的定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 派生类覆盖基类的虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 派生类提供的实现</span><br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h1 id="64-C-中的组合？它与继承相比有什么优缺点？"><a href="#64-C-中的组合？它与继承相比有什么优缺点？" class="headerlink" title="64 C++中的组合？它与继承相比有什么优缺点？"></a>64 C++中的组合？它与继承相比有什么优缺点？</h1><p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// Engine 类的定义</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine carEngine; <span class="hljs-comment">// Car 类包含 Engine 类的对象作为成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员和方法</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>组合的优点：</strong></p><ul><li>当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</li><li>当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</li><li>当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</li></ul><p><strong>组合的缺点：</strong></p><ul><li><p>容易产生过多的对象。</p></li><li><p>为了能组合多个对象，必须仔细对接口进行定义。</p></li></ul><h1 id="65-函数指针"><a href="#65-函数指针" class="headerlink" title="65 函数指针"></a>65 函数指针</h1><p>函数指针是指向函数的指针变量。 </p><p>函数也是有地址的，函数指针指向函数的地址。</p><h1 id="66-结构体变量比较是否相等"><a href="#66-结构体变量比较是否相等" class="headerlink" title="66 结构体变量比较是否相等"></a>66 结构体变量比较是否相等</h1><p><strong>重载操作符 &#x3D;&#x3D;</strong></p><ul><li>元素一个一个比</li><li>指针直接比较，如果保存的是同一个地址，则相等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span><br>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span>* p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> s &amp;rhs);<br>&#125;;<br><br><span class="hljs-type">bool</span> s::<span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> s &amp;rhs)<br>&#123;<br><span class="hljs-built_in">return</span> ((a == rhs.a) &amp;&amp; (b == rhs.b) &amp;&amp; p == (rhs.p));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span> s1, s2;<br>s1.a = <span class="hljs-number">1</span>;<br>s1.b = <span class="hljs-number">2</span>;<br>s2.a = <span class="hljs-number">1</span>;<br>s2.b = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p1 = &amp;a;<br>    <span class="hljs-type">int</span>* p2 = &amp;a;<br>    s1.p = p1;<br>    s2.p = p2;<br><span class="hljs-keyword">if</span> (s1 == s2)<br>cout &lt;&lt; <span class="hljs-string">&quot;两个结构体相等&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-string">&quot;两个结构体不相等&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>两个结构体相等<br></code></pre></td></tr></table></figure><h1 id="67-memcmp和memset"><a href="#67-memcmp和memset" class="headerlink" title="67 memcmp和memset"></a>67 memcmp和memset</h1><p><strong>memcmp</strong></p><p>memcmp是比较内存区域<code>str</code>1和<code>str2</code>的前<code>count</code>个字节。该函数是按字节比较的，根据字节的<code>ascII</code>码值进行比较</p><p>ASCII码的大小规则：<strong>0<del>9&lt;A</del>Z&lt;a~z</strong></p><p>语法：<code>int memcmp(const void *str1, const void *str2, size_t n)</code></p><p>返回值：</p><ul><li>如果返回值 &gt; 0 ，则表示  str1 &gt; str2；</li><li>如果返回值 &lt; 0 ，则表示  str1 &lt; str2；</li><li>如果返回值 &#x3D; 0 ，则表示  str1 &#x3D; str2；</li></ul><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">char</span> str1[<span class="hljs-number">15</span>];<br>   <span class="hljs-type">char</span> str2[<span class="hljs-number">15</span>];<br>   <span class="hljs-type">int</span> ret;<br><br>   <span class="hljs-built_in">memcpy</span>(str1, <span class="hljs-string">&quot;abcdef&quot;</span>, <span class="hljs-number">6</span>);<br>   <span class="hljs-built_in">memcpy</span>(str2, <span class="hljs-string">&quot;ABCDEF&quot;</span>, <span class="hljs-number">6</span>);<br><br>   ret = <span class="hljs-built_in">memcmp</span>(str1, str2, <span class="hljs-number">5</span>);<br><br>   <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str2 小于 str1&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) <br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 小于 str2&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">else</span> <br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 等于 str2&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br>str2 小于 str1<br></code></pre></td></tr></table></figure><p><strong>memset</strong></p><p>作用：memset是一个初始化函数，作用是将某一块内存中的值设置为指定的值</p><p>声明：<code>void *memset(void *s, int c, size_t n);</code></p><ul><li>s指向要填充的内存块。</li><li>c是要被设置的值。c的实际范围应该在0~255，因为memset函数只能取c的后八位给所输入范围的每个字节。也就是说无论c多大只有后八位二进制是有效的。</li><li>n是要被设置该值的字符数。</li><li>返回类型是一个指向存储区s的指针。</li></ul><p>实例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(str,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-built_in">sizeof</span>(str));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)<br>    &#123;<br>        cout&lt;&lt;str[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(str): %d&quot;</span>, <span class="hljs-built_in">sizeof</span>(str));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(a));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a): %d&quot;</span>, <span class="hljs-built_in">sizeof</span>(a));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span><br><span class="hljs-built_in">sizeof</span>(a): <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>为什么输出结果是 16843009而不是预期的 1？</p><p>因为memset是以字节为单位进行赋值的，int一般占4个字节，1的二进制表示是 00000001，也就是对于每一个a中的元素，它的4个字节都被赋值成了00000001 ， 结果就变成了 00000001 00000001 00000001 00000001，转换为10进制就是16843009。如果用memset初始化非char型的数组要特别注意用法</p><p><strong>具体用法实例</strong></p><ul><li>初始化数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(str,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><ul><li>清空结构体类型的变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> cno;<br>&#125;Stu;<br>Stu stu1; <br><span class="hljs-built_in">memset</span>(&amp;stu1, <span class="hljs-number">0</span> ,<span class="hljs-built_in">sizeof</span>(Stu));<br><br>Stu stu2[<span class="hljs-number">10</span>]; <span class="hljs-comment">//数组</span><br><span class="hljs-built_in">memset</span>(stu2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Stu)*<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h1 id="68-函数调用过程栈的变化，返回值和参数变量哪个先入栈"><a href="#68-函数调用过程栈的变化，返回值和参数变量哪个先入栈" class="headerlink" title="68 函数调用过程栈的变化，返回值和参数变量哪个先入栈"></a>68 函数调用过程栈的变化，返回值和参数变量哪个先入栈</h1><h1 id="69-重载运算符是什么"><a href="#69-重载运算符是什么" class="headerlink" title="69 重载运算符是什么"></a>69 重载运算符是什么</h1><p><strong>定义：</strong></p><p>重载运算符是通过对运算符的重新定义，使得其支持特定数据类型的运算操作。C++ 自带的运算符，最初只定义了一些基本类型的运算规则。当我们要在用户自定义的数据类型上使用这些运算符时，就需要定义运算符在这些特定类型上的运算方式</p><ul><li>引入重载运算符，是为了实现类的多态性</li></ul><p><strong>限制：</strong></p><ul><li>只能对现有的运算符进行重载，不能自行定义新的运算符</li><li>以下运算符不能被重载：<code>::</code>（作用域解析），<code>.</code>（成员访问），<code>.*</code>（通过成员指针的成员访问），<code>?:</code>（三目运算符）。</li></ul><p><strong>实现：</strong></p><p>有两种重载方式：重载为成员函数或非成员函数</p><ul><li>重载为成员函数：<code>Box operator+(const Box&amp;);</code>，隐含一个指向当前成员的<code>this</code>指针作为参数</li><li>重载为非成员函数：<code>Box operator+(const Box&amp;, const Box&amp;);</code></li></ul><h1 id="70-当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#70-当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="70 当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>70 当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ol><li><p>确定候选函数。候选函数有两个特征：</p><ul><li>与被调用的函数同名</li><li>其声明在调用点可见</li></ul></li><li><p>确定可行函数：考察本地函数调用提供的实参，然后从候选参数中选出能被这些实参调用的函数，可行函数也具备两个特征</p><ul><li>形参数量与提供的实参数量相同</li><li>每个实参类型与形参的类型相同，或者能转换成对应的形参的类型</li></ul></li><li><p>最佳匹配：逐一检查函数调用提供的实参，寻找实参类型和形参类型最匹配的那个参数。编译器将实参类型到形参类型的转化划分成几个等级（从 1 到 5 匹配度逐步降低）</p><ul><li>精确匹配，包括以下情况(它们具有相同且最高的匹配度)：<ul><li>实参类型和形参类型相同。</li><li>实参从数组类型或函数类型转换成对应的指针类型</li><li>向实参添加顶层const或者从实参中删除顶层const（形参的顶层cosnt是可以直接忽略掉的）</li></ul></li><li>通过const转化实现匹配(底层const的转换)</li><li>通过类型提升实现的匹配</li><li>通过算术类型转换实现的匹配</li><li>通过类类型转换实现的匹配</li></ul></li></ol><h1 id="71-全局变量和static变量的区别"><a href="#71-全局变量和static变量的区别" class="headerlink" title="71 全局变量和static变量的区别"></a>71 全局变量和static变量的区别</h1><p>全局变量（外部变量）的说明之前再加上<code>static</code>就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。</p><p><strong>作用域不同：</strong></p><ul><li>全局变量：全局对象在程序启动时创建，在程序结束时销毁。全局变量在整个程序文件内可见和可用，其他文件如果使用 extern 关键字声明后也可以访问。</li><li>静态变量：静态变量可以有多种作用域：<ul><li>当静态变量定义在函数内部时（局部静态对象），在第一次使用前分配，它在函数调用结束后不会被销毁，在程序结束时销毁，但作用域只限于该函数内部。</li><li>当静态变量定义在全局范围内时，它与全局变量类似，但作用域仅限于定义它的文件，可以避免在其他源文件中引起错误</li></ul></li></ul><h1 id="72-普通函数和static函数的区别"><a href="#72-普通函数和static函数的区别" class="headerlink" title="72 普通函数和static函数的区别"></a>72 普通函数和static函数的区别</h1><p><strong>作用域不同</strong></p><ul><li>用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用</li><li>而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。</li></ul><p><strong>存在位置</strong></p><p>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p><h1 id="73-普通成员与static成员的区别是什么？"><a href="#73-普通成员与static成员的区别是什么？" class="headerlink" title="73 普通成员与static成员的区别是什么？"></a>73 普通成员与static成员的区别是什么？</h1><p><strong>生命周期</strong></p><ul><li>静态成员变量从类被加载开始到类被卸载，一直存在；</li><li>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</li></ul><p><strong>共享方式</strong></p><ul><li>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</li></ul><p><strong>定义位置</strong></p><ul><li>普通成员变量存储在栈或堆中（存在于包含它们的对象中，取决于对象是怎么创建的，如果对象是作为局部对象创建，存在栈上，如果是通过new创建，存在堆上），而静态成员变量存储在静态全局区；</li></ul><p><strong>初始化位置</strong></p><ul><li>普通成员在类内初始化</li><li>静态成员变量在类外初始化</li></ul><p><strong>默认实参</strong></p><ul><li>可以使用静态成员变量作为默认实参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> defaultValue;  <span class="hljs-comment">// 静态成员变量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> x = defaultValue)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The value is: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::defaultValue = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    MyClass obj2;<br><br>    obj1.<span class="hljs-built_in">myFunction</span>();  <span class="hljs-comment">// 将使用静态成员变量的默认值</span><br>    obj2.<span class="hljs-built_in">myFunction</span>(<span class="hljs-number">200</span>);  <span class="hljs-comment">// 显式提供参数值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>The value is: <span class="hljs-number">100</span><br>The value is: <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="74-ifdef-endif代表着什么？"><a href="#74-ifdef-endif代表着什么？" class="headerlink" title="74 ifdef endif代表着什么？"></a>74 ifdef endif代表着什么？</h1><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p><p>形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ifdef 标识符</span><br>程序段1  <br><span class="hljs-comment">#else  </span><br>程序段2  <br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有</p><p>常见的预处理指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#空指令，无任何效果</span><br><span class="hljs-comment">#include包含一个源代码文件</span><br><span class="hljs-comment">#define定义宏</span><br><span class="hljs-comment">#undef取消已定义的宏</span><br><span class="hljs-comment">#if如果给定条件为真，则编译下面代码</span><br><span class="hljs-comment">#ifdef如果宏已经定义，则编译下面代码</span><br><span class="hljs-comment">#ifndef如果宏没有定义，则编译下面代码</span><br><span class="hljs-comment">#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</span><br><span class="hljs-comment">#endif结束一个#if……#else条件编译块</span><br><span class="hljs-comment">#error停止编译并显示错误信息</span><br></code></pre></td></tr></table></figure><h1 id="75-隐式转换，如何消除隐式转换？"><a href="#75-隐式转换，如何消除隐式转换？" class="headerlink" title="75 隐式转换，如何消除隐式转换？"></a>75 隐式转换，如何消除隐式转换？</h1><ul><li><p>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。</p></li><li><p>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，可以直接将一个子类的对象使用父类的类型进行返回。再比如，数值和布尔类型的转换，整数和浮点数的转换等。</p></li><li><p>基本数据类型的转换以取值范围作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p></li><li><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Entity</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> age)</span> : m_age(age)&#123;</span>&#125;;<br></code></pre></td></tr></table></figure><h1 id="76-C-如何处理多个异常的？"><a href="#76-C-如何处理多个异常的？" class="headerlink" title="76 C++如何处理多个异常的？"></a>76 C++如何处理多个异常的？</h1><p><strong>C++中的异常情况：</strong></p><ul><li>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。</li><li>运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li></ul><p><strong>C++异常处理机制：</strong></p><p>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> <br>&#123; <br>可能抛出异常的语句；（检查） <br>&#125; <br><span class="hljs-keyword">catch</span>（类型名[形参名]）<span class="hljs-comment">//捕获特定类型的异常 </span><br>&#123; <br><span class="hljs-comment">//处理1； </span><br>&#125; <br><span class="hljs-keyword">catch</span>（类型名[形参名]）<span class="hljs-comment">//捕获特定类型的异常 </span><br>&#123; <br><span class="hljs-comment">//处理2； </span><br>&#125; <br><span class="hljs-keyword">catch</span>（…）<span class="hljs-comment">//捕获所有类型的异常 </span><br>&#123; <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="77-如何在不使用额外空间的情况下，交换两个数？有几种方法"><a href="#77-如何在不使用额外空间的情况下，交换两个数？有几种方法" class="headerlink" title="77 如何在不使用额外空间的情况下，交换两个数？有几种方法"></a>77 如何在不使用额外空间的情况下，交换两个数？有几种方法</h1><p>算术：有溢出风险</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = x + y;<br>y = x - y;<br>x = x - y;<br></code></pre></td></tr></table></figure><p>异或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = x ^ y; <br>y = x ^ y;<br>x = x ^ y;<br></code></pre></td></tr></table></figure><h1 id="78-strcpy和memcpy的区别"><a href="#78-strcpy和memcpy的区别" class="headerlink" title="78 strcpy和memcpy的区别"></a>78 strcpy和memcpy的区别</h1><p><strong>操作对象不同</strong></p><ul><li>strcpy的两个操作对象均为字符串</li><li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li></ul><p><strong>复制的方法不同</strong></p><ul><li>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。</li><li>memcpy则是根据其第3个参数决定复制的长度</li></ul><p><strong>实现功能不同</strong></p><ul><li>strcpy主要实现字符串变量间的拷贝</li><li>memcpy主要是内存块间的拷贝</li></ul><p><strong>memcpy</strong></p><p>声明：<code>void *memcpy(void*dest, const void *src, size_t n);</code></p><p>作用：由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将字符串复制到数组 dest 中</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span> src[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;http://www.runoob.com&quot;</span>;<br>   <span class="hljs-type">char</span> dest[<span class="hljs-number">50</span>];<br> <br>   <span class="hljs-built_in">memcpy</span>(dest, src, <span class="hljs-built_in">strlen</span>(src)+<span class="hljs-number">1</span>);  <span class="hljs-comment">// +1 是因为src是c语言风格字符串，以&#x27;\0&#x27;结尾，这样可以保证完整复制</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dest = %s\n&quot;</span>, dest);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>dest = http:<span class="hljs-comment">//www.runoob.com</span><br></code></pre></td></tr></table></figure><p><strong>strcpy</strong></p><p>声明：<code>char* strcpy(char* dest, const char* src);</code></p><p>作用：把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>。</p><p>注意：如果目标数组<code>dest</code>不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p><p>个人理解：使用的时候相当于先把<code>dest</code>清空，再把<code>src</code>的内容复制到<code>dest</code>上，直到遇到<code>src</code>的<code>&#39;\0&#39;</code>为止</p><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> src[] = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">char</span> dest[] = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, src); <span class="hljs-comment">// a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, dest); <span class="hljs-comment">// bbb</span><br><br>    <span class="hljs-built_in">strcpy</span>(dest, src);<br>   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, src); <span class="hljs-comment">// a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, dest); <span class="hljs-comment">// a</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="79-size-t"><a href="#79-size-t" class="headerlink" title="79 size_t"></a>79 size_t</h1><p><code>size_t</code>是<strong>无符号</strong>的长整型，一般用来表示字节数的多少。常用于如sizeof返回值的类型。</p><p><strong>与<code>int</code>类型相比，主要的特点为</strong></p><ul><li><code>size_t</code>是无符号的，<code>int</code>是有符号的。</li><li><code>size_t</code>是一种跟具体的平台有关联的类型，会具体调整其能表示的范围，因此其可移植性会更好。</li><li><code>size_t</code>能保证可以存储任何类型理论上可能的对象的最大值，包括数组类型。而<code>int</code>类型则只能保证<strong>16</strong>位或 <strong>32</strong>位的长度，且<code>int</code>为有符号的类型，其能存储的范围就更小了。对于存储超过该范围的数值时，就会出现问题，而<code>size_t</code>则没有此问题。</li></ul><p>常见用法：</p><ul><li>当表示或计算字节数的大小时，用<code>size_t</code>，如计算 sizeof 返回值时。</li><li>当用于数组索引和循环计数时，推荐使用<code>size_t</code>。尤其对于循环中的索引值递减时，由于<code>int</code>可以为负值，<code>unsigned int</code>不可以为0，此时递减的循环很容易出问题</li></ul><h1 id="80-C-中标准库是什么"><a href="#80-C-中标准库是什么" class="headerlink" title="80 C++中标准库是什么"></a>80 C++中标准库是什么</h1><p>C++ 标准库可以分为两部分：</p><p><strong>标准函数库</strong>：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p><ul><li>输入&#x2F;输出 I&#x2F;O</li><li>字符串和字符处理</li><li>数学</li><li>时间、日期和本地化</li><li>动态分配</li><li>其他</li><li>宽字符函数</li></ul><p><strong>面向对象类库</strong>：这个库是类及其相关函数的集合。</p><ul><li>标准的 C++ I&#x2F;O 类</li><li>String 类</li><li>数值类</li><li>STL 容器类</li><li>STL 算法</li><li>STL 函数对象</li><li>STL 迭代器</li><li>STL 分配器</li><li>本地化库</li><li>异常处理类</li><li>杂项支持库</li></ul><h1 id="81-静态绑定和动态绑定"><a href="#81-静态绑定和动态绑定" class="headerlink" title="81 静态绑定和动态绑定"></a>81 静态绑定和动态绑定</h1><p>当使用基类的引用（或者指针）调用一个虚函数时将发生动态绑定。</p><p>函数的运行版本由实参决定，即在函数运行时选择函数的版本，所以动态绑定又称为运行时绑定。</p><h1 id="82-如何设计一个计算仅单个子类的对象个数？"><a href="#82-如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="82 如何设计一个计算仅单个子类的对象个数？"></a>82 如何设计一个计算仅单个子类的对象个数？</h1><p>1、为类设计一个static静态变量count作为计数器；</p><p>2、类定义结束后初始化count;</p><p>3、在构造函数中对count进行+1;</p><p>4、 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p><p>5、设计赋值构造函数，在进行赋值函数中对count+1操作；</p><p>6、在析构函数中对count进行-1；</p><h1 id="83-成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#83-成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="83 成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>83 成员初始化列表会在什么时候用到？它的调用过程是什么？</h1><p><strong>非静态常量成员必须使用成员初始化列表进行初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用成员的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> &amp;t;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> &amp;t):<span class="hljs-built_in">t</span>(t)&#123;&#125;  <span class="hljs-comment">//必须使用初始化列表</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">22</span>;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(x)</span></span>;<br>    cout &lt;&lt; t1.t &lt;&lt; endl;<br>    x = <span class="hljs-number">33</span>;<br>    cout &lt;&lt; t1.t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>初始化没有默认构造函数的成员对象</strong></p><p>类<code>B</code> 的数据成员<code>a</code>是类<code>A</code>的一个对象, 并且<code>A</code>没有默认构造函数，则<code>B</code>必须使用初始化列表来对<code>a</code>进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>A::<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> arg)  <br>&#123;  <br>  i = arg;  <br>  cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s Constructor called: Value of i: &quot;</span> &lt;&lt; i &lt;&lt; endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// 类B包含A的一个对象  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>  <br>&#123;  <br>  A a;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>B::<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x)   <span class="hljs-comment">//必须使用初始化列表  </span><br>&#123;  <br>  cout &lt;&lt; <span class="hljs-string">&quot;B&#x27;s Constructor called&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br><span class="hljs-comment">//输出结果：</span><br>A<span class="hljs-number">&#x27;</span>s Constructor called: Value of i: <span class="hljs-number">10</span><br>B<span class="hljs-number">&#x27;</span>s Constructor called<br></code></pre></td></tr></table></figure><p><strong>基类数据成员的初始化</strong></p><p>如果想要带参数的构造函数初始化基类，则子类必须使用初始化列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>);<br>&#125;;  <br>  <br>A::<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> arg)  <br>&#123;  <br>  i = arg;  <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s Constructor called: Value of i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// Class B 继承自Class A  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : A  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>B::<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x) :  <span class="hljs-built_in">A</span>(x)  <br>&#123; <span class="hljs-comment">//必须使用初始化列表  </span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;B&#x27;s Constructor called&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>当调用一个成员类的构造函数，而他拥有一组参数</strong></p><h1 id="84-静态-非静态、常量-变量初始化方式"><a href="#84-静态-非静态、常量-变量初始化方式" class="headerlink" title="84 静态&#x2F;非静态、常量&#x2F;变量初始化方式"></a>84 静态&#x2F;非静态、常量&#x2F;变量初始化方式</h1><p>初始化方式：成员列表初始化、定义时直接初始化、类内声明类外初始化、构造函数内初始化</p><p><strong>静态成员常量</strong>：定义时直接初始化、类内声明类外初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 类内声明类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>静态成员变量</strong>：类内声明类外初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类内声明类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>非静态成员常量</strong>：成员列表初始化、定义时直接初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//成员列表初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>非静态成员变量</strong>：成员列表初始化、定义时直接初始化、构造函数内初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 成员列表初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数内初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        m_num = <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="85-在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#85-在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="85 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>85 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</h1><p>对比值传递，引用传参的好处：</p><ul><li>在函数内部可以对此参数进行修改</li><li>提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</li></ul><p>函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本</p><p>但是有以下的限制：</p><ul><li>不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁，没有意义</li><li>不能返回函数内部new分配的内存的引用，当函数执行完毕时，函数内部使用<code>new</code>分配的内存将会被释放，从而使得引用变为悬空引用</li></ul><h1 id="86-将引用作为函数参数有哪些好处？"><a href="#86-将引用作为函数参数有哪些好处？" class="headerlink" title="86 将引用作为函数参数有哪些好处？"></a>86 将引用作为函数参数有哪些好处？</h1><ul><li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li></ul><p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p><p>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><ul><li>传递引用给函数与传递指针的效果是一样的</li></ul><p>被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对实参的操作。</p><h1 id="87-数组和指针的区别"><a href="#87-数组和指针的区别" class="headerlink" title="87 数组和指针的区别"></a>87 数组和指针的区别</h1><p><strong>概念</strong></p><p>数组：存储连续多个相同类型的数据</p><p>指针：变量，存的是地址</p><p><strong>赋值</strong></p><p>同类型的指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</p><p><strong>存储方式</strong></p><p>数组：连续内存空间。</p><p>指针：就是一个变量，指向一个地址，可以指向任意类型的数据。</p><p><strong>sizeof</strong></p><p>数组的sizeof求的是占用的空间（字节）。</p><p>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</p><p><strong>传参</strong></p><p>作为参数时，数组名退化为常量指针</p><h1 id="88-如何阻止一个类被实例化？有哪些方法？"><a href="#88-如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="88 如何阻止一个类被实例化？有哪些方法？"></a>88 如何阻止一个类被实例化？有哪些方法？</h1><ul><li>将类定义为抽象基类，抽象类是不能被实例化的，只能被继承</li><li>将构造函数声明为private</li><li>抛出异常</li></ul><h1 id="89-如何禁止程序自动生成拷贝构造函数？"><a href="#89-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="89 如何禁止程序自动生成拷贝构造函数？"></a>89 如何禁止程序自动生成拷贝构造函数？</h1><p><strong>将这些函数声明为删除的函数，在函数参数的后面加上</strong>&#x3D;delete<strong>来指示出我们定义的删除的函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 禁用默认的拷贝构造函数  </span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>;  <br>      <br>    <span class="hljs-comment">// 禁用默认的拷贝赋值函数  </span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>;  <br>  <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>将这些函数声明为</strong>private**,并且不提供函数定义，如果只声明不定义，会产生链接错误，也就无法生成拷贝构造函数了**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;);  <span class="hljs-comment">// 声明私有拷贝构造函数  </span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp;);  <span class="hljs-comment">// 声明私有赋值运算符  </span><br>    <span class="hljs-comment">// 其他成员和方法  </span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="90-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#90-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="90 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>90 strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><p><strong>strcpy</strong></p><p>函数声明：<code>char* strcpy(char* strDest, const char* strSrc)</code></p><p><code>strcpy</code>是覆盖拷贝，将<code>strSrc</code>全部覆盖拷贝到<code>strDest</code>，也会把<code>&#39;\0&#39;</code>拷贝进去，且必须考虑<code>strDest</code>的空间够不够（<code>strDest</code>的空间必须 ≥ <code>strSrc</code>的空间）</p><p><strong>strncpy</strong></p><p>函数声明：<code>char *strncpy(char *dest, const char *src, size_t len);</code></p><ul><li>第一个参数是指向目标空间的起始地址 <code>char *dest</code></li><li>第二个参数是源字符串的起始地址 <code>char *src</code></li><li>第三个字符串是无符号整数 <code>len</code>，表示源字符串向目标字符串写入的字符数</li></ul><p>函数作用：表示源字符串向目标字符串拷贝<code>len</code>个字符</p><ul><li>如果源字符串长度小于<code>len</code>，那么目标空间会以<code>&#39;\0&#39;</code>填充到<code>len</code>个长度</li><li>如果源字符串长度大于等于<code>len</code>，那么将会只有<code>len</code>个字符填充到目标空间，且不会以<code>&#39;\0&#39;</code>结尾</li></ul><p>使用场景：</p><ul><li><p>源字符串长度 ＞ 目标字符串长度</p><ul><li>源字符串长度 &lt; <code>len</code></li></ul><p>错误，溢出，但可能有输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br><span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">5</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>源字符串长度 ≥ <code>len</code></li></ul><p>错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br><span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出</span><br>ab怈<br></code></pre></td></tr></table></figure></li><li><p>源字符串长度 ≤ 目标字符串长度</p><ul><li>源字符串长度 &lt; <code>len</code></li></ul><p>将 <code>src</code>字符串全部拷贝到目标空间中，超过<code>src</code>长度小于<code>len</code>的以 <code>&#39;\0&#39;</code>补充，剩余保持原状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br><span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">5</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">5</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">6</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">7</span>]);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br>abcd<br>a   <br>b   <br>c   <br>d   <br>    <br><span class="hljs-number">6</span>   <br><span class="hljs-number">7</span>   <br><span class="hljs-number">8</span> <br></code></pre></td></tr></table></figure><ul><li>源字符串长度 ≥ <code>len</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br><span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">3</span>);<br>    str[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 手动加&#x27;\0&#x27;</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">5</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">6</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">7</span>]);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>安全性</strong></p><ul><li>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</li></ul><p><code>strncpy</code>比<code>strcpy</code>更安全的原因如下：</p><ul><li>目标字符串大小限制：<code>strncpy</code>函数接受一个目标字符串的大小限制参数，这可以确保复制的字符数不会超过目标字符串的容量。因此，即使源字符串的长度超过了目标字符串的大小，也只会发生部分复制，从而避免了缓冲区溢出的问题。</li><li>源字符串长度不确定：在某些情况下，源字符串的长度是未知的，或者无法通过其他方式确定。使用<code>strncpy</code>函数可以避免在不知道源字符串长度的情况下使用<code>strcpy</code>导致的潜在风险。</li><li>内存安全性：由于<code>strncpy</code>可以指定复制的字符数，因此可以避免在目标字符串中复制不必要的字符，从而避免了潜在的内存越界问题。</li></ul><h1 id="91-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#91-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="91 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast"></a>91 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast</h1><h1 id="92-static-cast比C语言中的转换强在哪里？"><a href="#92-static-cast比C语言中的转换强在哪里？" class="headerlink" title="92 static_cast比C语言中的转换强在哪里？"></a>92 static_cast比C语言中的转换强在哪里？</h1><h1 id="93-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#93-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="93 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>93 成员函数里memset(this,0,sizeof(*this))会发生什么</h1><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就<code>memset(this, 0, sizeof *this);</code>将整个对象的内存全部置为0，但是下面场景是不能用的：</p><ul><li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常</li><li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存</li></ul><h1 id="94-回调函数及其作用"><a href="#94-回调函数及其作用" class="headerlink" title="94 回调函数及其作用"></a>94 回调函数及其作用</h1><h1 id="95-delete和delete-区别？"><a href="#95-delete和delete-区别？" class="headerlink" title="95 delete和delete[]区别？"></a>95 delete和delete[]区别？</h1><ul><li>delete只会调用一次析构函数。</li><li>delete[]会调用数组（如果是对象的数组）中每个元素的析构函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> *pAa = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> A[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> pAa;<br></code></pre></td></tr></table></figure><h1 id="96-为什么不能把所有的函数写成内联函数"><a href="#96-为什么不能把所有的函数写成内联函数" class="headerlink" title="96 为什么不能把所有的函数写成内联函数?"></a>96 为什么不能把所有的函数写成内联函数?</h1><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数</p><ul><li>函数体内的代码比较长，将导致内存消耗</li><li>函数体内有循环，函数执行时间要比函数调用开销大</li></ul><h1 id="97-C-11新特性"><a href="#97-C-11新特性" class="headerlink" title="97 C++11新特性"></a>97 C++11新特性</h1><h2 id="nullptr替代NULL"><a href="#nullptr替代NULL" class="headerlink" title="nullptr替代NULL"></a>nullptr替代NULL</h2><p>C++中NULL和nullptr的区别</p><ul><li>NULL来自C语言，一般由宏定义实现，而nullptr是C++11新增的关键字</li><li>在C语言中，NULL被定义为<code>(void*)0</code>，在C++语言中，NULL被定义为整数0。编译器一般对其实际定义如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C中NULL的定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><br><br><span class="hljs-comment">// C++中NULL的定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果函数重载成整型和指针间的版本，传入NULL会被匹配到整型形参版本的函数，而不是预期的指针版本。<code>nullptr</code>在C++11中被引入用于解决一问题，<code>nullptr</code>可以明确区分整型和指针类型，能够根据环境自动转换成响应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f(int)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f(char*)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但使用<code>nullptr</code>仍会出现一种问题：如果函数在不同指针之间转换，那么传入<code>nullptr</code>仍然无法匹配到函数，会报错，这时需要显式调用函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f(int)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f(char*)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f(int*)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 报错，不知道匹配哪个函数</span><br>    <span class="hljs-built_in">f</span>((<span class="hljs-type">int</span>*)<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 显示调用函数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引入了auto和decltype这两个关键字实现了类型推导"><a href="#引入了auto和decltype这两个关键字实现了类型推导" class="headerlink" title="引入了auto和decltype这两个关键字实现了类型推导"></a>引入了auto和decltype这两个关键字实现了类型推导</h2><p>auto：auto让编译器通过初始值来进行类型推演，从而获得定义变量的类型，所以<code>auto</code>定义的变量必须有初始值。</p><p>decltype：有时需要获取表达式的类型，但又不希望实际执行表达式，使用decltype关键字来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func</span>()) sum = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><h2 id="类和结构体的初始化列表"><a href="#类和结构体的初始化列表" class="headerlink" title="类和结构体的初始化列表"></a>类和结构体的初始化列表</h2><h2 id="右值引用和move语义"><a href="#右值引用和move语义" class="headerlink" title="右值引用和move语义"></a>右值引用和move语义</h2><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h1 id="98-内存分区"><a href="#98-内存分区" class="headerlink" title="98 内存分区"></a>98 内存分区</h1><p><img src="/../imgs/$%7Bfiilename%7D/image-20240423165237625.png" alt="image-20240423165237625"></p><p><strong>栈：</strong>存放函数内部局部非静态变量。函数执行结束时这些存储单元自动被释放，栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p><p><strong>堆：</strong>就是那些由<code>new</code>分配的内存块（动态分配的对象，即那些在程序运行时分配的对象），由程序员管理内存的释放，如果程序没有被释放掉，那么在程序结束后，由操作系统回收。但在程序结束前，会造成内存泄漏。</p><p><strong>全局&#x2F;静态存储区：</strong>静态变量（局部static对象、类static数据成员）、全局变量</p><p><strong>常量存储区：</strong>存放的是常量，不允许修改</p><p><strong>代码区：</strong>存放函数体的二进制代码</p><h1 id="99-智能指针"><a href="#99-智能指针" class="headerlink" title="99 智能指针"></a>99 智能指针</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>指针的使用很容易出问题，确保在正确的时间释放内存是很困难的</p><ul><li>如果忘记释放内存，会产生内存泄漏（在堆中使用new创建一块内存，不用了之后没有及时释放掉（delete），程序执行结束这种不会再归还给堆了）。</li><li>使用已经释放掉的对象</li></ul><p>为了更安全和更容器地使用动态内存，产生了智能指针。智能指针的行为类似于常规指针，重要的区别就是它负责自动释放所指向的对象。新标准库中提供了两种智能指针。<code>unique_ptr</code>和<code>shared_ptr</code>这两种智能指针的区别在于管理底层指针的方式：</p><ul><li><code>shared_ptr</code>允许多个指针指向同一个对象</li><li><code>unique_ptr</code>则独占所指向的对象</li></ul><p>标准库中还定义了一个名为<code>week_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象</p><p><code>share_ptr</code>和<code>unique_ptr</code>都支持的操作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>shared_ptr<T> sp<br />unique_ptr<T> up</td><td>空智能指针，可以指向类型为T的对象</td></tr><tr><td>p</td><td>将p用作一个条件判断，若p指向一个对象，则为true</td></tr><tr><td>*p</td><td>解引用p，获得它指向的对象</td></tr><tr><td>p-&gt;mem</td><td>等价于(*p).mem</td></tr><tr><td>p.get()</td><td>返回p中保存的指针。要小心使用，如果智能指针释放了其对象，返回的指针所指向的对象也就消失了</td></tr><tr><td>swap(p，q)<br />p.swap(q)</td><td>交换p和q中的指针</td></tr></tbody></table><h2 id="shared-ptr类（共享指针）"><a href="#shared-ptr类（共享指针）" class="headerlink" title="shared_ptr类（共享指针）"></a>shared_ptr类（共享指针）</h2><p><strong>创建<code>shared_ptr</code>指针</strong>：<code>make_shared</code>函数</p><p><code>make_shared</code>函数：在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>（最安全的分配和使用动态内存的方式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;9&#x27;</span>); <span class="hljs-comment">// 指向一个值为&quot;999&quot;的string的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// 指向一个值初始化的int，即值为0</span><br><span class="hljs-keyword">auto</span> p6 = make_shared&lt;vector&lt;string&gt;&gt;; <span class="hljs-comment">// p6指向一个动态分配的空vector&lt;string&gt;</span><br></code></pre></td></tr></table></figure><p><strong><code>shared_ptr</code>的拷贝和赋值</strong></p><p>当进行拷贝或者赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其它<code>shared_ptr</code>指向相同的对象。可以认为每个<code>shared_ptr</code>都有一个关联的计数器，通常称其为<code>引用计数</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// p的指向放到对象只有p一个引用者</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">q</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// p和q指向相同的对象，此对象有两个引用者</span><br></code></pre></td></tr></table></figure><p>计数器增加的情况：拷贝一个<code>shared_ptr</code></p><ul><li>当用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code></li><li>将一个<code>shared_ptr</code>作为参数传递给一个函数</li><li>作为函数的返回值</li></ul><p>计数器减少的情况：</p><ul><li>当给<code>shared_ptr</code>赋予一个新值</li><li><code>shared_ptr</code>被销毁（例如一个局部的<code>shared_ptr</code>离开作用域）</li></ul><blockquote><p>一旦一个<code>shared_ptr</code>的计数器变为0，它就会自动释放自己所管理的对象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">41</span>);<br><span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// r指向的int只有一个使用者</span><br><span class="hljs-comment">//给r赋值，令它指向另一个地址</span><br><span class="hljs-comment">//递增q指向的对象的引用计数</span><br><span class="hljs-comment">//递减r原来指向的对象的引用计数</span><br><span class="hljs-comment">//r原来指向的对象已经没有引用者,会自动释放</span><br>r = q; <br></code></pre></td></tr></table></figure><blockquote><p>到底是用一个计数器还是其它数据结构来记录有多少个指针共享对象，完全由标准库的具体实现来决定。关键是智能指针类能记录由多少个 shared_ptr 指向相同的对象，并能在恰当的时候自动释放对象</p></blockquote><p><strong>shared_ptr自动销毁所管理的对象</strong></p><p>当指向一个对象的最后一个<code>shared_ptr</code>被销毁时，<code>shared_ptr</code>类会自动销毁此对象。它是通过析构函数完成销毁工作的。</p><p><code>shared_ptr</code>的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数就会销毁对象，并释放它占用的内存。</p><p><strong>shared_ptr自动释放相关联的内存</strong></p><p>当动态对象不再被使用时，<code>shared_ptr</code>类会自动释放动态对象</p><h2 id="unique-ptr类（独占指针）"><a href="#unique-ptr类（独占指针）" class="headerlink" title="unique_ptr类（独占指针）"></a>unique_ptr类（独占指针）</h2><p><strong>含义：</strong>某个时刻只能有一个<code>unique_ptr</code>指向一个给定对象</p><p><strong>特点：</strong></p><ul><li>由于一个<code>unique_ptr</code>拥有它指向的对象，因此<code>unique_ptr</code>不支持普通的拷贝或赋值操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;111&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <span class="hljs-comment">// 错误，unique_ptr不能拷贝</span><br>unique_ptr&lt;string&gt; p3;<br>p3 = p1;<span class="hljs-comment">// 错误，unique_ptr不支持赋值</span><br></code></pre></td></tr></table></figure><p><strong>创建方式：</strong></p><ul><li>通过已有指针创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">//如果p2释放，那么p指针就不能用了</span><br></code></pre></td></tr></table></figure><ul><li>通过<code>new</code>来创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><ul><li>通过<code>release</code>或<code>reset</code>将指针的所有权从一个（非<code>const</code>）<code>unique_ptr</code>转移给另一个<code>unique_ptr</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// release成员返回unique_ptr当前保存的指针并将其置为空，因此p2被初始化为p1原来保存的指针，而p1被置为空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Stegosaurus&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1.release())</span></span>; <br><br><span class="hljs-comment">// reset接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，它原来指向的对象被释放</span><br><span class="hljs-comment">// 因此，对p2调用释放了用&quot;Stegosaurus&quot;初始化的string所使用的内存，将p3的使用权交给了p2，并将p3置空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br>p2.<span class="hljs-built_in">reset</span>(p3.<span class="hljs-built_in">release</span>());<br></code></pre></td></tr></table></figure><blockquote><p>调用release会切断unique_ptr和它原来管理的对象间的联系。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。</p></blockquote><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr专门用于解决<code>share_ptr</code>循环引用的问题。<code>weak_ptr</code>不会修改引用计数，也就是它的存在并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个<code>shared_ptr</code>成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，与普通指针比较大的区别是，弱指针能检测到所管理的对象是否已经释放，从而避免访问非法内存。</p><p>当创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>wak_ptr<T> w</td><td>空wak_ptr可以指向类型为T的对象</td></tr><tr><td>wak_ptr<T> w(sp)</td><td>与shared_ptr sp指向相同对象的wak_ptr。T必须能够转换为sp指向的类型</td></tr><tr><td>w&#x3D;p</td><td>p可以是一个sharead_ptr或一个weak_ptr。赋值后w与p共享对象</td></tr><tr><td>w.reset()</td><td>将w置为空</td></tr><tr><td>w.use_count()</td><td>与w共享对象的shared_ptr的数量</td></tr><tr><td>w.expired()</td><td>若w.use_count()为0，返回true，否则返回false</td></tr><tr><td>w.lock()</td><td>如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><h1 id="100-智能指针相关问题"><a href="#100-智能指针相关问题" class="headerlink" title="100 智能指针相关问题"></a>100 智能指针相关问题</h1><h2 id="1-讲一下什么是智能指针-智能指针有哪几种"><a href="#1-讲一下什么是智能指针-智能指针有哪几种" class="headerlink" title="1 讲一下什么是智能指针&#x2F;智能指针有哪几种"></a>1 讲一下什么是智能指针&#x2F;智能指针有哪几种</h2><p>相比于裸指针，智能指针是对裸指针的一种封装，初衷是让程序员无需手动释放内存，来避免内存泄漏。常见的智能指针有<code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code></p><h2 id="2-讲一下这几种智能指针的区别和优缺点"><a href="#2-讲一下这几种智能指针的区别和优缺点" class="headerlink" title="2 讲一下这几种智能指针的区别和优缺点"></a>2 讲一下这几种智能指针的区别和优缺点</h2><ul><li><code>auto_ptr</code>在C++11中就已经标为废弃了，代替它的是<code>unique_ptr</code>，相比之下，<code>unique_ptr</code>语义更加清晰，更加安全，不允许复制，更加高效，并且更好地支持数组。</li><li><code>weak_ptr</code>本身不具备内存管理的能力，它主要是为了解决<code>shared_ptr</code>可能导致的循环引用问题，<code>weak_ptr</code>的原理就是指向某个资源时，它不会增加这个资源的引用计数，因此实际上真正意义上的智能指针就是<code>unique_ptr</code>和<code>shared_ptr</code></li><li><code>unique_ptr</code>最主要的特点就是对资源是独占的，它不可以复制和用来拷贝。它<strong>通过在析构函数中释放资源来管理对象的生命周期</strong>，来自动管理资源。可以防止多个智能指针指向同一个对象，更加方便于管理。相比<code>shared_ptr</code>，它的优点是高效，避免了循环引用的问题</li><li>当一个资源需要在多个对象之间共享时，就无法使用<code>unique_ptr</code>了。这时就需要使用到<code>shared_ptr</code>，它<strong>通过引用计数的方式来对资源进行控制</strong>，但是它存在循环引用的问题。需要结合<code>weak_ptr</code>来避免。</li></ul><h2 id="3-讲一下循环引用是如何发生的，以及如何解决"><a href="#3-讲一下循环引用是如何发生的，以及如何解决" class="headerlink" title="3 讲一下循环引用是如何发生的，以及如何解决"></a>3 讲一下循环引用是如何发生的，以及如何解决</h2><p>在两个或多个对象相互引用，或者一些复杂的数据结构，如图、双向链表中，存在多个引用路径等情况下，可能会出现循环引用的问题，导致资源无法被释放掉，这时候就需要使用<code>weak_ptr</code>来打破循环引用。因为使用<code>weak_ptr</code>指向某一个资源时，它不会增加这个资源的引用计数</p><h2 id="4-weak-ptr是弱引用，它弱在哪里？"><a href="#4-weak-ptr是弱引用，它弱在哪里？" class="headerlink" title="4 weak_ptr是弱引用，它弱在哪里？"></a>4 weak_ptr是弱引用，它弱在哪里？</h2><p>使用<code>weak_ptr</code>指向某一个资源时，它不会增加这个资源的引用计数</p><h2 id="5-具体讲一下shared-ptr自动管理内存的原理-引用计数的具体原理-shared-ptr引用计数什么时候会增加，什么时候减少"><a href="#5-具体讲一下shared-ptr自动管理内存的原理-引用计数的具体原理-shared-ptr引用计数什么时候会增加，什么时候减少" class="headerlink" title="5 具体讲一下shared_ptr自动管理内存的原理&#x2F;引用计数的具体原理&#x2F;shared_ptr引用计数什么时候会增加，什么时候减少"></a>5 具体讲一下shared_ptr自动管理内存的原理&#x2F;引用计数的具体原理&#x2F;shared_ptr引用计数什么时候会增加，什么时候减少</h2><p><strong>引用计数的核心原理</strong></p><p>在shared_ptr的内部维护了一个计数器，来跟踪有多少个shared_ptr对象指向了某一个资源。当计数器的值减少到0的时候，shared_ptr就会调用delete来释放资源（或者用户自定义的方法）</p><p><strong>计数器增加的情况：拷贝一个<code>shared_ptr</code></strong></p><ul><li>当用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code></li><li>将一个<code>shared_ptr</code>作为参数传递给一个函数</li><li>作为函数的返回值</li></ul><p><strong>计数器减少的情况：</strong></p><ul><li>当给<code>shared_ptr</code>赋予一个新值</li><li><code>shared_ptr</code>被销毁（例如一个局部的<code>shared_ptr</code>离开作用域）</li></ul><h1 id="101-左值引用和右值引用"><a href="#101-左值引用和右值引用" class="headerlink" title="101 左值引用和右值引用"></a>101 左值引用和右值引用</h1><p><strong>左值：</strong></p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>区分左值和右值：</strong></p><ul><li>左值<ul><li>可以在等号左边</li><li>能够取地址</li><li>具名</li></ul></li><li>右值<ul><li>只能在等号右边</li><li>不能取地址</li><li>不具名</li></ul></li></ul><p><strong>左值和右值举例：</strong></p><p>左值：</p><ul><li>变量名</li><li>返回左值引用的函数调用</li><li>前置自增&#x2F;自减</li><li>赋值运算</li><li>解引用等等</li></ul><p>右值：</p><ul><li>纯右值<ul><li>字面值</li><li>返回非引用类型的函数调用</li><li>后置自增&#x2F;自减</li><li>算术表达式</li><li>逻辑表达式</li><li>比较表达式</li></ul></li><li>将亡值</li></ul><p><strong>左值引用的含义</strong>：是对左值的引用</p><p><strong>右值引用的含义：</strong>是对右值的引用</p><p><strong>两者的功能及差异：</strong></p><ul><li>使用左值引用避免对象的拷贝<ul><li>函数传参</li><li>函数返回值</li></ul></li><li>使用右值引用为了实现移动语义、实现完美转发</li></ul><h1 id="102-C-中类的数据成员和成员函数的内存分布"><a href="#102-C-中类的数据成员和成员函数的内存分布" class="headerlink" title="102 C++中类的数据成员和成员函数的内存分布"></a>102 C++中类的数据成员和成员函数的内存分布</h1><p><strong>一个类的对象的地址就是类所包含的这一片内存的首地址，这个首地址就对应某一个成员变量的地址</strong></p><ul><li>对象的大小和对象中数据成员的大小是一致的，也就是成员函数不占用内存。这是因为所有的函数都是存放在代码区的，不管是全局函数还是成员函数。包括静态函数（静态函数不存放在全局区）</li></ul><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">23</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age &lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age地址: &quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;age大小: &quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(p.age) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br>对象地址：<span class="hljs-number">0x61fe0c</span><br>age地址: <span class="hljs-number">0x61fe0c</span><br>对象大小：<span class="hljs-number">4</span><br>age大小: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h1 id="103-this指针"><a href="#103-this指针" class="headerlink" title="103 this指针"></a>103 this指针</h1><p><code>this</code>指针是类的指针，指向对象的首地址，因此<code>this</code>指针只能在非静态成员函数中使用，在静态函数、全局函数中都不能用（不属于某个对象）</p><p><strong><code>this</code>指针的作用</strong></p><ul><li><p>一个对象的<code>this</code>指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</p></li><li><p><code>this</code>作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使没有显示地写this指针，编译器在编译的时候也是加上<code>this</code>的，它作为非静态成员函数的隐形形参，对各成员的访问均通过<code>this</code>进行</p></li></ul><p><strong><code>this</code>指针的使用</strong></p><ul><li>在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code></li><li>当形参与成员变量名相同时用于区分，如<code>this-&gt;n = n</code>（不能写成n &#x3D; n，相当于形参给形参自己赋值）</li></ul><p><strong><code>this</code>指针的特点</strong></p><ul><li><p>this指针不占用类的大小</p></li><li><p>this<strong>只能</strong>在成员函数中使用，全局函数、静态函数都不能使用<code>this</code>。原因：</p><ul><li>因为this指针指向对象的首地址，而静态成员函数是先于对象存在的（就算没有对象也能访问静态成员函数），所以静态&#x2F;全局函数都没有this指针</li></ul><p>传入参数为当前对象地址，成员函数第一个参数为<code>T *const this</code>，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>对于func函数，在编译器看来应该是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(A *<span class="hljs-type">const</span> <span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由上可见，<code>this</code>在成员函数前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的<code>this</code>参数传递进去</p></li></ul><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// this指针的使用：</span><br><span class="hljs-comment">// 用法1：在类的非静态成员函数中返回类对象本身的时候，直接使用`return *this`</span><br><span class="hljs-comment">// 用法2：当形参与成员变量名相同时用于区分，如`this-&gt;n = n`（不能写成n = n，相当于形参给形参自己赋值）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge1</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// age = age; //此时，相当于形参给形参自己赋值，并没有给成员age赋值，对应用法2</span><br>        <span class="hljs-keyword">this</span>-&gt;age = age; <span class="hljs-comment">// 正确写法，给成员赋值</span><br>    &#125;<br><br>    <span class="hljs-function">Student <span class="hljs-title">setAge2</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-comment">// 在类的非静态成员函数中返回类对象本身的时候，直接使用`return *this`，对应用法1</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;age = age;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 静态函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">lazy</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;i want to sleep &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">// 报错：“this”只能用于非静态成员函数内部。原因：因为this指针指向对象的首地址，而静态成员函数是先于对象存在的，所以静态/全局函数都没有this指针</span><br>        <span class="hljs-comment">// cout &lt;&lt; this-&gt;age &lt;&lt; endl; </span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf_func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;this 指针指向的地址：&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;成员age的地址: &quot;</span> &lt;&lt; &amp;age &lt;&lt; endl; <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Student s;<br>    s = s.<span class="hljs-built_in">setAge2</span>(<span class="hljs-number">18</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br>    <span class="hljs-comment">// this指针指向的地址=第一个成员的地址=对象的首地址(如果再创建一个对象2，则对象2的this指针的指向的地址就是对象2的首地址)</span><br><span class="hljs-comment">// this 指针指向的地址：0x61fe0c</span><br>    <span class="hljs-comment">// 成员age的地址: 0x61fe0c </span><br>    s.<span class="hljs-built_in">printf_func</span>(); <br>    cout &lt;&lt; <span class="hljs-string">&quot;对象的地址：&quot;</span> &lt;&lt; &amp;s &lt;&lt; endl; <span class="hljs-comment">// 对象的地址：0x61fe0c</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="104-在成员函数中调用delete-this会出现什么问题"><a href="#104-在成员函数中调用delete-this会出现什么问题" class="headerlink" title="104 在成员函数中调用delete this会出现什么问题"></a>104 在成员函数中调用delete this会出现什么问题</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个<code>this</code>指针，让成员函数知道当前是哪个对象在调用它。当调用<code>delete this</code>时，类对象的内存空间被释放。在delete this之后进行的其它任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><p><strong>为什么会出现不可预期的问题，delete之后释放了类的内存空间了，那么这段内存应该已经还给系统，不再属于这个进程。按照这个逻辑，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？</strong></p><p>这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存并不是马上被回收到系统中，可能是缓冲或者其它什么原因，导致这段内存暂时并没有被系统回收，此时这段内存是可以访问的, 但是其中的值可能是不确定的。当获取数据成员，可能得到的是一串很长的未初始化的随机数, 访问虚函数表, 指针可能无效, 造成系统崩溃。</p><h1 id="105-在类的析构函数中调用delete-this会出现什么问题"><a href="#105-在类的析构函数中调用delete-this会出现什么问题" class="headerlink" title="105 在类的析构函数中调用delete this会出现什么问题"></a>105 在类的析构函数中调用delete this会出现什么问题</h1><p>会导致堆栈溢出。</p><p>delete的本质是“为即将释放的内存调用一个或多个析构函数”，然后释放内存，如果在析构函数中调用了delete this，那么this会调用本对象的析构函数，而析构函数中又调用delete this，造成无线递归，最终导致堆栈溢出，系统崩溃。</p><h1 id="106-this指针调用成员变量时，堆栈会发生什么变化"><a href="#106-this指针调用成员变量时，堆栈会发生什么变化" class="headerlink" title="106 this指针调用成员变量时，堆栈会发生什么变化"></a>106 this指针调用成员变量时，堆栈会发生什么变化</h1><p>this指针首先入栈，然后成员函数的参数从右到左进行入栈，最后函数返回地址入栈</p><h1 id="107-如果有一个空类，它会默认添加哪些函数、大小是多少"><a href="#107-如果有一个空类，它会默认添加哪些函数、大小是多少" class="headerlink" title="107 如果有一个空类，它会默认添加哪些函数、大小是多少"></a>107 如果有一个空类，它会默认添加哪些函数、大小是多少</h1><ul><li>默认构造函数：<code>Empty(); </code></li><li>拷贝构造函数：<code>Empty(const Empty&amp;);</code>：如果没有为一个类定义拷贝构造函数，那么编译器会自己定义一个。即使定义了其它构造函数，编译器也会定义一个拷贝构造函数</li><li>析构函数：<code>~Empty();</code></li><li>赋值运算符：<code>Empty&amp; operator=( const Empty&amp; );</code></li></ul><p><strong>空类的大小是多少？</strong></p><p>空类的大小是1。</p><p><strong>为什么是1？</strong></p><p>这时为了让对象的实例能够相互区别。C++标准指出，不允许一个对象（包括类对象）的大小为0，不同的对象不能具有相同的地址，空类同样可以被实例化，并且每个实例在内存中都独一无二的地址。因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的地址。当该空类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="108-类对象的大小受哪些因素影响"><a href="#108-类对象的大小受哪些因素影响" class="headerlink" title="108 类对象的大小受哪些因素影响"></a>108 类对象的大小受哪些因素影响</h1><ul><li><p>类的非静态成员变量。（静态成员不占据类的空间，成员函数也不占用类的空间）</p></li><li><p>内存对齐另外分配的空间大小。</p></li><li><p>有虚函数的话，会在类对象插入vptr指针，加上指针大小</p></li><li><p>当该类是某类的派生类，那么派生类继承的基本部分的数据成员也会存在于派生类的空间中。（如果基类是一个空类，派生类的大小就是派生类本身的大小）</p></li></ul><h1 id="109-为什么析构函数一般写成虚函数"><a href="#109-为什么析构函数一般写成虚函数" class="headerlink" title="109 为什么析构函数一般写成虚函数"></a>109 为什么析构函数一般写成虚函数</h1><p><strong>多态情况下，对象的析构顺序</strong>：由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p><p>如果基类的析构函数不被声明称虚函数，那么在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p><p><strong>为什么只会调用基类的析构函数而不调用派生类析构函数？</strong></p><p>在C++中，当调用非虚函数时，编译器会根据指针或引用的类型进行静态绑定（早期绑定），而不是动态绑定（晚期绑定）。这意味着如果基类的析构函数不是虚函数，即使通过基类指针指向派生类对象，调用的仍然是基类的析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Animal *animal = <span class="hljs-keyword">new</span> Cat;<br><span class="hljs-keyword">delete</span> animal; <span class="hljs-comment">// 通过基类指针删除派生类对象</span><br></code></pre></td></tr></table></figure><p><strong>析构函数可以是纯虚函数吗？</strong></p><p>可以。含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重写基类中的纯虚函数。</p><h1 id="110-构造函数可以是虚函数吗？"><a href="#110-构造函数可以是虚函数吗？" class="headerlink" title="110 构造函数可以是虚函数吗？"></a>110 构造函数可以是虚函数吗？</h1><p>不可以。虚函数对应一个vtabe(虚函数表)，类中存储一个虚表指针(vptr)指向这个vtable。如果构造函数是虚函数，就需要通过虚函数表调用，但是对象没有初始化就没有虚表指针，无法找到虚函数表，所以构造函数不能是虚函数。</p><h1 id="111-派生类重写基类的虚函数-非虚函数有什么区别"><a href="#111-派生类重写基类的虚函数-非虚函数有什么区别" class="headerlink" title="111 派生类重写基类的虚函数&#x2F;非虚函数有什么区别"></a>111 派生类重写基类的虚函数&#x2F;非虚函数有什么区别</h1><ul><li>重写非虚函数时，非虚函数的调用是基于指针或引用的静态类型来确定的，而不是动态类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base class\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 重写基类的 display 函数</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived class\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base *basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();  <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    basePtr-&gt;<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 如果display是虚函数的话，调用的是子类的display，否则调用的是基类的display函数</span><br><br>    <span class="hljs-keyword">delete</span> basePtr;  <span class="hljs-comment">// 注意：删除指向派生类对象的基类指针需要虚析构函数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="112-构造函数和析构函数能调用虚函数吗"><a href="#112-构造函数和析构函数能调用虚函数吗" class="headerlink" title="112 构造函数和析构函数能调用虚函数吗"></a>112 构造函数和析构函数能调用虚函数吗</h1><p><strong>不要在构造函数和析构函数中调用虚函数</strong></p><p>对于构造函数：</p><ul><li>基类的析构函数如果调用自己的虚函数，可以调用但不建议。此时在执行构造函数的过程中，对象还未初始化完成，对象对应的虚函数表尚未初始化，如果调用虚函数，虚函数机制并不会再按照预期工作。</li><li>同时，基类也无法调用到派生类的虚函数，因为此时派生类对象还未创建。</li></ul><p>对于析构函数：</p><ul><li>基类的析构函数调用派生类的虚函数：析构函数是用来销毁对象的，在销毁对象时，先调用派生类的析构函数，再调用基类的析构函数。在调用基类的析构函数时，子类对象已经被销毁，调用不了。</li><li>基类的析构函数调用自己的虚函数：可以，但没必要。虚函数是为了实现运行时多态，这样调用没意义。</li></ul><h1 id="113-类什么时候会析构"><a href="#113-类什么时候会析构" class="headerlink" title="113 类什么时候会析构"></a>113 类什么时候会析构</h1><ul><li>对象生命周期结束，被销毁时</li><li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时</li><li>对象a是对象b的成员，b的析构函数被调用时，对象a的析构函数也被调用</li></ul><h1 id="114-构造函数、拷贝构造函数和赋值运算符的区别"><a href="#114-构造函数、拷贝构造函数和赋值运算符的区别" class="headerlink" title="114 构造函数、拷贝构造函数和赋值运算符的区别"></a>114 构造函数、拷贝构造函数和赋值运算符的区别</h1><p><strong>构造函数</strong>：对象不存在，没用别的对象进行初始化，在创建一个新的对象时调用构造函数</p><p><strong>拷贝构造函数</strong>：对象不存在，使用别的已经存在的对象进行初始化</p><p><strong>赋值运算符</strong>：对象存在，用别的对象给它赋值，这属于重载<code>=</code>号运算符的范畴，<code>=</code>号两侧的运算对象都是存在的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>A&amp; <span class="hljs-keyword">operator</span> = (A&amp; a)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是赋值操作符&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">A</span>() &#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a1; <span class="hljs-comment">//调用构造函数</span><br>A a2 = a1; <span class="hljs-comment">//调用拷贝构造函数</span><br>a2 = a1; <span class="hljs-comment">//调用赋值操作符</span><br>    <span class="hljs-function">A <span class="hljs-title">a3</span><span class="hljs-params">(a1)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br>我是构造函数<br>我是拷贝构造函数<br>我是赋值操作符<br>我是拷贝构造函数<br><br></code></pre></td></tr></table></figure><h1 id="115-静态成员函数可以定义是虚函数吗？"><a href="#115-静态成员函数可以定义是虚函数吗？" class="headerlink" title="115 静态成员函数可以定义是虚函数吗？"></a>115 静态成员函数可以定义是虚函数吗？</h1><p>不可以。</p><p>静态成员函数不属于类对象，与非静态成员函数一个重要的区别就是静态成员函数没有this指针。</p><p>虚函数依靠vptr和vtable来处理，vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数表地址的vtable。对于静态成员函数，它没有this指针，所以无法访问vptr。</p><p>因此，静态函数不能是虚函数。虚函数的调用关系：this-&gt;vptr-&gt;vtable-&gt;virtual function</p><h1 id="116-构造函数、析构函数和虚函数能否为内联函数"><a href="#116-构造函数、析构函数和虚函数能否为内联函数" class="headerlink" title="116 构造函数、析构函数和虚函数能否为内联函数"></a>116 构造函数、析构函数和虚函数能否为内联函数</h1><p>在语法上没有错误，但编译器不一定真正的内联。</p><p>构造函数、析构函数声明为内联函数没有意义：编译器并不真正对声明为内联函数构造和析构函数进行内联操作，因为编译器会在构造函数和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等）。其次，calss中的函数默认是inline型的，编译器也只是有选择性的Inline，将构造函数和析构函数声明为内联函数没有意义。</p><p>对于虚函数：当是指向派生类的指针（多态性）调用声明为内联的虚函数时，不会内联展开（因为此时调用哪个虚函数是运行时知道的）。当是对象本身调用虚函数时，会内联展开，不过前提是函数不复杂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base class\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived class\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived obj;<br>    obj.<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 直接调用虚函数 display</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="117-虚函数的代价是什么"><a href="#117-虚函数的代价是什么" class="headerlink" title="117 虚函数的代价是什么"></a>117 虚函数的代价是什么</h1><p>会在每个实例化的对象中添加一个虚表指针，增加对象的大小。</p><h1 id="118-哪些函数不能是虚函数？"><a href="#118-哪些函数不能是虚函数？" class="headerlink" title="118 哪些函数不能是虚函数？"></a>118 哪些函数不能是虚函数？</h1><ul><li>构造函数：如果构造函数是虚函数，那么需要对象的虚表指针对构造函数进行调用，但构造函数就是用来构建对象的，此时还没有对象，也就无法调用构造函数，所以构造函数不能是虚函数</li><li>内联函数：内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定。当是指向派生类的指针（多态性）调用声明为内联的虚函数时，不会内联展开（因为此时调用哪个虚函数是运行时知道的）。当是对象本身调用虚函数时，会内联展开，不过前提是函数不复杂</li><li>静态函数：静态函数不属于类，静态成员函数没有this指针，无法调用虚表指针，所以静态函数不能是虚函数</li><li>友元函数：友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法</li></ul><h1 id="119-构造函数"><a href="#119-构造函数" class="headerlink" title="119 构造函数"></a>119 构造函数</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p><strong>定义</strong>：如果类中没有显式地定义一个构造函数，那么编译器就会隐式地定义一个默认构造函数（也叫合成的默认构造函数）。</p><p><strong>使用场景</strong>：当我们没有为类显式定义构造函数的时候。</p><p><strong>使用合成的默认构造函数初始化类的规则：</strong></p><ul><li>如果存在类内的初始值，用初始值来初始化成员</li><li>否则，默认初始化该成员</li></ul><blockquote><p>类内初始值：直接在类内定义的时候给变量一个初始值，而不需要在构造函数中进行初始化。如果对象被默认构造，这些值将生效。</p><p>默认构造函数有两种：合成的默认构造函数、我们自己定义的默认构造函数</p><p>默认构造函数没有形参</p></blockquote><p><strong>使用合成的默认构造函数的限制：</strong>某些类不能依赖于合成的默认构造函数，原因有三个：</p><ul><li>原因1：编译器只有在发现类不包含任何构造函数的情况下才会生成一个默认的构造函数。一旦我们定义了一些其它的构造函数，那么除非我们再定义一个默认的构造函数，否则<code>类将没有默认构造函数</code>。</li><li>原因2：对于某些类来说，合成的默认构造函数可能执行错误的操作。含有内置类型或复合类型（比如数组和指针）成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数，否则用户在创建类的对象时就可能得到未定义的值。</li></ul><blockquote><p>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合使用合成的默认构造函数</p></blockquote><ul><li>原因3：有时候编译器不能为某些类合成默认的构造函数。比如：如果类中包含一个其它类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员，并且会导致编译错误。（因为编译器在生成默认构造函数时需要调用所有成员的默认构造函数，如果其中一个成员的类型没有默认构造函数，编译器无法保证类的完整成员都能被正确初始化）</li></ul><p><strong>&#x3D; default</strong></p><p>default关键字可以显式要求编译器生成默认构造函数，目的：我们既需要其它形式的构造函数，也需要默认的构造函数。这个作用完全等同于合成默认构造函数。</p><blockquote><p>即使有其它构造函数，我们也应该提供一个默认构造函数</p></blockquote><h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>)&#123;&#125; <span class="hljs-comment">// 成员初始化列表</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p><strong>定义</strong>：如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p><blockquote><p>如果我们没有为一个类定义拷贝构造函数，编译器会自动定义一个。</p></blockquote><p><strong>声明</strong>：Foo(const Foo&amp;)</p><p><strong>为什么拷贝构造函数的第一个参数必须是一个引用类型？</strong></p><p>因为拷贝构造函数用来初始化非引用类型参数。如果拷贝构造函数的参数不是引用类型，则调用永远也不会成功：为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数，如此循环，最终导致内存耗尽。</p><p><strong>使用拷贝构造函数时各成员的初始化原则：</strong></p><ul><li>类类型成员：使用其拷贝构造函数来拷贝</li><li>内置类型的成员：直接拷贝  int a &#x3D; b;</li></ul><p><strong>原理：</strong>一般情况下，拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">拷贝赋值<br>total = trans;<br>等价于<br>total.bookNo = trans.bookNo;<br>total.revenue = trans.revenue;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>如果没有为一个类定义拷贝构造函数，那么编译器会自己定义一个。即使定义了其它构造函数，编译器也会定义一个拷贝构造函数</li></ul><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><h1 id="120-初始化"><a href="#120-初始化" class="headerlink" title="120 初始化"></a>120 初始化</h1><h2 id="类内初始值初始化"><a href="#类内初始值初始化" class="headerlink" title="类内初始值初始化"></a>类内初始值初始化</h2><p>在类内为成员变量指定初始值。这是 C++11 引入的一个特性，允许在类内为成员变量赋初值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">//类内初始值初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p><strong>默认初始化：</strong>如果定义变量时没有指定初值，也没有其它的构造函数进行初始化，则变量被默认初始化。</p><p><strong>默认初始化的规则：</strong>如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。</p><ul><li>定义于任何函数体之外的变量被初始化为0。</li><li>定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其它形式访问此类值将引发错误。（定义局部变量的时候要给它一个初始值）</li></ul><blockquote><p>当给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// b和c都是未定义的，有值可能是编译器优化</span><br>        <span class="hljs-type">int</span> b;<br>        string c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="成员初始化列表初始化"><a href="#成员初始化列表初始化" class="headerlink" title="成员初始化列表初始化"></a>成员初始化列表初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>)&#123;&#125; <span class="hljs-comment">// 成员初始化列表</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面这种写法是赋值操作，并非初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b)<br>    &#123;<br>        a = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面这两种写法：第一个版本是初始化了它的数据成员，第二个版本是对数据成员执行了先初始化再赋值操作。这两种写法的差异有时可以忽略，但如果成员是<code>const</code>或引用的话，必须将其初始化，而不是赋值的写法（因为<code>const</code>不能修改值，引用定义的时候也必须初始化）。另外，如果成员属于某种类类型，且该类没有定义默认构造函数时，也必须将这个成员初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b):<span class="hljs-built_in">a</span>(b), <span class="hljs-built_in">ci</span>(b), <span class="hljs-built_in">ri</span>(a) <span class="hljs-comment">// 显示地初始化引用和const成员</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>        cout &lt;&lt; ri &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci;<br>    <span class="hljs-type">int</span> &amp;ri;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>随着构造函数体一开始执行，初始化就完成了，函数体内是赋值操作</p></blockquote><p><strong>成员初始化顺序：</strong>成员的初始化顺序于它们在类定义中的出现顺序一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> b): <span class="hljs-built_in">ci</span>(a), <span class="hljs-built_in">a</span>(b)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ci: &quot;</span> &lt;&lt; ci &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ci;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    b.<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：ci在类中先出现，用a来初始化，但初始化ci的时候a是未定义的值，此时值为0，所以ci就被初始化为0，如果把ci和a定义的顺序调换一下，就都是2了。</span><br>ci: <span class="hljs-number">0</span><br>a: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h2><p>使用圆括号进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h2><p>使用等号进行初始化。当将一个对象赋值给另一个对象或使用等号进行初始化时，会发生拷贝初始化。理解：等号右侧应该是个左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s5 = <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 直接初始化（在函数中）、拷贝初始化（在函数中）、类内初始值初始化（在类中）</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">data</span>(x) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass &amp;other) : <span class="hljs-built_in">data</span>(other.data) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 直接初始化</span><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 拷贝初始化</span><br>    MyClass obj2 = obj1;<br><br>    <span class="hljs-comment">// 类内初始值初始化</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>            std::cout &lt;&lt; a &lt;&lt; std::endl;<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 类内初始值初始化</span><br>    &#125;;<br><br>    Base obj3;<br>    obj3.<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>什么情况下会发生拷贝初始化</strong></p><ul><li>用等号<code>=</code>定义变量，用类的一个实例化对象去初始化另外一个对象的时候</li><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象，返回值会被用来初始化调用方的结果</li><li>用花括号列表初始化一个数组中的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;&#125;;  <span class="hljs-comment">// 默认构造函数</span><br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)  <span class="hljs-comment">// 拷贝构造函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;copy constructor is called&quot;</span> &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">A</span>() &#123;&#125;;  <span class="hljs-comment">// 析构函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useClassA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a1;<br>A a2 = a1;  <span class="hljs-comment">//调用拷贝构造函数,对应情况1</span><br><span class="hljs-built_in">useClassA</span>(a1);<span class="hljs-comment">//调用拷贝构造函数，对应情况2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的 </p></blockquote><p>非静态成员</p><p>虚函数，加上虚表指针</p><p>内存对齐的影响</p><p>派生类，加上基类的成员</p><p>默认为1，如果有</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题</title>
    <link href="/2024/03/01/%E5%88%B7%E9%A2%98/"/>
    <url>/2024/03/01/%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer目录"><a href="#剑指Offer目录" class="headerlink" title="剑指Offer目录"></a>剑指Offer目录</h1><h2 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h2><ul><li>[3. 数组中重复的数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/3">https://github.com/CyC2018/CS-Notes/blob/master/notes/3</a>. 数组中重复的数字.md)</li><li>[4. 二维数组中的查找](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/4">https://github.com/CyC2018/CS-Notes/blob/master/notes/4</a>. 二维数组中的查找.md)</li><li>[5. 替换空格](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/5">https://github.com/CyC2018/CS-Notes/blob/master/notes/5</a>. 替换空格.md)</li><li>[29. 顺时针打印矩阵](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/29">https://github.com/CyC2018/CS-Notes/blob/master/notes/29</a>. 顺时针打印矩阵.md)</li><li>[50. 第一个只出现一次的字符位置](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/50">https://github.com/CyC2018/CS-Notes/blob/master/notes/50</a>. 第一个只出现一次的字符位置.md)</li></ul><h2 id="栈队列堆"><a href="#栈队列堆" class="headerlink" title="栈队列堆"></a>栈队列堆</h2><ul><li>[9. 用两个栈实现队列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/9">https://github.com/CyC2018/CS-Notes/blob/master/notes/9</a>. 用两个栈实现队列.md)</li><li>[30. 包含 min 函数的栈](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/30">https://github.com/CyC2018/CS-Notes/blob/master/notes/30</a>. 包含 min 函数的栈.md)</li><li>[31. 栈的压入、弹出序列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/31">https://github.com/CyC2018/CS-Notes/blob/master/notes/31</a>. 栈的压入、弹出序列.md)</li><li>[40. 最小的 K 个数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/40">https://github.com/CyC2018/CS-Notes/blob/master/notes/40</a>. 最小的 K 个数.md)</li><li>[41.1 数据流中的中位数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/41.1">https://github.com/CyC2018/CS-Notes/blob/master/notes/41.1</a> 数据流中的中位数.md)</li><li>[41.2 字符流中第一个不重复的字符](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/41.2">https://github.com/CyC2018/CS-Notes/blob/master/notes/41.2</a> 字符流中第一个不重复的字符.md)</li><li>[59. 滑动窗口的最大值](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/59">https://github.com/CyC2018/CS-Notes/blob/master/notes/59</a>. 滑动窗口的最大值.md)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>[57.1 和为 S 的两个数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/57.1">https://github.com/CyC2018/CS-Notes/blob/master/notes/57.1</a> 和为 S 的两个数字.md)</li><li>[57.2 和为 S 的连续正数序列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/57.2">https://github.com/CyC2018/CS-Notes/blob/master/notes/57.2</a> 和为 S 的连续正数序列.md)</li><li>[58.1 翻转单词顺序列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.1">https://github.com/CyC2018/CS-Notes/blob/master/notes/58.1</a> 翻转单词顺序列.md)</li><li>[58.2 左旋转字符串](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.2">https://github.com/CyC2018/CS-Notes/blob/master/notes/58.2</a> 左旋转字符串.md)</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id=""><a href="#" class="headerlink" title="- "></a>- </h2><h2 id="-1"><a href="#-1" class="headerlink" title="- "></a>- </h2><h2 id="-2"><a href="#-2" class="headerlink" title="- "></a>- </h2><h2 id="35-复杂链表的复制-https-github-com-CyC2018-CS-Notes-blob-master-notes-35-复杂链表的复制-md"><a href="#35-复杂链表的复制-https-github-com-CyC2018-CS-Notes-blob-master-notes-35-复杂链表的复制-md" class="headerlink" title="-- [35. 复杂链表的复制](https://github.com/CyC2018/CS-Notes/blob/master/notes/35. 复杂链表的复制.md)"></a>-<br>- [35. 复杂链表的复制](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/35">https://github.com/CyC2018/CS-Notes/blob/master/notes/35</a>. 复杂链表的复制.md)</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="-3"><a href="#-3" class="headerlink" title="- "></a>- </h2><h2 id="-4"><a href="#-4" class="headerlink" title="- "></a>- </h2><h2 id="-5"><a href="#-5" class="headerlink" title="- "></a>- </h2><ul><li>[32.2 把二叉树打印成多行](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/32.2">https://github.com/CyC2018/CS-Notes/blob/master/notes/32.2</a> 把二叉树打印成多行.md)</li><li>[32.3 按之字形顺序打印二叉树](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/32.3">https://github.com/CyC2018/CS-Notes/blob/master/notes/32.3</a> 按之字形顺序打印二叉树.md)</li><li></li><li></li><li>[36. 二叉搜索树与双向链表](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/36">https://github.com/CyC2018/CS-Notes/blob/master/notes/36</a>. 二叉搜索树与双向链表.md)</li><li>[37. 序列化二叉树](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/37">https://github.com/CyC2018/CS-Notes/blob/master/notes/37</a>. 序列化二叉树.md)</li><li></li><li></li><li></li><li></li></ul><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><ul><li>[14. 剪绳子](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/14">https://github.com/CyC2018/CS-Notes/blob/master/notes/14</a>. 剪绳子.md)</li><li>[63. 股票的最大利润](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/63">https://github.com/CyC2018/CS-Notes/blob/master/notes/63</a>. 股票的最大利润.md)</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>[11. 旋转数组的最小数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/11">https://github.com/CyC2018/CS-Notes/blob/master/notes/11</a>. 旋转数组的最小数字.md)</li><li>[53. 数字在排序数组中出现的次数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/53">https://github.com/CyC2018/CS-Notes/blob/master/notes/53</a>. 数字在排序数组中出现的次数.md)</li></ul><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><ul><li>[16. 数值的整数次方](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/16">https://github.com/CyC2018/CS-Notes/blob/master/notes/16</a>. 数值的整数次方.md)</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li>[12. 矩阵中的路径](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/12">https://github.com/CyC2018/CS-Notes/blob/master/notes/12</a>. 矩阵中的路径.md)</li><li>[13. 机器人的运动范围](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/13">https://github.com/CyC2018/CS-Notes/blob/master/notes/13</a>. 机器人的运动范围.md)</li><li>[38. 字符串的排列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/38">https://github.com/CyC2018/CS-Notes/blob/master/notes/38</a>. 字符串的排列.md)</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>[21. 调整数组顺序使奇数位于偶数前面](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/21">https://github.com/CyC2018/CS-Notes/blob/master/notes/21</a>. 调整数组顺序使奇数位于偶数前面.md)</li><li>[45. 把数组排成最小的数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/45">https://github.com/CyC2018/CS-Notes/blob/master/notes/45</a>. 把数组排成最小的数.md)</li><li>[51. 数组中的逆序对](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/51">https://github.com/CyC2018/CS-Notes/blob/master/notes/51</a>. 数组中的逆序对.md)</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li>[10.1 斐波那契数列](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.1">https://github.com/CyC2018/CS-Notes/blob/master/notes/10.1</a> 斐波那契数列.md)</li><li>[10.2 矩形覆盖](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.2">https://github.com/CyC2018/CS-Notes/blob/master/notes/10.2</a> 矩形覆盖.md)</li><li>[10.3 跳台阶](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.3">https://github.com/CyC2018/CS-Notes/blob/master/notes/10.3</a> 跳台阶.md)</li><li>[10.4 变态跳台阶](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.4">https://github.com/CyC2018/CS-Notes/blob/master/notes/10.4</a> 变态跳台阶.md)</li><li>[42. 连续子数组的最大和](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/42">https://github.com/CyC2018/CS-Notes/blob/master/notes/42</a>. 连续子数组的最大和.md)</li><li>[47. 礼物的最大价值](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/47">https://github.com/CyC2018/CS-Notes/blob/master/notes/47</a>. 礼物的最大价值.md)</li><li>[48. 最长不含重复字符的子字符串](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/48">https://github.com/CyC2018/CS-Notes/blob/master/notes/48</a>. 最长不含重复字符的子字符串.md)</li><li>[49. 丑数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/49">https://github.com/CyC2018/CS-Notes/blob/master/notes/49</a>. 丑数.md)</li><li>[60. n 个骰子的点数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/60">https://github.com/CyC2018/CS-Notes/blob/master/notes/60</a>. n 个骰子的点数.md)</li><li>[66. 构建乘积数组](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/66">https://github.com/CyC2018/CS-Notes/blob/master/notes/66</a>. 构建乘积数组.md)</li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li>[39. 数组中出现次数超过一半的数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/39">https://github.com/CyC2018/CS-Notes/blob/master/notes/39</a>. 数组中出现次数超过一半的数字.md)</li><li>[62. 圆圈中最后剩下的数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/62">https://github.com/CyC2018/CS-Notes/blob/master/notes/62</a>. 圆圈中最后剩下的数.md)</li><li>[43. 从 1 到 n 整数中 1 出现的次数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/43">https://github.com/CyC2018/CS-Notes/blob/master/notes/43</a>. 从 1 到 n 整数中 1 出现的次数.md)</li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li>[15. 二进制中 1 的个数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/15">https://github.com/CyC2018/CS-Notes/blob/master/notes/15</a>. 二进制中 1 的个数.md)</li><li>[56. 数组中只出现一次的数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/56">https://github.com/CyC2018/CS-Notes/blob/master/notes/56</a>. 数组中只出现一次的数字.md)</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>[17. 打印从 1 到最大的 n 位数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/17">https://github.com/CyC2018/CS-Notes/blob/master/notes/17</a>. 打印从 1 到最大的 n 位数.md)</li><li>[19. 正则表达式匹配](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/19">https://github.com/CyC2018/CS-Notes/blob/master/notes/19</a>. 正则表达式匹配.md)</li><li>[20. 表示数值的字符串](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/20">https://github.com/CyC2018/CS-Notes/blob/master/notes/20</a>. 表示数值的字符串.md)</li><li>[44. 数字序列中的某一位数字](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/44">https://github.com/CyC2018/CS-Notes/blob/master/notes/44</a>. 数字序列中的某一位数字.md)</li><li>[46. 把数字翻译成字符串](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/46">https://github.com/CyC2018/CS-Notes/blob/master/notes/46</a>. 把数字翻译成字符串.md)</li><li>[61. 扑克牌顺子](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/61">https://github.com/CyC2018/CS-Notes/blob/master/notes/61</a>. 扑克牌顺子.md)</li><li>[64. 求 1+2+3+…+n](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/64">https://github.com/CyC2018/CS-Notes/blob/master/notes/64</a>. 求 1+2+3+…+n.md)</li><li>[65. 不用加减乘除做加法](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/65">https://github.com/CyC2018/CS-Notes/blob/master/notes/65</a>. 不用加减乘除做加法.md)</li><li>[67. 把字符串转换成整数](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/67">https://github.com/CyC2018/CS-Notes/blob/master/notes/67</a>. 把字符串转换成整数.md)</li></ul><h1 id="0-剑指Offer列表"><a href="#0-剑指Offer列表" class="headerlink" title="0 剑指Offer列表"></a>0 剑指Offer列表</h1><table><thead><tr><th>题目</th><th>是否完成</th><th>类型</th><th>方法（可能还有更优解）</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=">25.合并两个排序的链表</a></td><td>完成</td><td>链表</td><td>双指针，dummy节点</td><td>轻网科技一面</td></tr><tr><td><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=">24.反转链表</a></td><td>完成</td><td>链表</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=23278&ru=/practice/d0267f7f55b3412ba93bd35cfa8e8035&qru=/ta/coding-interviews/question-ranking&sourceUrl=">6. 从尾到头打印链表</a></td><td>完成</td><td>链表</td><td>递归&#x2F;栈</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=23257&ru=/practice/d0267f7f55b3412ba93bd35cfa8e8035&qru=/ta/coding-interviews/question-ranking&sourceUrl=">52. 两个链表的第一个公共结点</a></td><td>完成</td><td>链表</td><td>双指针</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=23449&ru=/practice/6ab1d9a29e88450685099d45c9e31e46&qru=/ta/coding-interviews/question-ranking&sourceUrl=">23. 链表中环的入口结点</a></td><td>完成</td><td>链表</td><td>双指针</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tqId=1377477&ru=/practice/253d2c59ec3e4bc68da16833f79a38e4&qru=/ta/coding-interviews/question-ranking&sourceUrl=">22. 链表中倒数第 K 个结点</a></td><td>完成</td><td>链表</td><td>双指针</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=13&tqId=2273171&ru=/practice/886370fe658f41b498d40fb34ae76ff9&qru=/ta/coding-interviews/question-ranking&sourceUrl=">18.1. 删除链表的节点</a></td><td>完成</td><td>链表</td><td>双指针，dummy节点</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=23450&ru=/practice/f9f78ca89ad643c99701a7142bd59f5d&qru=/ta/coding-interviews/question-ranking&sourceUrl=">18.2 删除链表中重复的结点</a></td><td>完成</td><td>链表</td><td>dummy节点</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=23254&ru=/practice/fc533c45b73a41b0b44ccba763f866ef&qru=/ta/coding-interviews/question-ranking&sourceUrl=">35. 复杂链表的复制</a></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=23294&ru=/practice/f836b2c43afc4b35ad6adc41ec941dba&qru=/ta/coding-interviews/question-ranking&sourceUrl=">55.1 二叉树的深度</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tqId=1374963&ru=/practice/a861533d45854474ac791d90e447bafd&qru=/ta/coding-interviews/question-ranking&sourceUrl=">27. 二叉树的镜像</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=23250&ru=/practice/7fe2212963db4790b57431d9ed259701&qru=/ta/coding-interviews/question-ranking&sourceUrl=">55.2 平衡二叉树</a></td><td>完成</td><td>树</td><td>递归+最大深度</td><td></td></tr><tr><td><a href="%5B%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%5D(https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)">28. 对称的二叉树</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=23280&ru=/practice/6e196c44c7004d15b1610b9afca8bd88&qru=/ta/coding-interviews/question-ranking&sourceUrl=">32.1 从上往下打印二叉树</a></td><td>完成</td><td>树</td><td>层序遍历</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=23282&ru=/practice/7fe2212963db4790b57431d9ed259701&qru=/ta/coding-interviews/question-ranking&sourceUrl=">7 重建二叉树</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=13&tqId=1024325&ru=/practice/d9820119321945f588ed6a26f0a6991f&qru=/ta/coding-interviews/question-ranking&sourceUrl=">86 在二叉树中找到两个节点的最近公共祖先</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=13&tqId=2290592&ru=/practice/e0cc33a83afe4530bcec46eba3325116&qru=/ta/coding-interviews/question-ranking&sourceUrl=">68 二叉搜索树的最近公共祖先</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=23289&ru=/practice/a861533d45854474ac791d90e447bafd&qru=/ta/coding-interviews/question-ranking&sourceUrl=">33 二叉搜索树的后序遍历序列</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&tqId=2305268&ru=/practice/e0cc33a83afe4530bcec46eba3325116&qru=/ta/coding-interviews/question-ranking&sourceUrl=">54. 二叉查找树的第 K 个结点</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=23293&ru=/practice/57aa0bab91884a10b5136ca2c087f8ff&qru=/ta/coding-interviews/question-ranking&sourceUrl=">26. 树的子结构</a></td><td>完成</td><td>树</td><td>递归</td><td></td></tr><tr><td><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451&ru=/practice/f836b2c43afc4b35ad6adc41ec941dba&qru=/ta/coding-interviews/question-ranking&sourceUrl=">8. 二叉树的下一个结点</a></td><td>完成</td><td>树</td><td>递归&#x2F;next指针</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-ii/description/">34. 二叉树中和为某一值的路径</a></td><td>完成</td><td>树</td><td>递归、恢复现场</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>[4. 二维数组中的查找](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/4">https://github.com/CyC2018/CS-Notes/blob/master/notes/4</a>. 二维数组中的查找.md)</td><td></td><td></td><td></td><td>轻网科技一面</td></tr></tbody></table><h1 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h1><h2 id="剑指Offer25-合并两个排序的链表"><a href="#剑指Offer25-合并两个排序的链表" class="headerlink" title="剑指Offer25. 合并两个排序的链表"></a><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=">剑指Offer25. 合并两个排序的链表</a></h2><p><strong>思路：</strong></p><ul><li>根据两条链表创建两个指针，分别指向各自的头节点，同时定义一个头指针，用于表示合并之后的链表；</li><li>比较两条链表当前节点的值，将定义的节点指向节点值较小的链表。</li><li>更新头指针</li></ul><p><strong>用到的技巧：</strong></p><ul><li>虚拟头节点：dummy，当需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), *p = dummy;<br>        ListNode *p1 = list1, *p2 = list2;<br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)<br>            &#123;<br>                p-&gt;next = p2;<br>                p2 = p2-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                p-&gt;next = p1;<br>                p1 = p1-&gt;next;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p1 == <span class="hljs-literal">nullptr</span>) p-&gt;next = p2;<br>        <span class="hljs-keyword">if</span>(p2 == <span class="hljs-literal">nullptr</span>) p-&gt;next = p1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer24-反转链表"><a href="#剑指Offer24-反转链表" class="headerlink" title="剑指Offer24. 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=">剑指Offer24. 反转链表</a></h2><p>解法1：递归解法</p><ul><li>递归的含义：输入一个头节点head，将以head为起点的链表反转，并返回反转之后的头节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        ListNode* last = <span class="hljs-built_in">ReverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法2：迭代解法</p><ul><li>按节点分别反转，比较容易理解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>延伸问题</strong></p><p><strong>1 反转链表的前n个节点</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240303154214803.png" alt="image-20240303154214803"></p><p>递归解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>ListNode* successor = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        successor = head-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* last = <span class="hljs-built_in">reverseN</span>(head-&gt;next, n - <span class="hljs-number">1</span>);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = successor;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2 反转链表的一部分</strong></p><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode* successor = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 反转以left和right区间内的链表，并返回反转之后的头节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// left == 1, 相当于反转以头节点开头的前right个节点</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseN</span>(head, right);<br>        head-&gt;next = <span class="hljs-built_in">reverseBetween</span>(head-&gt;next, left - <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br><span class="hljs-comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            successor = head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* last = <span class="hljs-built_in">reverseN</span>(head-&gt;next, n - <span class="hljs-number">1</span>);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = successor;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer6-从尾到头打印链表"><a href="#剑指Offer6-从尾到头打印链表" class="headerlink" title="剑指Offer6. 从尾到头打印链表"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=23278&ru=/practice/d0267f7f55b3412ba93bd35cfa8e8035&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer6. 从尾到头打印链表</a></h2><p>刚看到这个题时的解题思路是结合前面的反转链表，将链表反转，然后使用一个vector接收反转后链表的值，虽然能通过，但是忽略了重要的一点：这种解法会改变原来的链表结构，题目应该是想要一种既能够从尾到头打印链表，又不改变原来链表结构的方法。</p><p><strong>解法1：反转链表解法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        ListNode* last = <span class="hljs-built_in">reverse</span>(head);<br>        <span class="hljs-keyword">while</span>(last != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(last-&gt;val);<br>            last = last-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* last = <span class="hljs-built_in">reverse</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>解法2：</strong>使用栈</p><p>遍历链表是从头到尾，而打印链表是从尾到头，也就是第一个遍历的最后一个打印，最后一个遍历的第一个打印，那么就可以使用栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;ListNode*&gt; nodes;<br>        <span class="hljs-comment">//向栈里存元素</span><br>        ListNode* tmp = head;<br>        <span class="hljs-keyword">while</span>(tmp != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            nodes.<span class="hljs-built_in">push</span>(tmp);<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-built_in">empty</span>()) <br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(nodes.<span class="hljs-built_in">top</span>()-&gt;val);  <span class="hljs-comment">// 注意栈的top()方法</span><br>            nodes.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>解法3</strong>：使用递归</p><p>递归的本质就是栈结构，如果能用栈结构解决，那么递归也能够解决。</p><p>但是递归方法不容易理解，看一遍题解才能写出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">func</span>(head, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span> <span class="hljs-comment">// 需要加上&amp;, 不加 &amp; 就是值传递，实参会赋不上值</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">func</span>(head-&gt;next, res);<br>            res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="剑指Offer52-两个链表的第一个公共结点"><a href="#剑指Offer52-两个链表的第一个公共结点" class="headerlink" title="剑指Offer52. 两个链表的第一个公共结点"></a><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=23257&ru=/practice/d0267f7f55b3412ba93bd35cfa8e8035&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer52. 两个链表的第一个公共结点</a></h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240303215832089.png" alt="image-20240303215832089"></p><p>思路较简单：</p><ul><li>定义两个指针*p1, *p2，分别指向两条链表的头节点p1指向head1, p2指向head2；</li><li>如果两个指针不相交，就一直往下走；</li><li>如果走到最后还不相交，那么让两个指针分别指向对方的头节点，即p1指向head2，p2指向head1；</li><li>如果两条链表有公共节点的话，第二遍就会相交，如果第二遍不相交，说明两条链表没有公共节点，那么两条链表就会都指向null</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span><br><span class="hljs-function"></span>&#123;<br>        ListNode* p1 = pHead1;<br>        ListNode* p2 = pHead2;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(p1 != p2)<br>&#123;<br>p1 = p1 == <span class="hljs-literal">nullptr</span> ? pHead2 : p1-&gt;next;<br>p2 = p2 == <span class="hljs-literal">nullptr</span> ? pHead1 : p2-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="剑指Offer23-链表中环的入口结点"><a href="#剑指Offer23-链表中环的入口结点" class="headerlink" title="剑指Offer23. 链表中环的入口结点"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=23449&ru=/practice/6ab1d9a29e88450685099d45c9e31e46&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer23. 链表中环的入口结点</a></h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240304093628261.png" alt="image-20240304093628261"></p><p>解法1：使用容器，思路简单，也很好实现</p><ul><li>使用容器，保存的值唯一，依次遍历链表，如果容器中有当前节点，那么链表就是有环的，当前节点就是环的入口</li><li>如果遍历链表后走到了Null，说明链表没有环，返回Null</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//使用set保证节点唯一</span><br>        set&lt;ListNode*&gt; mySet;<br>        <br>        ListNode* p = pHead;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) <br>        &#123;<br>            <span class="hljs-comment">//set中已经有当前元素，则返回</span><br>            <span class="hljs-keyword">if</span>(mySet.<span class="hljs-built_in">find</span>(p) != mySet.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>            <span class="hljs-comment">// set中没有当前元素，就将元素放到set里</span><br>            mySet.<span class="hljs-built_in">insert</span>(p);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// p走到了空节点，说明没有环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法2：快慢指针（<strong>快慢指针是链表中常用的技巧</strong>）：本题直接记流程，先不用管证明</p><ul><li>确定是否有环：快指针F一次走两个，慢指针S一次走一个节点，如果有环，它们一定会在环上相遇。如果快指针走到了null，说明没有环</li><li>如果有环：快指针回到起点，慢指针不动，它们同时走，并且都是一次走一个节点，那么一定会在环的入口相遇</li></ul><p>明白这个思路后，首先写出了下面这版代码：虽然能通过，但是感觉流程控制有点冗余不清晰，并且在24行的if里套了一个while，看起来有点奇怪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span> || pHead-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* fast = pHead-&gt;next-&gt;next;<br>        ListNode* slow = pHead-&gt;next;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) <br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast == slow)<br>        &#123;<br>            fast = pHead;<br>            <span class="hljs-keyword">while</span>(fast != slow)<br>            &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>改了一版之后：好多了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span> || pHead-&gt;next == <span class="hljs-literal">nullptr</span> || pHead-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* fast = pHead-&gt;next-&gt;next;<br>        ListNode* slow = pHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast != slow)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        fast = pHead;<br>        <span class="hljs-keyword">while</span>(fast != slow)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer22-链表中倒数第-K-个结点"><a href="#剑指Offer22-链表中倒数第-K-个结点" class="headerlink" title="剑指Offer22. 链表中倒数第 K 个结点"></a><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tqId=1377477&ru=/practice/253d2c59ec3e4bc68da16833f79a38e4&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer22. 链表中倒数第 K 个结点</a></h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240304110202229.png" alt="image-20240304110202229"></p><p>首先想到的思路是使用快慢指针，间隔为始终为k，当快指针走到尾部（空节点）时，返回慢指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = pHead;<br>        ListNode* fast = pHead;<br>        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                fast = fast-&gt;next;<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer18-1-删除链表的节点"><a href="#剑指Offer18-1-删除链表的节点" class="headerlink" title="剑指Offer18.1. 删除链表的节点"></a><a href="https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=13&tqId=2273171&ru=/practice/886370fe658f41b498d40fb34ae76ff9&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer18.1. 删除链表的节点</a></h2><p> 想到的思路是使用双指针，fast和slow，两个同时往前走，如果fast遇到了需要删除的节点，那么让slow&#x3D;fast-&gt;next，但是写的时候发现写不通（有可能是水平不够），如果定义了双指针，那么最终的返回值确定不了了，没有想到一个合适的办法能够返回整条删除节点之后的链表。于是转变思路，用虚拟头节点再创建一条链表，但这种方法不是在原链表删除的，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param val int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p = dummy;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;val != val)<br>        &#123;<br>            p-&gt;next = fast;<br>            p = p-&gt;next;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        p-&gt;next = fast-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果要在原链表上删除，思路如下：</p><ul><li><p>找到要删除的节点<code>i</code>及其下一节点<code>j</code></p></li><li><p>将<code>j</code>的值复制到<code>i</code>上，然后将<code>i</code>指向<code>j</code>的下一节点</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param val int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p-&gt;val != val)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>            p = p-&gt;next;<br>        &#125;<br><br>        p-&gt;val = p-&gt;next-&gt;val;<br>        p-&gt;next = p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer18-2-删除链表中重复的结点"><a href="#剑指Offer18-2-删除链表中重复的结点" class="headerlink" title="剑指Offer18.2 删除链表中重复的结点"></a><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=23450&ru=/practice/f9f78ca89ad643c99701a7142bd59f5d&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer18.2 删除链表中重复的结点</a></h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240305123000685.png" alt="image-20240305123000685"></p><ul><li>题目要求不保留重复的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 虚拟节点，用于删除头元素</span><br>        res-&gt;next = pHead;<br>        ListNode* cur = res;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)<br>            &#123;<br>                <span class="hljs-type">int</span> tmp = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;val == tmp) <span class="hljs-comment">// 把重复元素都跳过</span><br>                &#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>延伸题目</strong></p><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240305123037198.png" alt="image-20240305123037198"></p><ul><li>题目要求保留重复的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        res-&gt;next = head;<br>        ListNode* cur = res;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)<br>            &#123;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表补充题目"><a href="#链表补充题目" class="headerlink" title="链表补充题目"></a>链表补充题目</h2><h3 id="1-判断回文链表"><a href="#1-判断回文链表" class="headerlink" title="1 判断回文链表"></a><a href="https://leetcode.cn/problems/aMhZSa/description/">1 判断回文链表</a></h3><p>思路：</p><ul><li>使用栈存放链表元素</li><li>然后比较栈顶元素和链表元素的值是否一样</li><li>如果有不一样的节点值，说明不是回文，如果链表走到了Null节点或者栈为空，说明是回文</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;ListNode*&gt; myStack;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            myStack.<span class="hljs-built_in">push</span>(p);<br>            p = p-&gt;next;<br>        &#125;<br>        p = head;<br>        <span class="hljs-keyword">while</span>(!myStack.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(p-&gt;val != myStack.<span class="hljs-built_in">top</span>()-&gt;val)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            myStack.<span class="hljs-built_in">pop</span>();<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另外一个思路：本题使用递归比较啰嗦，就当练习递归思想和vector用法了。</p><ul><li>使用递归把元素放到vector里，递归函数调用结束后，vector存放的就是从尾到头的元素</li><li>比较链表和vector首元素的值是否相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        ListNode* p = head;<br>        <span class="hljs-built_in">reverse</span>(p, res);<br>        p=head;<br>        <span class="hljs-keyword">while</span>(!res.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;val != res.<span class="hljs-built_in">front</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p-&gt;next;<br>            res.<span class="hljs-built_in">erase</span>(res.<span class="hljs-built_in">begin</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">reverse</span>(head-&gt;next,res);<br>        res.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-K个一组反转链表"><a href="#2-K个一组反转链表" class="headerlink" title="2 K个一组反转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">2 K个一组反转链表</a></h3><h1 id="2-树"><a href="#2-树" class="headerlink" title="2 树"></a>2 树</h1><h2 id="剑指Offer-55-1-二叉树的深度"><a href="#剑指Offer-55-1-二叉树的深度" class="headerlink" title="剑指Offer 55.1 二叉树的深度"></a><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=23294&ru=/practice/f836b2c43afc4b35ad6adc41ec941dba&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 55.1 二叉树的深度</a></h2><p>简单递归问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 函数含义：给定一个节点，求出以这个节点为根节点的二叉树的最大深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left), <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="剑指Offer-27-二叉树的镜像"><a href="#剑指Offer-27-二叉树的镜像" class="headerlink" title="剑指Offer 27. 二叉树的镜像"></a><a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tqId=1374963&ru=/practice/a861533d45854474ac791d90e447bafd&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 27. 二叉树的镜像</a></h2><p>题意：</p><p>源二叉树：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240306204142164.png" alt="image-20240306204142164"></p><p>镜像后的二叉树</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240306204157445.png" alt="image-20240306204157445"></p><p>思路：递归，前序或者后序</p><ul><li>明确递归函数的定义，然后应用于左右子树</li><li>在根节点完成镜像</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 递归含义：给定一个节点，返回以这个节点为根节点的二叉树的镜像</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 镜像自己</span><br>        TreeNode* tmp = pRoot-&gt;left;;<br>        pRoot-&gt;left = pRoot-&gt;right;<br>        pRoot-&gt;right = tmp;<br>        <br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);  <span class="hljs-comment">// 返回以左子树节点为根节点的二叉树的镜像</span><br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right); <span class="hljs-comment">// 返回以右子树节点为根节点的二叉树的镜像</span><br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-55-2-平衡二叉树"><a href="#剑指Offer-55-2-平衡二叉树" class="headerlink" title="剑指Offer 55.2 平衡二叉树"></a><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=23250&ru=/practice/7fe2212963db4790b57431d9ed259701&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 55.2 平衡二叉树</a></h2><p>平衡二叉树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240306212949672.png" alt="image-20240306212949672"></p><p>思路：想到的思路分别判断左右子树是否是平衡二叉树（递归），在判断自己是否是平衡二叉树，那么需要求二叉树的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 递归含义：输入一个节点，返回以这个节点为根节点的树是否是平衡二叉树</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> a = <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;left); <span class="hljs-comment">// 左子树是否是平衡二叉树</span><br>        <span class="hljs-type">bool</span> b = <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;right); <span class="hljs-comment">// 右子树是否是平衡二叉树</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">maxDepth</span>(pRoot-&gt;left) - <span class="hljs-built_in">maxDepth</span>(pRoot-&gt;right)) &lt;= <span class="hljs-number">1</span>) &amp;&amp; a &amp;&amp; b ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 先求二叉树的最大深度</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(pRoot-&gt;left), <span class="hljs-built_in">maxDepth</span>(pRoot-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer28-对称的二叉树"><a href="#剑指Offer28-对称的二叉树" class="headerlink" title="剑指Offer28. 对称的二叉树"></a><a href="%5B%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%5D(https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)">剑指Offer28. 对称的二叉树</a></h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240307101742880.png" alt="image-20240307101742880"></p><p>思路：</p><p>首先尝试了一下前中后序遍历的结果，发现中序遍历<code>8 7 9 6 9 7 8</code>是一个回文数</p><p>所以一个简单的解法就是把树按照中序遍历一下，放到一个容器中，判断这个容器里的数字是不是回文的就可以了</p><p>但是写完之后发现这个方法不可行，如果节点的值一样，并且有null的话，就不好判断了</p><p><strong>192 &#x2F; 195 个通过的测试用例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkSymmetricTree</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; myVector;<br>        stack&lt;<span class="hljs-type">int</span>&gt; myStack;<br>        <span class="hljs-built_in">middleIter</span>(root, myVector, myStack);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it : myVector)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it != myStack.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            myStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">middleIter</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; myVector, stack&lt;<span class="hljs-type">int</span>&gt;&amp; myStack)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">middleIter</span>(root-&gt;left, myVector, myStack);<br>        myVector.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        myStack.<span class="hljs-built_in">push</span>(root-&gt;val);<br>        <span class="hljs-built_in">middleIter</span>(root-&gt;right, myVector, myStack);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另外一种解法，递归，虽然想到了，但是第一次没写出来，mirror理解不到位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkSymmetricTree</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mirror</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> || right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mirror</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">mirror</span>(left-&gt;right, right-&gt;left) &amp;&amp; (left-&gt;val == right-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-32-1-从上往下打印二叉树"><a href="#剑指Offer-32-1-从上往下打印二叉树" class="headerlink" title="剑指Offer 32.1 从上往下打印二叉树"></a><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=23280&ru=/practice/6e196c44c7004d15b1610b9afca8bd88&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 32.1 从上往下打印二叉树</a></h2><p>二叉树的层序遍历：使用队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>queue&lt;TreeNode*&gt; q;<br>q.<span class="hljs-built_in">push</span>(root);<br>TreeNode* cur;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cur = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br><span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br><span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>拓展题目</strong></p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240307122047992.png" alt="image-20240307122047992"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) <br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        TreeNode* cur;<br>        map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; myMap; <span class="hljs-comment">//记录当前节点在第几层</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        myMap[root] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> level = myMap[cur];<br>            <span class="hljs-keyword">if</span>(myMap[cur] == res.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>            res[level].<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                myMap[cur-&gt;left] = level + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                myMap[cur-&gt;right] = level + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-7-重建二叉树"><a href="#剑指Offer-7-重建二叉树" class="headerlink" title="剑指Offer 7 重建二叉树"></a><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=23282&ru=/practice/7fe2212963db4790b57431d9ed259701&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 7 重建二叉树</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param preOrder int整型vector </span><br><span class="hljs-comment">     * @param vinOrder int整型vector </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vinOrder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preOrder, <span class="hljs-number">0</span>, preOrder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,<br>                     vinOrder, <span class="hljs-number">0</span>, vinOrder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vinOrder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> </span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-comment">// base case：要构建的是从[preStart, preEnd]之间的节点值，如果preStart&gt;preEnd，说明preOrder全部都用完了</span><br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <br>        <span class="hljs-type">int</span> rootVal = preOrder[preStart];<br>        <span class="hljs-type">int</span> rootIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vinOrder.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vinOrder[i] == rootVal)<br>            &#123;<br>                rootIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> leftSize = rootIndex - inStart;<br>        <br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(preOrder, preStart + <span class="hljs-number">1</span>, preStart + leftSize, <br>                           vinOrder, inStart, rootIndex - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(preOrder, preStart + leftSize + <span class="hljs-number">1</span>, preEnd, <br>                           vinOrder, rootIndex + <span class="hljs-number">1</span>, inEnd);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-86-在二叉树中找到两个节点的最近公共祖先"><a href="#剑指Offer-86-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="剑指Offer 86 在二叉树中找到两个节点的最近公共祖先"></a><a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=13&tqId=1024325&ru=/practice/d9820119321945f588ed6a26f0a6991f&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer 86 在二叉树中找到两个节点的最近公共祖先</a></h2><p>两个节点存在两种关系</p><ul><li>包含</li><li>分叉</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param o1 int整型 </span><br><span class="hljs-comment">     * @param o2 int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val == o1 || root -&gt;val == o2)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root-&gt;val;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNum = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2);<br>        <span class="hljs-type">int</span> rightNum = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2);<br>        <span class="hljs-comment">//左子树也搜到，右子树也搜到，返回root</span><br>        <span class="hljs-keyword">if</span>(leftNum != <span class="hljs-number">-1</span> &amp;&amp; rightNum != <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root-&gt;val;<br>        &#125;<br> <span class="hljs-comment">//都没搜到返回空</span><br>        <span class="hljs-keyword">if</span>(leftNum == <span class="hljs-number">-1</span> &amp;&amp; rightNum == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 一个为空一个不为空，返回为不为空的那个</span><br>        <span class="hljs-keyword">return</span> leftNum != <span class="hljs-number">-1</span> ? leftNum : rightNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer68-二叉搜索树的最近公共祖先"><a href="#剑指Offer68-二叉搜索树的最近公共祖先" class="headerlink" title="剑指Offer68 二叉搜索树的最近公共祖先"></a><a href="https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=13&tqId=2290592&ru=/practice/e0cc33a83afe4530bcec46eba3325116&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer68 二叉搜索树的最近公共祖先</a></h2><p>方法1：当作普通二叉树处理，但这不是题目想表达的意思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param p int整型 </span><br><span class="hljs-comment">     * @param q int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val == p || root-&gt;val == q) <span class="hljs-keyword">return</span> root-&gt;val;<br>        <span class="hljs-type">int</span> leftNum = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        <span class="hljs-type">int</span> rightNum = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span>(leftNum == <span class="hljs-number">-1</span> &amp;&amp; rightNum == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(leftNum != <span class="hljs-number">-1</span> &amp;&amp; rightNum != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> root-&gt;val;<br>        <span class="hljs-keyword">return</span> leftNum != <span class="hljs-number">-1</span> ? leftNum : rightNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法2：结合二叉搜索树的性质</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param p int整型 </span><br><span class="hljs-comment">     * @param q int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 1. 如果先遇到了p，返回p</span><br>        <span class="hljs-comment">// 2. 如果先遇到了q，返回q</span><br>        <span class="hljs-comment">// p和q肯定区分较大值和较小值:</span><br>        <span class="hljs-comment">// 3. 如果root大于最大值，root左移</span><br>        <span class="hljs-comment">// 4. 如果root小于最小值，root右移</span><br>        <span class="hljs-comment">// 5. 如果最小值&lt;root&lt;最大值，返回root自己</span><br>        <span class="hljs-keyword">while</span> (root-&gt;val != q &amp;&amp; root-&gt;val != p) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;val &gt; <span class="hljs-built_in">min</span>(p, q) &amp;&amp; root-&gt;val &lt; <span class="hljs-built_in">max</span>(p, q))<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            root = root-&gt;val &gt; <span class="hljs-built_in">max</span>(p, q) ? root-&gt;left : root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer33-二叉搜索树的后序遍历序列"><a href="#剑指Offer33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指Offer33. 二叉搜索树的后序遍历序列"></a><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=23289&ru=/practice/a861533d45854474ac791d90e447bafd&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer33. 二叉搜索树的后序遍历序列</a></h2><p>二叉搜索树的最后一个节点是根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sequence, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> rootVal = sequence[right];<br>        <span class="hljs-type">int</span> p = left;<br>        <span class="hljs-comment">// 找到第一个大于rootVal的位置，大于根节点的位置</span><br>        <span class="hljs-keyword">while</span> (sequence[p] &lt; rootVal) <br>        &#123;<br>            p++;<br>        &#125;<br>        <span class="hljs-comment">// (p) -- right 之间，rootVal的值是否小于这些值 --这个不用判断，因为P的取值已经决定p之前的值都是小于rootVal的</span><br>        <span class="hljs-comment">// left -- (p-1) 之间，rootVal的值是否大于这些值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = p; i &lt; right; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sequence[i] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(sequence, left, p - <span class="hljs-number">1</span>) &amp;&amp;  <span class="hljs-built_in">func</span>(sequence, p, right - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer54-二叉查找树的第-K-个结点"><a href="#剑指Offer54-二叉查找树的第-K-个结点" class="headerlink" title="剑指Offer54. 二叉查找树的第 K 个结点"></a><a href="https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&tqId=2305268&ru=/practice/e0cc33a83afe4530bcec46eba3325116&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer54. 二叉查找树的第 K 个结点</a></h2><p>遇到这个题想到一种最直接的方法是把二叉树的节点都放到vector里，然后返回vector的第<code>k-1</code>个元素</p><p>面向用例编程….</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param proot TreeNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* proot, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(proot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">func</span>(proot, vec);<br>        <span class="hljs-keyword">if</span>(k &gt; vec.<span class="hljs-built_in">size</span>() || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> vec[k - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 中序遍历二叉树，将节点值放到vector里</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* proot, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(proot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">func</span>(proot-&gt;left, vec);<br>        vec.<span class="hljs-built_in">push_back</span>(proot-&gt;val);<br>        <span class="hljs-built_in">func</span>(proot-&gt;right, vec);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看了官方题解才写出来的答案：</p><ul><li>中序遍历并且使用一个变量<code>count</code>记录遍历到第几个了</li><li>如果<code>count == k</code> 说明找到了第<code>k</code>小的节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param proot TreeNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    TreeNode* res = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* proot, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(proot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">midOrder</span>(proot, k);<br>        <span class="hljs-keyword">if</span>(res)<br>        &#123;<br>            <span class="hljs-keyword">return</span> res-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(TreeNode* proot, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(proot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">midOrder</span>(proot-&gt;left, k);<br>        count++;<br>        <span class="hljs-keyword">if</span>(count == k) res = proot;<br><br>        <span class="hljs-built_in">midOrder</span>(proot-&gt;right, k);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer26-树的子结构"><a href="#剑指Offer26-树的子结构" class="headerlink" title="剑指Offer26. 树的子结构"></a><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=23293&ru=/practice/57aa0bab91884a10b5136ca2c087f8ff&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer26. 树的子结构</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 判断pRoot1是否包含pRoot2</span><br><span class="hljs-comment">// 子问题：以每一个pRoot1的节点作为根节点，判断是否包含pRoot2的子结构</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 1. 以pRoot1为根节点的树包含pRoot2</span><br>        <span class="hljs-comment">// 2. pRoot1 的左子树包含pRoot2</span><br>        <span class="hljs-comment">// 3. pRoot1 的右子树包含pRoot2</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTree</span>(pRoot1, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br><br><span class="hljs-comment">// 判断以A为根节点的树，是否包含以B为根节点的树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubTree</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(B == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(A == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> (A-&gt;val == B-&gt;val) &amp;&amp; <span class="hljs-built_in">isSubTree</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">isSubTree</span>(A-&gt;right, B-&gt;right);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer8-二叉树的下一个结点"><a href="#剑指Offer8-二叉树的下一个结点" class="headerlink" title="剑指Offer8. 二叉树的下一个结点"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451&ru=/practice/f836b2c43afc4b35ad6adc41ec941dba&qru=/ta/coding-interviews/question-ranking&sourceUrl=">剑指Offer8. 二叉树的下一个结点</a></h2><p>朴素解法：根据next指针一直向上找，找到整棵树的根节点，然后中序遍历，存到vector里，最后判断要找的值是哪个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pNode == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeLinkNode* root = pNode;<br>        <span class="hljs-keyword">while</span>(root-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            root = root-&gt;next;<br>        &#125;<br>        vector&lt;TreeLinkNode*&gt; vec;<br>        <span class="hljs-built_in">inOrder</span>(root, vec);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vec[i] == pNode)<br>            &#123;<br>                <span class="hljs-keyword">return</span> vec[i + <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeLinkNode* root, vector&lt;TreeLinkNode*&gt;&amp; vec)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left, vec);<br>        vec.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right, vec);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>进阶解法：看完题解才明白</p><ul><li>当前节点有右子树<ul><li>找到右子树的最左节点</li></ul></li><li>当前节点没有右子树<ul><li>当前节点为父节点的左节点，返回父节点</li><li>当前节点为父节点的右节点，一直向上找，直到上级是上上级的左孩子，返回上上级</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 当前节点有右子树，找到右子树的最左节点</span><br>        <span class="hljs-keyword">if</span>(pNode-&gt;right != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            pNode = pNode -&gt;right;<br>            <span class="hljs-keyword">while</span>(pNode-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                pNode = pNode-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> pNode;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-comment">// 当前节点没有右子树</span><br>            <span class="hljs-comment">// 1. 当前节点为父节点的左节点，返回父节点</span><br>            <span class="hljs-keyword">if</span>(pNode-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; pNode == pNode-&gt;next-&gt;left) <span class="hljs-keyword">return</span> pNode-&gt;next;<br>            <span class="hljs-comment">// 2.当前节点为父节点的右节点，一直向上找，直到上级是上上级的左孩子，返回上上级</span><br>            <span class="hljs-keyword">if</span>(pNode-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; pNode == pNode-&gt;next-&gt;right)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(pNode-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; pNode != pNode-&gt;next-&gt;left)<br>                &#123;<br>                    pNode = pNode-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> pNode-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="剑指Offer34-二叉树中和为某一值的路径"><a href="#剑指Offer34-二叉树中和为某一值的路径" class="headerlink" title="剑指Offer34. 二叉树中和为某一值的路径"></a><a href="https://leetcode.cn/problems/path-sum-ii/description/">剑指Offer34. 二叉树中和为某一值的路径</a></h2><p>递归+恢复现场</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) <br>    &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">func</span>(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        targetSum -= root-&gt;val;<br>        <span class="hljs-keyword">if</span>(targetSum == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">func</span>(root-&gt;left, targetSum);<br>        <span class="hljs-built_in">func</span>(root-&gt;right, targetSum);<br><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong><a href="https://leetcode.cn/problems/path-sum/">路径总和</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root -&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> targetSum - root-&gt;val == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum-root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum-root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>生活的不如意是理想存在的必要条件。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="零、网络的全貌"><a href="#零、网络的全貌" class="headerlink" title="零、网络的全貌"></a>零、网络的全貌</h1><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224125924309.png" alt="网络的全貌"></p><p>从浏览器到web服务器</p><p>（1）浏览器向web服务器发送请求</p><p>（2）web服务器根据请求向浏览器回复响应</p><p><strong>从在浏览器按下发送键到收到服务器响应这一过程发生了什么？</strong></p><h1 id="一、web浏览器"><a href="#一、web浏览器" class="headerlink" title="一、web浏览器"></a>一、web浏览器</h1><p><strong>在浏览器输入网址（URL）–&gt; 浏览器将数据委托操作系统发出去</strong></p><h2 id="1-生成HTTP请求消息"><a href="#1-生成HTTP请求消息" class="headerlink" title="1 生成HTTP请求消息"></a>1 生成HTTP请求消息</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20240222220843937.png" alt="image-20240222220843937"></p><h3 id="1-1-从输入网址开始"><a href="#1-1-从输入网址开始" class="headerlink" title="1.1 从输入网址开始"></a>1.1 从输入网址开始</h3><p>网址，准确的说应该是URL（Uniform Resource Locator，统一资源定位符）</p><p>比如百度官网：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://www.baidu.com/<br></code></pre></td></tr></table></figure><p>此处是以 https: 开头的，实际上还有其它开头，如 “ftp:”  “file:”  “mailto” 等。下图是几种常见的URL</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240222221715764.png" alt="image-20240222221715764"></p><p>对于不同的开头，它后面的写法也不相同。比如上图中访问 HTTP服务器和访问FTP服务器的方式是服务器域名+文件的路径名，而发送电子邮件时则包含收件人的邮箱地址。</p><p>这些开头的文字可以理解问访问时使用的协议类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP：Hypertext Transfer Prorocol, 超文本传输协议<br></code></pre></td></tr></table></figure><h3 id="1-2-浏览器先要解析URL"><a href="#1-2-浏览器先要解析URL" class="headerlink" title="1.2 浏览器先要解析URL"></a>1.2 浏览器先要解析URL</h3><p>URL的格式随着协议不同而不同，以访问web服务器为例：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224105925444.png" alt="image-20240224105925444"></p><p>上图表示浏览器要访问 <a href="http://www.lab.glasscom.com/">www.lab.glasscom.com</a> 这个web服务器下的 &#x2F;dir1&#x2F;file1.html文件。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224110301148.png" alt="image-20240224110301148"></p><h3 id="1-3-文件名省略的情况"><a href="#1-3-文件名省略的情况" class="headerlink" title="1.3 文件名省略的情况"></a>1.3 文件名省略的情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://www.lab.glasscom.com/dir1/file1.html <br></code></pre></td></tr></table></figure><p>上面是一个典型的URL，但是有时也会有文件名省略的情况，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">(a) http://www.lab.glasscom.com/dir1/<br></code></pre></td></tr></table></figure><p>(a) 这种URL的写法是以 &#x2F; 作为结尾，可以这样理解：以 “&#x2F;“ 结尾的URL表示&#x2F;dir1&#x2F;后面本该有的文件名被省略了。那么服务器应该访问哪个文件呢？</p><p>其实，这种一般会访问事先设置好的文件，这种设置根据服务器的不同而不同，大多数情况是 index.html 和default.html 之类的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">(b) http://www.lab.glasscom.com/<br></code></pre></td></tr></table></figure><p>(b) 这种也是以”&#x2F;“ 结尾的，它表示访问一个 “&#x2F;“ 的目录，由于省略了文件名，所以默认访问index.html 和default.html 之类的文件。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(c)</span> http:<span class="hljs-comment">//www.lab.glasscom.com</span><br></code></pre></td></tr></table></figure><p>(c) 连”&#x2F;“都省略了，这时会默认访问根目录下事先设置好的默认文件，也就是 &#x2F;index.html 和 &#x2F;default.html 之类的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">(d) http://www.lab.glasscom.com/whatisthis<br></code></pre></td></tr></table></figure><p>(d)这种情况的处理方式是：如果服务器上存在 whatisthis这个文件，则将其作为文件来处理；如果服务器上存在 whatisthis 这个文件夹，则将其作为文件夹来处理。</p><p>ps：无法创建名字是whatisthis的文件和文件夹，所以上面这种方式并不会产生歧义。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224113148681.png" alt="image-20240224113148681"></p><h3 id="1-4-HTTP协议的基本思路"><a href="#1-4-HTTP协议的基本思路" class="headerlink" title="1.4 HTTP协议的基本思路"></a>1.4 HTTP协议的基本思路</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224114522554.png" alt="image-20240224114522554"></p><p>HTTP协议定义了客户端与服务器的交互消息内容和步骤。其思路是：</p><ul><li>客户端向服务器发送请求消息。请求消息中包含“对什么”“进行什么样的操作”<ul><li>对什么：就是URI（Uniform Resource Identifier, 统一资源标识符）。URI一般是一个存放网页的数据的文件名或者是一个CGI程序。也可以使用http:开头的URL作为URI。可以理解为，这里可以写各种访问目标，而这些访问目标就称为URI。</li><li>进行什么样的操作：就是方法，表示让web服务器完成什么样的操作。例如，读取URI表示的数据，或者将客户端输入的数据发给URI表示的程序等。</li></ul></li></ul><p>HTTP的主要方法如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224122810742.png" alt="image-20240224122810742"></p><p>​常用的方法是GET和POST</p><p>​GET：当访问web服务器上的数据时，一般使用的是GET方法。服务器收到请求后，根据URI查找数据，并将数据放到响应消息中发给客户端、</p><p>​POST：当在表单（网页中的文本框等能够输入数据的地方，如淘宝中的搜索框）中填写数据并将其发给web服务器时，一般使用的是POST方法。POST方法会指向web服务器中运行的一个应用程序名的文件名。然后在请求消息中除了传递URI和方法外还需要传递需要输入给web服务器的数据，也就是用户框的填的内容。web服务器收到消息后，会将请求消息中的数据发给URI执行的应用程序，应用程序执行结束后将结果发给web服务器，web服务器再将结果放到响应消息后发给客户端。</p><ul><li><p>服务器向客户端回复响应。服务器根据URI和方法判断“对什么”“进行什么样的操作”。完成操作后将结果放在响应消息中，响应消息的开头有一个状态码，用来表示执行的结果是成功还是失败。状态码后面就是头字段和网页数据。客户端收到响应消息后，在浏览器会从消息中读取所需的数据并显示在屏幕上。</p><p>常用的状态码如下：</p><table><thead><tr><th align="left">状态码</th><th>含义</th></tr></thead><tbody><tr><td align="left">1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr><tr><td align="left">200</td><td>请求成功</td></tr><tr><td align="left">201</td><td>已创建，成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td>已接受，已接受请求，但未处理完成</td></tr><tr><td align="left">301</td><td>永久重定向，请求的资源被永久移到新URL，今后任何新的请求都应使用新的URL代替</td></tr><tr><td align="left">302</td><td>暂时重定向，资源只是临时被移动，客户端仍使用原有的URL</td></tr><tr><td align="left">400</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td>请求要求用户的身份认证</td></tr><tr><td align="left">403</td><td>服务器理解客户端的请求，但是拒绝执行的请求</td></tr><tr><td align="left">404</td><td>服务器无法根据客户端的请求找到资源</td></tr><tr><td align="left">500</td><td>服务器内部错误，无法完成请求服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">503</td><td>由于超载或系统维护，服务器暂时无法处理客户端的请求</td></tr></tbody></table></li></ul><h3 id="1-5-生成HTTP请求消息"><a href="#1-5-生成HTTP请求消息" class="headerlink" title="1.5 生成HTTP请求消息"></a>1.5 生成HTTP请求消息</h3><p>浏览器对URL进行解析之后，浏览器就确定了web服务器和文件名，知道应该要访问的目标在哪里了，接下来浏览器会使用HTTP协议来访问web服务器。首先要根据web服务器和文件名生成HTTP请求消息。HTTP消息的格式如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240224131140699.png" alt="image-20240224131140699"></p><p><strong>请求的第一行为请求行。</strong></p><ul><li><p>请求行的开头是方法，方法可以告诉服务器它应该进行什么样的操作，重点是确定使用哪种方法。确定的关键是在于浏览器的工作状态：比如在搜索框中输入网址，会使用GET方法，点击超链接也会使用GET方法，在表单中点击 ”提交“会使用POST方法。</p></li><li><p>方法之后加一个空格，后面再跟上URI，URI的一般格式为文件和程序的路径： &#x2F;&lt;目录名&gt;&#x2F;…&#x2F;&lt;文件名&gt;，而从浏览器输入的URL中已经包含路径了，所以从URL复制就可以了。</p></li><li><p>第一行的末尾需要添加上HTTP的版本号，这是为了表示该消息是基于哪个版本的HTTP发出的。</p></li></ul><p><strong>请求从第二行开始为消息头</strong></p><ul><li>消息头是为了存放额外信息，长度为几行到几十行不等</li></ul><p><strong>消息头后加一行空行</strong></p><p><strong>空行后是消息体</strong></p><ul><li>在使用GET方法时，仅通过方法和URI，服务器就能知道客户端想让服务器执行什么操作，所以此场景下消息体不需要填写内容。</li><li>当使用POST方法时，需要将表单中填写的信息放到消息体中。</li></ul><p><strong>消息体之后整个消息就结束了</strong></p><h3 id="1-6-发送请求后会收到响应"><a href="#1-6-发送请求后会收到响应" class="headerlink" title="1.6 发送请求后会收到响应"></a>1.6 发送请求后会收到响应</h3><p>响应消息的格式及基本思路和请求消息基本是一致的，差别只在第一行。</p><p><strong>第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错</strong></p><ul><li>状态码是一个数字，用来向<strong>程序</strong>告知执行的结果</li><li>响应短语是一段文字，用来向<strong>人类</strong>告知执行的结果</li></ul><p>如果网页中只有文字，到这里就结束了。</p><p>如果网页中包含图片，会在网页中的相应位置嵌入表示图片相关的标签的控制信息，浏览器会在显示文字的时候搜索相关的标签，当遇到图片相关标签时，会在屏幕上预留相应的空间，然后再次访问web服务器，向服务器请求标签所表示的图片，收到响应后将图片显示在预留的空间上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">标签：编写网页所使用的HTML语言中规定的控制信息。例如，当需要在网页中插入图片时，需要在相应位置嵌入形如&lt;img src = <span class="hljs-string">&quot;imalel.jpg&quot;</span>&gt;的标签。<br></code></pre></td></tr></table></figure><h2 id="2-向DNS服务器查询Web服务器的IP地址"><a href="#2-向DNS服务器查询Web服务器的IP地址" class="headerlink" title="2 向DNS服务器查询Web服务器的IP地址"></a>2 向DNS服务器查询Web服务器的IP地址</h2><p>生成HTTP请求消息后，需要委托操作系统把消息发出去，而操作系统不是根据域名发送消息的，而是根据IP地址发送的，因此，在生成HTTP请求消息后，下一个步骤就是根据域名查询IP地址。 </p><h3 id="2-1-IP地址基本知识"><a href="#2-1-IP地址基本知识" class="headerlink" title="2.1 IP地址基本知识"></a>2.1 IP地址基本知识</h3><p>TCP&#x2F;IP网络的基本思路：</p><ul><li>发送者发出的消息首先通过子网中的集线器，转发到距离最近的路由器上；</li><li>路由器会根据消息的目的地根据IP地址判断下一个路由器的位置，然后将消息发送到下一个路由器；</li><li>前面的过程不断重复，最终消息就被传送到了目的地。</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240226194908071.png" alt="image-20240226194908071"></p><p><strong>IP地址是什么？</strong></p><p>实际的IP地址是一串32比特的数字，按照8比特（1字节）为一组分为4组，分别用10进制表示并用圆点隔开。但是仅有这些信息还是不知道网络号和主机号分别是什么。原因是网络号和主机号连起来总共32比特，但这两部分的具体结构不确定，因此还需要附加信息。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240226200346659.png" alt="image-20240226200346659"></p><p>附加信息就是子网掩码，如图：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240226200949365.png" alt="image-20240226200949365"></p><p>根据子网掩码和IP地址主体，就能得到网络号（网段）和主机号，可以理解为<strong>子网掩码就是分隔网络号和主机号的</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.1.1/255.255.255.0  //表示其中192.168.1 就是网络号，最后的0是主机号<br>192.168.1.1/255.255.0.0  //其中192.168 就是网络号，最后两个0是主机号<br>192.168.2.2/255.255.0.0  //根据子网掩码判断和192.168.1.1/255.255.0.0 属于同一网段<br></code></pre></td></tr></table></figure><h3 id="2-2-域名和IP地址并用的理由"><a href="#2-2-域名和IP地址并用的理由" class="headerlink" title="2.2 域名和IP地址并用的理由"></a>2.2 域名和IP地址并用的理由</h3><p><strong>知道了IP地址就知道了网络上的哪一台计算机，那还需要域名吗？</strong></p><p>如果IP地址和域名只知道其一，会发生下面的情况：</p><ul><li>已知IP地址：实际上，在浏览器中输入IP也是可以搜索的，但是IP太长，那么多的网址，记不住。</li><li>已知域名：互联网中大量的路由器根据IP地址判断下一步应该往哪里发，如果使用域名，域名的大小最短也是几十个字节，传输时会耗费大量的时间，就算提升路由器的性能，但与此同时，消息转发数量也在增加，因此，只用域名转发消息不可行。</li></ul><p>那么，目前已知域名，怎么得到IP地址呢？</p><h3 id="2-3-通过解析器向DNS发出查询请求"><a href="#2-3-通过解析器向DNS发出查询请求" class="headerlink" title="2.3 通过解析器向DNS发出查询请求"></a>2.3 通过解析器向DNS发出查询请求</h3><p>根据域名查询IP地址的方法很简单：</p><ul><li>浏览器向DNS服务器发送查询请求，请求携带域名（前提是要查询的域名在DNS服务器上注册，才能够查到）；</li><li>DNS服务器回复响应消息，响应携带IP地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">DNS：Domain Name System, 域名服务系统<br></code></pre></td></tr></table></figure><p><strong>那么，浏览器是如何向DNS发送查询请求的呢？</strong></p><p>先了解两个概念：</p><ul><li><strong>解析器</strong>：对于DNS服务器，我们的计算机上一定有DNS客户端，相当于DNS客户端的部分被称作DNS解析器，简称解析器，解析器实际上是一段程序，位于操作系统的Socket库中。</li><li><strong>域名解析</strong>：通过DNS服务器将域名解析成IP的操作称为域名解析</li></ul><p>解析器的用法如下图：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240301214900330.png" alt="image-20240301214900330"></p><p>Socket库中的程序都是标准组件，只需要在应用程序（浏览器）中调用就可以了：在编写应用程序时，像上图那样写上解析器的程序名和域名，就完成了调用。</p><ul><li><p>浏览器调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器回复响应，响应内容包含IP地址，解析器取出IP地址，写入浏览器指定的内存中</p></li><li><p>接下来，浏览器在向HTTP发送请求消息时，会从该内存中取出IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。</p></li></ul><h3 id="2-4-解析器的工作原理"><a href="#2-4-解析器的工作原理" class="headerlink" title="2.4 解析器的工作原理"></a>2.4 解析器的工作原理</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20240301220432973.png" alt="image-20240301220432973"></p><ul><li><p>浏览器应用代码调用解析器时，流程会走到解析器内部</p></li><li><p>解析器生成要发送给DNS服务器的消息，并委托操作系统发送（解析器本身并不仅具备网络收发数据消息功能）</p></li><li><p>解析器收到DNS服务器的响应消息后，取出消息中的IP地址，存放到内存中</p></li><li><p>将代表该内存的变量返回给浏览器</p></li></ul><p><strong>解析器是如何知道DNS服务器的IP地址呢？</strong></p><p>这个是事先设置好的</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240301221859624.png" alt="image-20240301221859624"></p><h3 id="2-5-DNS服务器的基本工作"><a href="#2-5-DNS服务器的基本工作" class="headerlink" title="2.5 DNS服务器的基本工作"></a>2.5 DNS服务器的基本工作</h3><p>DNS服务器的基本工作如图：</p><ul><li>接收DNS客户端的请求消息。请求消息包含：<ul><li>域名：服务器、邮件服务器（邮件地址中@后面的部分）的名称</li><li>Class：最早的DNS服务器考虑到了互联网之外的其它网络中的应用，Class就是用来识别网络的信息，如今Class的值永远是IN（代表互联网）</li><li>记录类型：表示域名对应何种类型的记录。A：表示域名对应的是IP地址，MX：表示域名对应的是邮件服务器</li></ul></li><li>根据请求消息返回响应</li></ul><p><img src="/../imgs/$%7Bfiilename%7D/image-20240301222651408.png" alt="image-20240301222651408"></p><h3 id="2-6-域名的层次结构"><a href="#2-6-域名的层次结构" class="headerlink" title="2.6 域名的层次结构"></a>2.6 域名的层次结构</h3><p>DNS的域名都是用句点来分隔的，比如<code>www.lab.glasscom.com</code>，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。</p><p>在域名中，越靠右的位置表示其层次越高，比如<code>www.lab.glasscom.com</code>：<code>com</code>域的下一层是<code>glass</code>域，再下一层是<code>lab</code>域，再下面才是<code>www</code>这个名字</p><h3 id="2-7-寻找响应的DNS服务器并获取IP地址"><a href="#2-7-寻找响应的DNS服务器并获取IP地址" class="headerlink" title="2.7 寻找响应的DNS服务器并获取IP地址"></a>2.7 寻找响应的DNS服务器并获取IP地址</h3><p><strong>如何找到DNS服务器中存放的信息，即如何找到我们要访问的web服务器的信息归哪一台DNS服务器管？</strong></p><ul><li>将管理下级域的DNS服务器的IP地址注册到上一级DNS服务器中</li><li>再将上一级DNS服务器的IP地址注册到更上一级的DNS服务器中</li></ul><p>这样就可以通过上级DNS服务器找到下级域的DNS服务器的IP地址</p><p>其实，互联网中最顶层的域是根域，<code>www.lab.glasscom.com.</code>最后的 . 就是根域，只是平时不写出来，根域中保管着com 这种域的IP地址，因此，互联网中所有DNS服务器中都可以保存根域的IP地址，这样的话，只要客户端能找到任何一台DNS服务器，就可以根据这台DNS服务器找到根域，然后顺藤摸瓜，找到想要的域名对应的IP地址。</p><p><strong>根域DNS服务器的相关信息已经包含在DNS服务器程序的配置文件中了</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240304213227954.png" alt="image-20240304213227954"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240304213442014.png" alt="image-20240304213442014"></p><h3 id="2-8-通过缓存加快DNS服务器的响应"><a href="#2-8-通过缓存加快DNS服务器的响应" class="headerlink" title="2.8 通过缓存加快DNS服务器的响应"></a>2.8 通过缓存加快DNS服务器的响应</h3><p>上面展示的是DNS服务器工作的基本原理，与真实互联网上的DNS服务器工作还是有点区别的：</p><ul><li><p>真实互联网中，一台DNS服务器会保存多个域的信息，上图中的上级域和下级域可能共享同一台DNS服务器</p></li><li><p>有时候并不需要从最上面的根域开始查找，因为DNS有个缓存功能，可以记住之前查过的域名</p></li><li><p>并且，当要查询的域名不存在时，”不存在”这一信息也会被记录，下次再查询这个域名时，可以快速响应</p></li></ul><p>缓存机制有一点需要注意：就是信息被缓存后，原本注册信息可能会发生改变，这时候就缓存中的信息就不是最新的了，因此需要给缓存设置一个有消息，超过这个有效期后，缓存中的内容就会被清除。而且，在对查询进行响应时，也应该告知响应结果是缓存给的还是管理该域名的DNS服务器</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/2024/01/31/hexo/"/>
    <url>/2024/01/31/hexo/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>生成及上传</strong></p><p>hexo clean<br>rm -rf .deploy_git&#x2F;<br>git config –global core.autocrlf false<br>hexo g<br>hexo d</p><p><strong>图片插入之后上传</strong></p><p>..&#x2F;..&#x2F;source&#x2F;imgs&#x2F;${fiilename}</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20240201204311056.png" alt="image-20240201204311056"></p><p>主题：</p><p><a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p><p><a href="https://www.erenship.com/posts/40222.html">https://www.erenship.com/posts/40222.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2024/01/31/%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/31/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二分法"><a href="#一、二分法" class="headerlink" title="一、二分法"></a>一、二分法</h1><h2 id="1-基础场景"><a href="#1-基础场景" class="headerlink" title="1 基础场景"></a>1 基础场景</h2><p>场景1：在<strong>非降序</strong>数组中查找某个值的下标；</p><p>场景2：在<strong>非降序</strong>数组中查找某个值的起止位置。</p><h2 id="2-常规代码"><a href="#2-常规代码" class="headerlink" title="2 常规代码"></a>2 常规代码</h2><p>场景1：在非降序数组中查找某个值的下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 此时left和right的取值可以理解为是“左闭右开”区间：[left，right)</span><br>    <span class="hljs-keyword">while</span>(left &lt; right) <span class="hljs-comment">// 1.写成&lt;的原因：前面定义的取值范围是[left，right)。2. 此条件的终止条件是：left == right</span><br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-comment">// 找到了</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) <span class="hljs-comment">// 说明目标值在mid的右方，那么需要变更左边界</span><br>        &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 加1的原因：区间是左闭右开，走到此分支说明target的索引肯定大于mid</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) <span class="hljs-comment">//说明目标值在mid的左方，那么需要变更右边界</span><br>        &#123;<br>            right = mid; <span class="hljs-comment">//不加1的原因：区间是左闭右开，right = mid，实际搜索的区间是[left， right-1]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束，终止条件为 left == right，即while外面left == right，走到这里说明没提前返回mid</span><br>    <span class="hljs-comment">// 区间要么在最左边，要么在最右边</span><br>    <span class="hljs-keyword">if</span>(left &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 最右边，left的另一个含义：left左边有nums.size()个值不符合要求</span><br>    <span class="hljs-keyword">return</span> nums[right] == target ? right : <span class="hljs-number">-1</span>;  <span class="hljs-comment">//最左边</span><br>&#125;<br></code></pre></td></tr></table></figure><p>场景2：在非降序数组中查找某个值的起止位置</p><p>查找左边界：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchLeftBoundary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>        &#123;<br>           right = mid; <span class="hljs-comment">// 找到之后左移右边界 </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>        &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>        &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> nums[right] == target ? right : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找右边界：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchRightBoundary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>        &#123;<br>left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到之后右移左边界</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>        &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>        &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left - <span class="hljs-number">1</span> &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 理解：mid = left - 1，mid就是每次找的索引</span><br>    <span class="hljs-keyword">return</span> nums[right - <span class="hljs-number">1</span>] == target ? right - <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-场景泛化"><a href="#3-场景泛化" class="headerlink" title="3 场景泛化"></a>3 场景泛化</h2><p><strong>给定一个场景，能够想到可以用二分法才是最重要的。靠经验和玄学。。</strong></p><p>让求最大&#x2F;最小边界值，能把题目抽象出一个x，f(x)，以及target。</p><p>条件1：并且f(x)是在x上的单调函数，单调增或单调减；</p><p>条件2：题目是让计算满足f(x) &#x3D;&#x3D; target时的x的值。</p><p><strong>使用二分法的步骤，确定用二分法后，按步骤来就可以了</strong></p><p>步骤1：思考 x、f(x)、target是什么，并写出f(x)的函数</p><p>步骤2：找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</p><p>步骤3：根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</p><h2 id="4-举例"><a href="#4-举例" class="headerlink" title="4 举例"></a>4 举例</h2><p><strong>leetcode：<a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></strong></p><p>步骤1：思考 x、f(x)、target是什么，并写出f(x)的函数</p><p>x：问题是求吃掉香蕉的最小速度，那么吃香蕉的速度就是x</p><p>f(x)：不同x对应吃掉所有香蕉的时间</p><p>target：时间h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">//函数实现的是在速度为x的情况下，把当前堆里香蕉(piles[i])吃完的时间hours</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> hours = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; piles.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        hours += piles[i] / x;<br>        <span class="hljs-keyword">if</span>(piles[i] % x &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            hours++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hours;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>步骤2：找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</p><p>x取值范围：[1，10^9 + 1) –&gt; left &#x3D; 1, right &#x3D; 10^9 + 1;</p><p>步骤3：根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> h)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> left = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> right = <span class="hljs-number">1000000000</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(piles, mid) == h) <span class="hljs-comment">// 找到了。右边界左移</span><br>        &#123;<br>            right = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(piles, mid) &gt; h)<br>        &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 不理解，先死记</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(piles, mid) &lt; h)<br>        &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>leetcode：<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></strong></p><p>步骤1：思考 x、f(x)、target是什么，并写出f(x)的函数</p><p>x：让包裹送达的船的最低运载能力</p><p>f(x)：运载能力越大，用的时间越少（单调减），函数返回的就是运载能力为x的情况下，所需的天数</p><p>target：最大天数days，也就是f(x)的限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 函数返回的就是运载能力为x的情况下，所需的天数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> days = <span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); )<br>    &#123;<br>        <span class="hljs-type">int</span> cap = x; <span class="hljs-comment">// 每天的容量都重置</span><br>        <span class="hljs-keyword">while</span>(i &lt; weights.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(weights[i] &gt; cap)<br>            &#123;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//容量不够装下下一个的话，就明天装</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//weights[i] &lt;= cap</span><br>            &#123;<br>                cap -= weights[i];<br>            &#125;<br>            i++;<br>        &#125;<br>days++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> days;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤2：找到 <code>x</code> 的取值范围作为二分搜索的搜索区间，初始化 <code>left</code> 和 <code>right</code> 变量</p><p>x范围：最小为weight[]的最大值，最大为weight[]的总和，即[left, right) –&gt; [max(weight[i]), sum[weight[]])</p><p>步骤3：根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sumWeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        sumWeight += weights[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sumWeight;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> maxWeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(weights[i] &gt; maxWeight)<br>        &#123;<br>            maxWeight = weights[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxWeight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> days)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(weights);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">sum</span>(weights) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(weights, mid) == days)<br>        &#123;<br>            right = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(weights, mid) &gt; days)<br>        &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(weights, mid) &lt; days)<br>        &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、双指针"><a href="#二、双指针" class="headerlink" title="二、双指针"></a>二、双指针</h1><h2 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1 快慢指针"></a>1 快慢指针</h2><p><strong>场景1：原地修改数组</strong></p><p>leetcode：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast &lt; nums.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums[fast] != nums[slow])<br>        &#123;<br>            slow++;<br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>; <span class="hljs-comment">//根据不同题目修改返回值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2 左右指针"></a>2 左右指针</h2><p><strong>场景1：回文子串</strong></p><p><strong>场景2：二分法类似场景</strong></p><h1 id="三、前缀和数组"><a href="#三、前缀和数组" class="headerlink" title="三、前缀和数组"></a>三、前缀和数组</h1><h2 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1 一维数组"></a>1 一维数组</h2><p><strong>应用场景：前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。</strong></p><p>leetcode: <a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></p><p>注意：</p><ul><li>前缀和数组比原数组的长度大1，需要扩容</li><li>前缀和就是 第 i个索引的值&#x3D;第(i-1)个索引的值+原数组第i个索引的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><br><span class="hljs-keyword">private</span>: <br>    vector&lt;<span class="hljs-type">int</span>&gt; preArray;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) <br>    &#123;<br>        preArray.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            preArray[i] = preArray[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> preArray[right + <span class="hljs-number">1</span>] - preArray[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2 二维数组"></a>2 二维数组</h2><h1 id="四、差分数组"><a href="#四、差分数组" class="headerlink" title="四、差分数组"></a>四、差分数组</h1><p><strong>适用场景：频繁对原始数组的某个区间的元素进行增减。</strong></p><p><strong>推理：</strong></p><ul><li>构造差分数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 已知原始数组为nums</span><br>vector&lt;<span class="hljs-type">int</span>&gt; diffArray;<br>diffArray[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    diffArray[i] = nums[i] - nums[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//得到差分数组　</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据差分数组可反推原数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>res[<span class="hljs-number">0</span>] = diffArray[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; diffArray.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    res[i] = diffArray[i] + res[i - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>根据反推原数组的原理，如果给定一个原数组 nums，目的让[i, j]中的元素 +val，那么可以让diffArray[i]+&#x3D;3，再让diffArray[j + 1]-&#x3D;3即可实现。</p><p>leetcode：<a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br><br><br></code></pre></td></tr></table></figure><h1 id="五、滑动窗口"><a href="#五、滑动窗口" class="headerlink" title="五、滑动窗口"></a>五、滑动窗口</h1><h2 id="1-核心框架"><a href="#1-核心框架" class="headerlink" title="1 核心框架"></a>1 核心框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 滑动窗口算法框架 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-comment">// 用合适的数据结构记录窗口中的数据</span><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; <span class="hljs-comment">//左闭右开区间</span><br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> c = s[right];<br>        window.<span class="hljs-built_in">add</span>(c)<br>        <span class="hljs-comment">// 增大窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">/*** debug 输出的位置 ***/</span><br>        <span class="hljs-comment">// 注意在最终的解法代码中不要 print</span><br>        <span class="hljs-comment">// 因为 IO 操作很耗时，可能导致超时</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">/********************/</span><br>        <br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> d = s[left];<br>            window.<span class="hljs-built_in">remove</span>(d)<br>            <span class="hljs-comment">// 缩小窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2 举例"></a>2 举例</h2><p>leetcode：<a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window, needs;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t) needs[c]++;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>, valid=<span class="hljs-number">0</span>, start=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = INT_MAX;<br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> a = s[right];<br>            right++;<br>            <span class="hljs-keyword">if</span>(needs.<span class="hljs-built_in">count</span>(a))<br>            &#123;<br>                window[a]++;<br>                <span class="hljs-keyword">if</span>(window[a] == needs[a])<br>                &#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(valid == needs.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right- left &lt; len)<br>                &#123;<br>                    start = left;<br>                    len = right - left;<br>                &#125;<br>                <span class="hljs-type">char</span> d = s[left];<br>                left++;<br>                <span class="hljs-keyword">if</span>(needs.<span class="hljs-built_in">count</span>(d))<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(window[d] == needs[d])<br>                        valid--;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(start, len);<br>    &#125; <br></code></pre></td></tr></table></figure><p>leetcode：<a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window, need;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s1) need[c]++;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s2.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> a = s2[right];<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(a))<br>        &#123;<br>            window[a]++;<br>            <span class="hljs-keyword">if</span>(window[a] == need[a])<br>            &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right - left == s1.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">//缩小窗口条件</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(valid == need.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//注意</span><br>            <span class="hljs-type">char</span> d = s2[left];<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(window[d] == need[d])<br>                    valid--;<br>                window[d]--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>leetcode：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window, need;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : p) need[c]++;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, valid = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> a = s[right];<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(a))<br>        &#123;<br>            window[a]++;<br>            <span class="hljs-keyword">if</span>(window[a] == need[a])<br>            &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right - left == p.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(valid == need.<span class="hljs-built_in">size</span>()) res.<span class="hljs-built_in">push_back</span>(left);  <span class="hljs-comment">//注意</span><br>            <span class="hljs-type">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(window[d] == need[d])<br>                    valid--;<br>                window[d]--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h1><p> <strong>每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和</strong></p><h1 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h1><h2 id="1-从递归入手二维动态规划"><a href="#1-从递归入手二维动态规划" class="headerlink" title="1 从递归入手二维动态规划"></a>1 从递归入手二维动态规划</h2><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><strong><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></strong></h3><p><strong>暴力解法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 思路：如果想知道从左下角到右下角路径的最小值，可以求出其子问题，也就是从[0,0] --&gt; [i,j]路径的最小值，进一步，从[0,0] --&gt; [i,j]路径的最小值就等于 从[0,0] --&gt; [i-1,j-1]的最小值加上[i,j]的值。这样也就是递归的思路</span><br><span class="hljs-comment">//怎么想出来上面这个思路的？画个图，拆解一下问题，实例化进行分析</span><br><span class="hljs-comment">//暴力解法的入参填什么？不变量是grid，根据思路得到变量是横坐标和纵坐标即i和j，先确定这三个入参，进行【尝试】</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 暴力解法调用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">minPathSum1</span>(grid, grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//暴力解法实现</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum1</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// base case: 只有一个格子，那么最小路径就是当前格子的值</span><br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> up = INT_MAX;<br>        <span class="hljs-type">int</span> left = INT_MAX;<br>        <span class="hljs-comment">// 行数大于1</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//得到从[i - 1, j]到[i, j]路径的最小值</span><br>            up = <span class="hljs-built_in">minPathSum1</span>(grid, i - <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//得到从[i, j - 1]到[i, j]路径的最小值</span><br>            left = <span class="hljs-built_in">minPathSum1</span>(grid, i, j - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(up, left) + grid[i][j];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>记忆化搜索</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-comment">// 就是加缓存表，那么缓存表的大小是多少？ 原格子中一个格子对应缓存表的一个格子，那么缓存表的大小就是原格子的大小</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-comment">//创建一个缓存表，传到函数里</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(grid.<span class="hljs-built_in">size</span>(),<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-number">-1</span>));<br>        <span class="hljs-built_in">minPathSum2</span>(grid, grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, dp);<br>        <span class="hljs-keyword">return</span> dp[grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br><span class="hljs-comment">//记忆化搜索实现：根据暴力递归修改，基本上是固定写法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum2</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果dp表的[i,j]位置不是-1，说明之前有计算过，那么直接返回缓存表里的值</span><br><span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> dp[i][j]; <span class="hljs-comment">// 用缓存</span><br>        &#125;<br>        <span class="hljs-comment">// dp表的[i,j]位置是-1，说明之前没加到缓存里，那么就需要加到缓存里</span><br>        <span class="hljs-type">int</span> curVal = <span class="hljs-number">0</span>; <span class="hljs-comment">//定义一个变量代表当前缓存表格子的值，算出来curval的之后更新到dp缓存表中</span><br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>        &#123;<br>            curVal = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> up = INT_MAX;<br>            <span class="hljs-type">int</span> left = INT_MAX;<br>            <span class="hljs-comment">// 行数大于1</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">//得到从[i - 1, j]到[i, j]路径的最小值</span><br>                up = <span class="hljs-built_in">minPathSum2</span>(grid, i - <span class="hljs-number">1</span>, j, dp);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">//得到从[i, j - 1]到[i, j]路径的最小值</span><br>                left = <span class="hljs-built_in">minPathSum2</span>(grid, i, j - <span class="hljs-number">1</span>, dp);<br>            &#125;<br>            curVal = <span class="hljs-built_in">min</span>(up, left) + grid[i][j];<br>        &#125;<br>        dp[i][j] = curVal; <span class="hljs-comment">//挂缓存</span><br><span class="hljs-keyword">return</span> curVal; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>严格位置依赖的动态规划</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//其实就是创建一个dp表，dp表中每个格子的值dp[i][j]就是从dp[0][0] --&gt; dp[i][j]的最小路径和，和缓存表存的内容一样，只是给dp表赋值的方式不一样</span><br><span class="hljs-comment">// 问题是怎么赋值？ 查看依赖关系，如果想得到dp[i][j]的值，那么就要知道dp[i-1][j]和dp[i][j-1]两者之间的最小值加上grid[i][j]的值，也就是左上角的值最好求，最终求出右下角的值</span><br><span class="hljs-comment">// 动态规划表的大小：每个可变参数的可能性数量相乘。例如本题中，有两个可变参数，行数和列数，可能性数量也就是取值，行数和列数的取值范围分别为 0--grid.size(),0--grid[0].size()那么动态规划表的大小就是 grid.size() * grid[0].size()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span><br><span class="hljs-function">    </span>&#123;<br><span class="hljs-comment">//创建一个dp表</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(grid.<span class="hljs-built_in">size</span>(),<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 第一行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); index++)<br>        &#123;<br>            dp[<span class="hljs-number">0</span>][index] = dp[<span class="hljs-number">0</span>][index- <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][index];<br>        &#125;<br>        <span class="hljs-comment">// 第一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">1</span>; index &lt; grid.<span class="hljs-built_in">size</span>(); index++)<br>        &#123;<br>            dp[index][<span class="hljs-number">0</span>] = dp[index - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[index][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 算里面的</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt; grid.<span class="hljs-built_in">size</span>(); l++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); r++)<br>            &#123;<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l - <span class="hljs-number">1</span>][r], dp[l][r - <span class="hljs-number">1</span>]) + grid[l][r];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">char</span>&gt; t1, t2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> it : text1) t1.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> it : text2) t2.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-comment">// 暴力解法</span><br>        <span class="hljs-comment">// return func(t1, t2, 0, 0);</span><br><br>        <span class="hljs-comment">//加缓存</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(t1.size(), vector&lt;int&gt;(t2.size(), -1));</span><br>        <span class="hljs-comment">// return func2(t1, t2, 0, 0, dp);</span><br><br>        <span class="hljs-comment">// 严格位置依赖的动态规划</span><br>        <span class="hljs-comment">//1 画图分析某个格子依赖格子可以得到答案</span><br>        <span class="hljs-comment">//2 确定方向，从左到右/从右到左、从上到下/从下到上的方向（从简单到复杂的方向）比如本题中根据递归写法可以知道当前位置[i,j]格子的值依赖[i+1,j+1]和[i+1][j]和[i][j+1]</span><br>        <span class="hljs-comment">//3 填dp表</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(t1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(t1[i] == t2[j])<br>                &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, vector&lt;<span class="hljs-type">char</span>&gt;&amp; t2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i == t1.<span class="hljs-built_in">size</span>() || j ==t2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t1[i] == t2[j])<br>        &#123;<br>            ans = <span class="hljs-built_in">func</span>(t1, t2, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func</span>(t1, t2, i + <span class="hljs-number">1</span>, j), <span class="hljs-built_in">func</span>(t1, t2, i, j + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 加缓存</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, vector&lt;<span class="hljs-type">char</span>&gt;&amp; t2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i == t1.<span class="hljs-built_in">size</span>() || j ==t2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[i][j]; <span class="hljs-comment">// 用缓存</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t1[i] == t2[j])<br>        &#123;<br>            ans = <span class="hljs-built_in">func2</span>(t1, t2, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, dp) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func2</span>(t1, t2, i + <span class="hljs-number">1</span>, j, dp), <span class="hljs-built_in">func2</span>(t1, t2, i, j + <span class="hljs-number">1</span>, dp));<br>        &#125;<br>        dp[i][j] = ans; <span class="hljs-comment">// 挂缓存</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">char</span>&gt; t1, t2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            t1.<span class="hljs-built_in">push_back</span>(s[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            t2.<span class="hljs-built_in">push_back</span>(s[i]);<br>        &#125;<br>        <span class="hljs-comment">// 解法1：暴力解</span><br>        <span class="hljs-comment">// return func(t1, t2, 0, 0);</span><br><br>        <span class="hljs-comment">// 解法2：加缓存</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(t1.size(), vector&lt;int&gt;(t2.size(), -1));</span><br>        <span class="hljs-comment">// return func2(t1, t2, 0, 0, dp);</span><br><br>        <span class="hljs-comment">// 解法3：严格位置依赖的动态规划</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(t1.size() + 1, vector&lt;int&gt;(t2.size() + 1, 0));</span><br>        <span class="hljs-comment">// for(int i = t1.size() - 1; i &gt;= 0; i--)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     for(int j = t2.size() - 1; j &gt;= 0; j--)</span><br>        <span class="hljs-comment">//     &#123;</span><br>        <span class="hljs-comment">//         if(t1[i] == t2[j])</span><br>        <span class="hljs-comment">//         &#123;</span><br>        <span class="hljs-comment">//             dp[i][j] =dp[i + 1][j + 1] + 1;</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//         else</span><br>        <span class="hljs-comment">//         &#123;</span><br>        <span class="hljs-comment">//             dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]);</span><br>        <span class="hljs-comment">//         &#125;</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return dp[0][0];</span><br><br>        <span class="hljs-comment">// 解法4：区间dp解法</span><br>        <span class="hljs-comment">// if(t1.size() == 1) return 1;</span><br>        <span class="hljs-comment">// return func3(t1, 0, t1.size() - 1);</span><br><br>        <span class="hljs-comment">// 解法5：区间dp加缓存</span><br>        <span class="hljs-comment">// if(t1.size() == 1) return 1;</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(t1.size(), vector&lt;int&gt;(t1.size(), -1));</span><br>        <span class="hljs-comment">// return func4(t1, 0, t1.size() - 1, dp);</span><br><br>        <span class="hljs-comment">// 解法6：严格位置依赖的区间dp</span><br>        <span class="hljs-comment">//分析l 和 r的范围：l[0,t1.size() - 1] r[0, t1.size() - 1],所以dp表的大小为(t1.size()) * (t1.size())</span><br>        <span class="hljs-comment">//分析格子依赖：根据递归写法，可知某一个格子依赖于左、下和左下的格子，所以最终结果就是求dp表的左上角格子的值，即填dp表时的for循环就按此顺序</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(t1.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(t1.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; t1.<span class="hljs-built_in">size</span>())  dp[i][i + <span class="hljs-number">1</span>] = t1[i + <span class="hljs-number">1</span>] == t1[i] ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">2</span>; j &lt; t1.<span class="hljs-built_in">size</span>(); j++)<br>            &#123;<br>                <span class="hljs-comment">// if(i == j) dp[i][j] = 1;</span><br>                <span class="hljs-comment">// if(i + 1 == j) dp[i + 1][j] = t1[i + 1] == t1[j] ? 2 : 1;</span><br>                <span class="hljs-keyword">if</span>(t1[i] == t1[j])<br>                &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][t1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, vector&lt;<span class="hljs-type">char</span>&gt;&amp; t2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// base case </span><br>        <span class="hljs-keyword">if</span>(i == t1.<span class="hljs-built_in">size</span>() || j == t2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t1[i] == t2[j])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(t1, t2, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func</span>(t1, t2, i + <span class="hljs-number">1</span>, j), <span class="hljs-built_in">func</span>(t1, t2, i, j + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, vector&lt;<span class="hljs-type">char</span>&gt;&amp; t2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// base case </span><br>        <span class="hljs-keyword">if</span>(i == t1.<span class="hljs-built_in">size</span>() || j == t2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t1[i] == t2[j])<br>        &#123;<br>            ans = <span class="hljs-built_in">func2</span>(t1, t2, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, dp) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func2</span>(t1, t2, i + <span class="hljs-number">1</span>, j, dp), <span class="hljs-built_in">func2</span>(t1, t2, i, j + <span class="hljs-number">1</span>, dp));<br>        &#125;<br>        dp[i][j] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>  <br>        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// if(l &gt; r) return 0;</span><br>        <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> == r) <span class="hljs-keyword">return</span> t1[l] == t1[r] ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(t1[l] == t1[r])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">func3</span>(t1, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func3</span>(t1, l + <span class="hljs-number">1</span>, r), <span class="hljs-built_in">func3</span>(t1, l, r - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; t1, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> == r) <span class="hljs-keyword">return</span> t1[l] == t1[r] ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(dp[l][r] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[l][r];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t1[l] == t1[r])<br>        &#123;<br>            ans = <span class="hljs-built_in">func4</span>(t1, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, dp) + <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">func4</span>(t1, l + <span class="hljs-number">1</span>, r, dp), <span class="hljs-built_in">func4</span>(t1, l, r - <span class="hljs-number">1</span>, dp));<br>        &#125;<br>        dp[l][r] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(matrix.<span class="hljs-built_in">size</span>(), std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-comment">// ans = max(ans, func(matrix, i, j));</span><br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">func1</span>(matrix, i, j, dp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;   <br><br>        <span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; matrix[i + <span class="hljs-number">1</span>][j] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func</span>(matrix, i + <span class="hljs-number">1</span>, j));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[i - <span class="hljs-number">1</span>][j] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func</span>(matrix, i - <span class="hljs-number">1</span>, j));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; matrix[i][j + <span class="hljs-number">1</span>] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func</span>(matrix, i, j + <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[i][j - <span class="hljs-number">1</span>] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func</span>(matrix, i, j - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> next + <span class="hljs-number">1</span>; <span class="hljs-comment">// 4个next取最大再加上自己</span><br>    &#125;<br><br>    <span class="hljs-comment">//加缓存</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; matrix[i + <span class="hljs-number">1</span>][j] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func1</span>(matrix, i + <span class="hljs-number">1</span>, j, dp));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[i - <span class="hljs-number">1</span>][j] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func1</span>(matrix, i - <span class="hljs-number">1</span>, j, dp));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; matrix[i][j + <span class="hljs-number">1</span>] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func1</span>(matrix, i, j + <span class="hljs-number">1</span>, dp));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[i][j - <span class="hljs-number">1</span>] &gt; matrix[i][j])<br>        &#123;<br>            next = <span class="hljs-built_in">max</span>(next, <span class="hljs-built_in">func1</span>(matrix, i, j - <span class="hljs-number">1</span>, dp));<br>        &#125;<br>        dp[i][j] = next + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> next + <span class="hljs-number">1</span>; <span class="hljs-comment">// 4个next取最大再加上自己</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">char</span>&gt; ss, tt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> it : s) ss.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> it : t) tt.<span class="hljs-built_in">push_back</span>(it);<br><br>        <span class="hljs-comment">// 暴力解</span><br>        <span class="hljs-comment">// return func(ss, tt, 0, 0); </span><br><br>        <span class="hljs-comment">// 加缓存</span><br>        <span class="hljs-comment">// std::vector&lt;std::vector&lt;int&gt;&gt; dp(ss.size(), std::vector&lt;int&gt;(tt.size(), -1));</span><br>        <span class="hljs-comment">// return func2(ss, tt, 0, 0, dp); </span><br><br>        <span class="hljs-comment">// 严格位置依赖的动态规划</span><br>        <span class="hljs-comment">// 先确定格子大小</span><br>        <span class="hljs-type">int</span> n = ss.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = tt.<span class="hljs-built_in">size</span>();<br>        std::vector&lt;std::vector&lt;<span class="hljs-type">uint64_t</span>&gt;&gt; <span class="hljs-built_in">dp</span>(ss.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(tt.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 画图分析某个格子依赖哪些格子可以得到答案</span><br>        <span class="hljs-comment">// 确定方向，从左到右/从右到左、从上到下/从下到上的方向（从简单到复杂的方向）比如本题中根据递归写法可以知道当前位置[i,j]格子的值依赖[i+1,j]和[i+1][j + 1]</span><br>        <span class="hljs-comment">// 填dp表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            dp[i][m] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(ss[i] == tt[j])<br>                &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//总结：</span><br>    <span class="hljs-comment">//base case可以尝试的方向：i,j索引分别为0和n</span><br><span class="hljs-comment">// ss[i] == tt[j] 和 ss[i] != tt[j] 两者ans的求解方式与1143题.最长公共子序列 的形式一样，但ans求解方式不一样</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; ss, vector&lt;<span class="hljs-type">char</span>&gt;&amp; tt, <span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// if(i == ss.size() &amp;&amp; j == tt.size()) return 1;</span><br>        <span class="hljs-comment">// if(i != ss.size() &amp;&amp; j == tt.size()) return 1;</span><br>        <span class="hljs-keyword">if</span>(i == ss.<span class="hljs-built_in">size</span>() &amp;&amp; j != tt.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(j == tt.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(ss[i] == tt[j])<br>        &#123;<br>            <span class="hljs-comment">// 加 func(ss, tt, i + 1, j) 的原因：字符匹配上了但是不用，用后面的字符来匹配</span><br>            ans = <span class="hljs-built_in">func</span>(ss, tt, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-built_in">func</span>(ss, tt, i + <span class="hljs-number">1</span>, j); <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans = <span class="hljs-built_in">func</span>(ss, tt, i + <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; ss, vector&lt;<span class="hljs-type">char</span>&gt;&amp; tt, <span class="hljs-type">int</span> i , <span class="hljs-type">int</span> j, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// if(i == ss.size() &amp;&amp; j == tt.size()) return 1;</span><br>        <span class="hljs-comment">// if(i != ss.size() &amp;&amp; j == tt.size()) return 1;</span><br>        <span class="hljs-comment">//base case可以尝试的方向：索引分别为0和n</span><br>        <span class="hljs-keyword">if</span>(i == ss.<span class="hljs-built_in">size</span>() &amp;&amp; j != tt.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(j == tt.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(dp[i][j] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[i][j];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        ans = (ss, tt, i + <span class="hljs-number">1</span>, j, dp);<br>        <span class="hljs-keyword">if</span>(ss[i] == tt[j])<br>        &#123;<br>            ans += <span class="hljs-built_in">func2</span>(ss, tt, i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, dp);<br>        &#125;<br>        dp[i][j] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-打家劫舍系列"><a href="#2-打家劫舍系列" class="headerlink" title="2 打家劫舍系列"></a>2 打家劫舍系列</h2><h1 id="函数使用方法"><a href="#函数使用方法" class="headerlink" title="#函数使用方法"></a>#函数使用方法</h1><p>1.在vector末尾插入另一个vector的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; a;<br>vector&lt;<span class="hljs-type">int</span>&gt; b;<br><span class="hljs-comment">//实现把b的所有元素插入到a的末尾</span><br>a.<span class="hljs-built_in">insert</span>(a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
