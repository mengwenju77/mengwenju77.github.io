

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toc] 1 在main执行之前和之后执行的代码可能是什么？main函数执行之前执行的代码  全局对象初始化，在main之前调用构造函数  123456789101112131415161718192021class A&amp;#123;public:    A()    &amp;#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://example.com/2024/03/28/C++/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[toc] 1 在main执行之前和之后执行的代码可能是什么？main函数执行之前执行的代码  全局对象初始化，在main之前调用构造函数  123456789101112131415161718192021class A&amp;#123;public:    A()    &amp;#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &amp;#125;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/$%7Bfiilename%7D/image-20240326165000175.png">
<meta property="og:image" content="http://example.com/imgs/$%7Bfiilename%7D/image-20240326165233475.png">
<meta property="og:image" content="http://example.com/imgs/$%7Bfiilename%7D/image-20240326165247530.png">
<meta property="og:image" content="http://example.com/imgs/$%7Bfiilename%7D/image-20240326165431867.png">
<meta property="article:published_time" content="2024-03-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-02T05:58:06.150Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/imgs/$%7Bfiilename%7D/image-20240326165000175.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>C++ - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 20vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>文档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-28 00:00" pubdate>
          2024/03/28 12:00 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          202 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    Last updated on 2024-04-02T13:58:06+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>[toc]</p>
<h1 id="1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1 在main执行之前和之后执行的代码可能是什么？"></a>1 在main执行之前和之后执行的代码可能是什么？</h1><p><strong>main函数执行之前执行的代码</strong></p>
<ul>
<li>全局对象初始化，在main之前调用构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>A a;　　<span class="hljs-comment">//调用构造函数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;　<br>&#125;<br><br><span class="hljs-comment">//输出结果</span><br>A<br>main<br><br></code></pre></td></tr></table></figure>

<ul>
<li>将main函数的参数argc、argv传给main函数，才算真正调用main函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; 函数体 &#125;  <span class="hljs-comment">//写法1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123; 函数体 &#125; <span class="hljs-comment">//写法2</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>__attribute__((constructor))</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>__attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beforeMainToRun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>beforeMainToRun  <br>main<br></code></pre></td></tr></table></figure>

<ul>
<li>其它，暂时不理解…</li>
</ul>
<p><strong>main函数执行之后执行的代码</strong></p>
<ul>
<li>可以注册一个<code>atexit</code>函数，注册的函数会在main之后运行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-built_in">atexit</span>(func);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//执行结果</span><br>main<br>func<br><br></code></pre></td></tr></table></figure>

<ul>
<li><code>__attribute__((destructor))</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">__attribute__((destructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">afterMainToRun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>其它，如全局对象的析构函数，不理解…</li>
</ul>
<h1 id="2-内存对齐问题？"><a href="#2-内存对齐问题？" class="headerlink" title="2 内存对齐问题？"></a>2 内存对齐问题？</h1><h2 id="1-什么是内存对齐"><a href="#1-什么是内存对齐" class="headerlink" title="1 什么是内存对齐"></a><strong>1 什么是内存对齐</strong></h2><p>元素是按照声明顺序一个一个放到内存中去的，但并不是紧密排列的。元素放置的地址一定会在自己宽度的整数倍上开始，即内存对齐。</p>
<h2 id="2-为什么需要内存对齐？"><a href="#2-为什么需要内存对齐？" class="headerlink" title="2 为什么需要内存对齐？"></a><strong>2 为什么需要内存对齐？</strong></h2><p><strong>结论：</strong></p>
<ul>
<li>对齐与否会影响读取效率。</li>
<li>合理地利用对齐规则可以节省空间</li>
</ul>
<p><strong>a. 处理器是如何读取内存的？</strong></p>
<p>如果把内存看做是简单的字节数组，比如在C语言中，char *就可表示一块内存。那么它的内存读取方式可以按照1byte顺序读取：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165000175.png" srcset="/img/loading.gif" lazyload alt="image-20240326165000175"></p>
<p>然而，尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的，这取决于数据类型和处理器的设置；它一般会以双字节,4字节,8字节,16字节甚至32字节的<code>块</code>来存取内存，这些存取单位称为<code>内存存取粒度</code></p>
<p><strong>b. 内存对齐、内存不对齐对比</strong></p>
<p>现在假设一个整型变量(4字节)不是自然对齐的，它的起始地址落在0x00000002（图中蓝色区域），处理器想要访问它的值，按照4字节的块进行读取，从图中的0x0起读，读取4字节大小，读到0x3</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165233475.png" srcset="/img/loading.gif" lazyload alt="image-20240326165233475"></p>
<p>这样的一次读取之后，并不能取到要访问的整型数据，紧接着处理器会继续再往下读，偏移4个字节，从0x4开始，读到0x7</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165247530.png" srcset="/img/loading.gif" lazyload alt="image-20240326165247530"></p>
<p>到这里，处理器才能读取到了需要访问的内存数据，这中间还存在剔除与合并的过程，读了两次才读到想要的数据。</p>
<p>如果是自然对齐的：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20240326165431867.png" srcset="/img/loading.gif" lazyload alt="image-20240326165431867"></p>
<p>读取一次就能读到想要的数据。<strong>对齐与否会影响读取效率。</strong></p>
<p><strong>c. 合理地利用对齐规则可以节省空间</strong></p>
<p>比如下列情况，结构体所占的字节数为24</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-type">int</span>   a;  <span class="hljs-comment">//4</span><br>  <span class="hljs-type">double</span>  b;  <span class="hljs-comment">//8</span><br>  <span class="hljs-type">short</span> c;  <span class="hljs-comment">//2</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl;  <span class="hljs-comment">// 24</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果把b和c交换一下位置，那么结构体所占的字节数为12</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-type">int</span>   a;  <span class="hljs-comment">//4</span><br>  <span class="hljs-type">short</span> c;  <span class="hljs-comment">//2</span><br>  <span class="hljs-type">double</span>  b;  <span class="hljs-comment">//8</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl;  <span class="hljs-comment">// 12</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-内存对齐规则"><a href="#3-内存对齐规则" class="headerlink" title="3 内存对齐规则"></a>3 内存对齐规则</h2><ul>
<li>各成员变量存放的起始地址， 相对于结构体的起始地址的偏移量 ，必须为该变量的类型所占用的字节数的倍数；</li>
<li>各成员变量在存放的时候根据在结构体中声明的顺序依次申请空间， 同时按照上面的对齐方式调整位置， 空缺的字节自动填充</li>
<li>同时为了确保结构的大小为结构体的size最大成员的倍数，所以在为最后一个成员变量申请空间后 还会根据需要自动填充空缺的字节</li>
</ul>
<h3 id="4-影响内存对齐的因素"><a href="#4-影响内存对齐的因素" class="headerlink" title="4 影响内存对齐的因素"></a>4 影响内存对齐的因素</h3><p><strong>1.<code>#pragma pack(n)</code></strong></p>
<p>程序员可以通过预编译命令<code>#pragma pack(n)</code>，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是要指定的“对齐系数”。这里规定的是上界，只影响对齐单元大于n的成员，对于对齐字节不大于n的成员没有影响。</p>
<p>通过预编译命令<code>#pragma pack()</code>取消自定义字节对齐方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2) <span class="hljs-comment">//让编译器对这个结构作2字节对齐</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span><br>&#123;<br><span class="hljs-type">char</span> x1;  <span class="hljs-comment">//1</span><br><span class="hljs-type">short</span> x2; <span class="hljs-comment">//2</span><br><span class="hljs-type">float</span> x3; <span class="hljs-comment">//4</span><br><span class="hljs-type">char</span> x4; <span class="hljs-comment">//1</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack() <span class="hljs-comment">//取消1字节对齐，恢复为默认4字节对齐</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    test t;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(t) &lt;&lt; endl; <span class="hljs-comment">// 10</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2.alignas</strong></p>
<ul>
<li>C++11以后引入两个关键字 <code>alignas</code>与 <code>alignof</code>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// alignas生效的情况：设置的值大于等于size最大成员所占的字节数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">16</span>) Info2 &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// alignas失效的情况：设置的值小size最大成员所占的字节数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) Info3 &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">double</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 24  8 + 8 + 8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 8</span><br><br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 32  16 + 16</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 16</span><br>    <br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info3) &lt;&lt; std::endl;   <span class="hljs-comment">// 24  8 + 8 + 8</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info3) &lt;&lt; std::endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-number">24</span><br><span class="hljs-number">8</span><br><span class="hljs-number">32</span><br><span class="hljs-number">16</span><br><span class="hljs-number">24</span><br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6870162226032934926">https://juejin.cn/post/6870162226032934926</a></p>
</blockquote>
<h1 id="3-指针和引用的区别"><a href="#3-指针和引用的区别" class="headerlink" title="3 指针和引用的区别"></a>3 指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址；引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以为空，而引用在定义的时候必须初始化（因为引用是原变量的别名，如果没有初始化，那么引用是给谁起的名字呢？）</li>
<li>指针可以有多级，引用只有一级（指针是一个内存中的对象，向其它对象一样也有自己的地址，那么就可以有指针指向这个地址，即指向指针的指针）</li>
<li>指针在初始化之后可以改变指向，而引用在初始化之后不可改变（指针可以在初始化的时候指向某个地址，后面可以改变指向，指向另外一个地址）</li>
<li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>　　<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>　　p=&amp;a;<br>　　cout&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">test</span>(p);<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>    cout&lt;&lt;<span class="hljs-string">&quot;指针p为NULL&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果为：</span><br><span class="hljs-comment">//0x61fddc 1</span><br><span class="hljs-comment">//指针p为NULL</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPTR</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>	p = &amp;a;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testREFF</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>	p = a;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span>* b = &amp;a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;before: &quot;</span> &lt;&lt;  b &lt;&lt; endl; <span class="hljs-comment">// before: 0x61fe14</span><br>	<span class="hljs-built_in">testPTR</span>(b); <span class="hljs-comment">//相当于值传递，函数外实际上没改变指针</span><br>	cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 10</span><br>	cout &lt;&lt; *b &lt;&lt; endl;<span class="hljs-comment">// 10</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;after: &quot;</span> &lt;&lt;  b &lt;&lt; endl; <span class="hljs-comment">// after: 0x61fe14</span><br><br>	a = <span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">testREFF</span>(a);<br>	cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">//12</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h1><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* myArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];  <span class="hljs-comment">// 在堆上分配内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        myArray[i] = i * i;  <span class="hljs-comment">// 初始化数组</span><br>    &#125;<br>    <span class="hljs-comment">// 返回一个指向堆内存的指针</span><br>    <span class="hljs-keyword">return</span> myArray;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* squareArray = <span class="hljs-built_in">createArray</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        std::cout &lt;&lt; squareArray[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// 输出数组</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">delete</span>[] squareArray;  <span class="hljs-comment">// 释放数组所占的内存</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>

<ul>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式，传引用有以下特点：<ul>
<li><strong>避免拷贝</strong>：使用引用可以避免当对象作为参数传递时的潜在的拷贝操作，特别是对于大型对象，这可以显著提高性能。</li>
<li><strong>保持对原始对象的修改</strong>：如果需要在函数内部修改类对象并反映到外部的原始对象，使用引用允许你直接在原始对象上操作，而不是在其副本上操作。</li>
<li><strong>语义清晰</strong>：当通过引用传递参数时，它告诉使用函数的开发者，这个函数可能会修改传入的对象。</li>
</ul>
</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= vec.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 基线条件</span><br>    &#125;<br>    <span class="hljs-comment">// 做一些处理...</span><br>    <span class="hljs-built_in">recursiveFunction</span>(vec, index + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largeVector</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">42</span>)</span></span>; <span class="hljs-comment">// 大型向量</span><br>    <span class="hljs-built_in">recursiveFunction</span>(largeVector, <span class="hljs-number">0</span>); <span class="hljs-comment">// 通过引用传递</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="5-堆和栈的区别"><a href="#5-堆和栈的区别" class="headerlink" title="5 堆和栈的区别"></a>5 堆和栈的区别</h1><ul>
<li>申请方式不同<ul>
<li>栈是由系统自动分配</li>
<li>堆是自己申请的，比如new对象 int myArray &#x3D; new int[size];</li>
</ul>
</li>
<li>申请大小限制不同<ul>
<li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li>
<li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
</ul>
</li>
<li>申请效率不同。<ul>
<li>栈由系统分配，速度快，不会有碎片。</li>
<li>堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理方式</strong></td>
<td>堆中资源由程序员控制（容易产生memory leak）</td>
<td>栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr>
<td><strong>内存管理机制</strong></td>
<td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td>
<td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td>
</tr>
<tr>
<td><strong>空间大小</strong></td>
<td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td>
<td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）</td>
</tr>
<tr>
<td><strong>碎片问题</strong></td>
<td>对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低</td>
<td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td>
</tr>
<tr>
<td><strong>生长方向</strong></td>
<td>堆向上，向高地址方向增长。</td>
<td>栈向下，向低地址方向增长。</td>
</tr>
<tr>
<td><strong>分配方式</strong></td>
<td>堆都是动态分配（没有静态分配的堆）</td>
<td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr>
<td><strong>分配效率</strong></td>
<td>堆由C&#x2F;C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td>
<td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody></table>
<p><strong>形象的比喻</strong></p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h1 id="6-堆快还是栈快"><a href="#6-堆快还是栈快" class="headerlink" title="6 堆快还是栈快"></a>6 堆快还是栈快</h1><p>栈快</p>
<ul>
<li><p>操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率较高也比较快。</p>
</li>
<li><p>而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
</li>
</ul>
<h1 id="7-区别以下指针类型？"><a href="#7-区别以下指针类型？" class="headerlink" title="7 区别以下指针类型？"></a>7 区别以下指针类型？</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>] <span class="hljs-comment">//指针数组，强调数组概念，一共有10个变量，每个数组元素都是一个指向 int 类型数据的指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>] <span class="hljs-comment">//数组指针，强调指针概念，只有一个变量，是指针类型， 它指向一个具有10个整数的数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-comment">// 函数声明，函数名是p，参数类型是int类型，返回值是int*类型</span></span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> <span class="hljs-comment">// 函数指针，强调是指针，该指针指向的函数具有int类型参数，返回值也是int类型</span></span><br></code></pre></td></tr></table></figure>



<h1 id="8-new-delete-与-malloc-free的异同"><a href="#8-new-delete-与-malloc-free的异同" class="headerlink" title="8 new &#x2F; delete 与 malloc &#x2F; free的异同"></a>8 new &#x2F; delete 与 malloc &#x2F; free的异同</h1><p>相同点：</p>
<ul>
<li>都可用于内存的动态申请和释放</li>
</ul>
<p>不同点：</p>
<ul>
<li>new &#x2F; delete是C++运算符，malloc &#x2F; free是C&#x2F;C++语言标准库函数</li>
<li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</li>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，所以new是类型安全的。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</li>
</ul>
<h1 id="9-new和delete是如何实现的？"><a href="#9-new和delete是如何实现的？" class="headerlink" title="9 new和delete是如何实现的？"></a>9 new和delete是如何实现的？</h1><ul>
<li>new的实现过程是：<ul>
<li>首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；</li>
<li>接下来运行该类型的一个构造函数，用指定初始化构造对象；</li>
<li>最后返回指向新分配并构造后的的对象的指针</li>
</ul>
</li>
<li>delete的实现过程是：<ul>
<li>对指针指向的对象运行适当的析构函数；（编译器会自动选择合适的析构函数，析构函数可以被重载，但不建议）</li>
<li>然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li>
</ul>
</li>
</ul>
<h1 id="10-malloc和new的区别？"><a href="#10-malloc和new的区别？" class="headerlink" title="10 malloc和new的区别？"></a>10 malloc和new的区别？</h1><ul>
<li>malloc和free是标准库函数，支持重写；new和delete是运算符，支持重载。</li>
<li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li>
<li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li>
</ul>
<h1 id="11-既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？"><a href="#11-既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？" class="headerlink" title="11 既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>11 既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h1><p>在对非基本数据类型使用的时候，创建对象需要调用构造函数，销毁对象需要调用析构函数，而malloc&#x2F;free不具备调用构造函数&#x2F;析构函数的功能，所以需要new&#x2F;delete来调用构造&#x2F;析构函数</p>
<h1 id="12-被free回收的内存是立即返还给操作系统吗？"><a href="#12-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="12 被free回收的内存是立即返还给操作系统吗？"></a>12 被free回收的内存是立即返还给操作系统吗？</h1><p>不是的，内存通常会被添加到可用内存池中，并由程序的内存管理系统维护。</p>
<p>这些内存可能在之后的内存分配中再次被使用，以避免频繁地向操作系统请求内存。</p>
<p>当程序结束时，这些内存才会被彻底返回给操作系统。</p>
<p>同时，ptmalloc会尝试把小块的内存合并，避免过多的内存碎片</p>
<h1 id="13-define和函数有何区别？"><a href="#13-define和函数有何区别？" class="headerlink" title="13 define和函数有何区别？"></a>13 define和函数有何区别？</h1><ul>
<li>处理时机不同<ul>
<li>宏在预处理阶段完成替换，运行时不存在函数调用，执行起来更快</li>
<li>函数需要等待后面的编译–汇编–链接操作，最终变成可执行文件</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//替换前</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> p() printf(<span class="hljs-string">&quot;macro\n&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">p</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//替换后</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>安全性不同<ul>
<li>有参宏函数在传参的时候也只是简单的参数替换，不涉及类型</li>
<li>不同函数的形参有类型限制，所以更加安全一点，如果参数不合法，编译的时候就会体现</li>
</ul>
</li>
<li>宏定义属于在结构中插入代码，没有返回值，函数调用具有返回值</li>
</ul>
<h1 id="14-define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#14-define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="14 define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>14 define、const、typedef、inline的使用方法？他们之间有什么区别？</h1><p><strong>define和typedef区别</strong></p>
<ul>
<li>typedef主要用于类型别名，#define不只是可以为类型取别名，还可以定义常量、变量等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 有两种方法可以定义类型别名：</span><br><span class="hljs-comment">//方法一：typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;	<span class="hljs-comment">// wages 是 double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base;		<span class="hljs-comment">// base 是double 的同义词</span><br><br><span class="hljs-comment">//方法二（新标准）：别名声明</span><br><span class="hljs-keyword">using</span> SI = <span class="hljs-type">int</span>	<span class="hljs-comment">// SI 是 int 的同义词</span><br>    <br><span class="hljs-comment">// 类型别名和类型的名字等价，有类型的名字出现的地方，都可以替换为别名</span><br>wages hourly, weekly <span class="hljs-comment">// 等价于 double houtly, weekly</span><br>SI item		<span class="hljs-comment">//等价于 int item</span><br><br>    <br><span class="hljs-comment">// 宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 99</span><br></code></pre></td></tr></table></figure>

<ul>
<li>宏替换发生在预处理阶段，而typedef发生在编译阶段</li>
<li>宏定义不检查数据类型，typedef要检查数据类型</li>
<li>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</li>
<li>宏不是语句，不在最后面添加分号，typedef是语句，要以分号结束</li>
</ul>
<p><strong>define和const的区别</strong></p>
<p>编译阶段</p>
<ul>
<li>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、链接的时候起作用</li>
</ul>
<p>安全性</p>
<ul>
<li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li>
<li>const常量有数据类型，编译器可以对其进行类型安全检查</li>
</ul>
<p>内存占用</p>
<ul>
<li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份</li>
</ul>
<p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p>
<p><strong>define和inline的区别</strong></p>
<ul>
<li>宏在预编译时进行，只做简单的字符串替换，内联函数可以做参数类型检查</li>
<li>内联函数在编译时直接将函数代码嵌入到函数调用处，省去了函数调用的开销来提高执行效率，可以实现重载</li>
</ul>
<h1 id="15-声明变量和定义的区别"><a href="#15-声明变量和定义的区别" class="headerlink" title="15 声明变量和定义的区别"></a>15 声明变量和定义的区别</h1><ul>
<li>变量只能在一处定义，但是可以在多处声明<ul>
<li>声明：一个文件如果想使用其它地方定义的变量，就必须声明它</li>
<li>定义：定义负责创建与名字关联的实体</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i <span class="hljs-comment">// 声明i并非定义i</span><br><span class="hljs-type">int</span> j		<span class="hljs-comment">// 声明并定义j</span><br></code></pre></td></tr></table></figure>

<ul>
<li>任何包含了显示初始化的声明即成为了定义，能给 <code>extern</code>修饰的变量赋一个初始值，但这也抵消了<code>entern</code>的作用，将其变成了一个定义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;	<span class="hljs-comment">// 定义</span><br></code></pre></td></tr></table></figure>



<h1 id="16-strlen和sizeof的区别"><a href="#16-strlen和sizeof的区别" class="headerlink" title="16 strlen和sizeof的区别"></a>16 strlen和sizeof的区别</h1><ul>
<li><code>sizeof</code>是运算符不是函数，<code>strlen</code>是字符处理的库函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sizeof用法</span><br><span class="hljs-comment">// sizeof运算符返回一条表达式或一个类型名字所占的字节数</span><br><span class="hljs-built_in">sizeof</span>(type)  <br><span class="hljs-keyword">sizeof</span> express   <span class="hljs-comment">// 返回表达式结果类型的大小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> a, *p;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> a &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> p &lt;&lt; endl; <span class="hljs-comment">// 8  指针p的大小</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span> *p &lt;&lt; endl; <span class="hljs-comment">// 1  p所指向的对象的类型大小，即char的大小</span><br>&#125;<br>    <br><span class="hljs-comment">// strlen用法</span><br><span class="hljs-comment">// strlen 是一个用来计算字符串长度的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(str)); <span class="hljs-comment">//8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">strlen</span>(str)); <span class="hljs-comment">//6 取的是这个字符串的长度，不包含结尾的 \0。大小是6</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)); <span class="hljs-comment">// 7 ，包含结尾的\0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>sizeof</code>参数可以是任何数据类型或者数据；<code>strlen</code> 的参数只能是字符指针</p>
</li>
<li><p><code>sizeof</code>的值在编译时确定。</p>
</li>
</ul>
<h1 id="17-一个指针占多少字节？"><a href="#17-一个指针占多少字节？" class="headerlink" title="17 一个指针占多少字节？"></a>17 一个指针占多少字节？</h1><ul>
<li>64位的编译环境下的指针的占用大小为8字节</li>
<li>32位的编译环境下的指针的占用大小为4字节</li>
</ul>
<h1 id="18-常量指针和指针常量的区别"><a href="#18-常量指针和指针常量的区别" class="headerlink" title="18 常量指针和指针常量的区别"></a>18 常量指针和指针常量的区别</h1><ul>
<li>常量指针：指针本身是不可变的，即指向的地址不能改变，但指向的内容可以改变。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;value; <span class="hljs-comment">// ptr是一个常量指针</span><br>*ptr = <span class="hljs-number">6</span>; <span class="hljs-comment">// 合法，可以改变ptr指向的值</span><br>ptr = &amp;some_other_value; <span class="hljs-comment">// 非法，ptr的值不能改变</span><br></code></pre></td></tr></table></figure>

<ul>
<li>指针常量：指针指向的内容是不可变的，即指向的值不能改变，但指针本身可以改变指向其他内容。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>* ptr_to_const = &amp;value; <span class="hljs-comment">// ptr_to_const是一个指针常量</span><br>*ptr_to_const = <span class="hljs-number">6</span>; <span class="hljs-comment">// 非法，不能改变指向的内容</span><br>ptr_to_const = &amp;some_other_value; <span class="hljs-comment">// 合法，可以改变ptr_to_const的值</span><br></code></pre></td></tr></table></figure>



<h1 id="19-a和-a有什么区别"><a href="#19-a和-a有什么区别" class="headerlink" title="19 a和&amp;a有什么区别"></a>19 a和&amp;a有什么区别</h1><ul>
<li><code>a</code> 是一个变量，代表该变量存储的值。</li>
<li><code>&amp;a</code> 是取地址操作符，用于获取变量 <code>a</code> 的内存地址。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// a是变量名，值为5</span><br><span class="hljs-comment">// &amp;a是a在内存中的地址</span><br></code></pre></td></tr></table></figure>



<h1 id="20-C-中struct和class的区别"><a href="#20-C-中struct和class的区别" class="headerlink" title="20 C++中struct和class的区别"></a>20 C++中struct和class的区别</h1><p><strong>相同点</strong></p>
<ul>
<li>两者都拥有成员函数、公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承， 而struct默认是public继承</li>
</ul>
<h1 id="21-printf函数的实现原理"><a href="#21-printf函数的实现原理" class="headerlink" title="21 printf函数的实现原理"></a>21 printf函数的实现原理</h1><h1 id="22-C-的顶层const和底层const"><a href="#22-C-的顶层const和底层const" class="headerlink" title="22 C++的顶层const和底层const"></a>22 C++的顶层const和底层const</h1><ul>
<li>顶层const：指针本身是一个常量（常量指针，就是 * 号的右边），指针本身不能修改指向别的地址，但是所指的对象的值可以修改</li>
<li>底层const：指针所指的对象是一个常量（指针常量，就是 * 号的左边），指针所指的对象不能修改，但是指针可以指向别的地址</li>
</ul>
<h1 id="23-static关键字"><a href="#23-static关键字" class="headerlink" title="23 static关键字"></a>23 static关键字</h1><p><strong>static成员变量：</strong></p>
<ul>
<li><p>类的所有对象共用一份数据</p>
</li>
<li><p>在编译阶段分配内存</p>
</li>
<li><p>在类内声明，类外初始化</p>
<ul>
<li>原因：因为静态成员属于整个类，而不属于某个对象，如果在类内进行初始化，会导致每个对象都包含该静态成员，这是矛盾的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>static成员常量：</strong></p>
<p>可以在类内声明，类外初始化。也可以在类内定义的时候直接初始化（因为是常量，在类内初始化时对象也无法改变其值），但是不能使用成员初始化列表进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类内声明，类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num; <span class="hljs-comment">// 类内声明</span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 类外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br><br><span class="hljs-comment">// 类内直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b.m_num);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>static成员函数：</strong></p>
<ul>
<li>static成员函数只能访问static成员变量，访问不了非静态成员变量</li>
<li>类的所有对象都可以访问static成员函数</li>
</ul>
<h1 id="24-C-从代码到可执行程序经历了什么"><a href="#24-C-从代码到可执行程序经历了什么" class="headerlink" title="24 C++从代码到可执行程序经历了什么"></a>24 C++从代码到可执行程序经历了什么</h1><p><strong>预编译</strong></p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p>
<ul>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li>
<li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</li>
</ul>
<p><strong>编译</strong></p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ul>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。</li>
</ul>
<p><strong>汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没 有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过 来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p>
<p><strong>链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ul>
<li>静态链接</li>
</ul>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快</p>
<ul>
<li>动态链接</li>
</ul>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h1 id="25-构造函数与析构函数"><a href="#25-构造函数与析构函数" class="headerlink" title="25 构造函数与析构函数"></a>25 构造函数与析构函数</h1><p><strong>构造函数：</strong>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</p>
<p><strong>析构函数：</strong>主要作用在于对象销毁前系统自动调用，执行一些清理工作</p>
<p><strong>构造函数的语法：</strong><code>类名()&#123;&#125;</code></p>
<ul>
<li>构造函数没有返回值也不写void</li>
<li>函数名称与类型相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在创建对象时候会自动调用构造函数，无须手动调用，而且只会调用一次</li>
</ul>
<p><strong>析构函数的语法：</strong><code>~类名()&#123;&#125;</code></p>
<ul>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类型相同，在名称前面加上符号 <code>~</code></li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Person p;   <span class="hljs-comment">// 创建对象调用构造函数</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    				<span class="hljs-comment">// return 0 之前也就是函数结束之前也就是对象销毁前，调用析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br>constructor<br>请按任意键继续. . . <br>destructor <br><br></code></pre></td></tr></table></figure>

<h1 id="26-构造函数的分类及调用"><a href="#26-构造函数的分类及调用" class="headerlink" title="26 构造函数的分类及调用"></a>26 构造函数的分类及调用</h1><p>两种分类方式：</p>
<ul>
<li>按参数分为：有参构造和无参构造</li>
<li>按类型分为：普通构造和拷贝构造</li>
</ul>
<p>三种调用方式：括号法、显示法、隐式转换法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无参构造（默认构造）</span><br>    <span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parameterless construction&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>    &#123;<br>        age = age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parametric construction&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//拷贝构造</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)<br>    &#123;<br>        age = p.age;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用方法：括号法</span><br>    <span class="hljs-comment">// Person p1;</span><br>    <span class="hljs-comment">// Person p2(10);</span><br>    <span class="hljs-comment">// Person p3(p2);</span><br><br>    <span class="hljs-comment">// 调用方法：显示法</span><br>    <span class="hljs-comment">// Person p4 = Person(10); // 有参构造</span><br>    <span class="hljs-comment">// Person p5 = Person(p4); // 拷贝构造</span><br>    <span class="hljs-comment">// Person(10); // 匿名对象，在执行完此行后会立即释放内存</span><br><br>    <span class="hljs-comment">// 调用方法：隐式转换</span><br>    Person p6 = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 相当于Person p4 = Person(10);</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="27-深拷贝和浅拷贝的区别"><a href="#27-深拷贝和浅拷贝的区别" class="headerlink" title="27 深拷贝和浅拷贝的区别"></a>27 深拷贝和浅拷贝的区别</h1><p>在有指针的情况下，</p>
<ul>
<li><p>浅拷贝只是增加了一个指针指向已经存在的内容</p>
</li>
<li><p>深拷贝就是增加一个指针，并且申请一块新的内存，使这个增加的指针指向这个新的内存</p>
</li>
</ul>
<p>采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height)<br>    &#123;<br>        m_Age = age;<br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height);  <span class="hljs-comment">// 在堆区开辟的内存，由程序员手动开辟和释放（在析构函数中释放）</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parametric construction&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自己实现拷贝构造，解决浅拷贝带来的问题</span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)  <br>    &#123;<br>        m_Age = p.m_Age;<br>        <span class="hljs-comment">// m_height = p.m_height;  不写这行</span><br>        <span class="hljs-comment">// 深拷贝操作</span><br>        m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_height); <span class="hljs-comment">// 自己的成员m_height 指向新开辟的内存，存放的内容就是解引用之后*p.m_height的值</span><br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Person</span>()<br>    &#123;<br>        <span class="hljs-comment">// 析构代码，将堆区开辟的数据做释放操作</span><br>        <span class="hljs-keyword">if</span>(m_height != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> m_height;<br>            m_height = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;destructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_Age;<br>    <span class="hljs-type">int</span> *m_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">160</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1 age: &quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="hljs-string">&quot;, height: &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <br>    cout &lt;&lt; <span class="hljs-string">&quot;p2 age: &quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="hljs-string">&quot;, height: &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br>Parametric construction<br>p1 age: <span class="hljs-number">18</span>, height: <span class="hljs-number">160</span><br>p2 age: <span class="hljs-number">18</span>, height: <span class="hljs-number">160</span><br>destructor  <br><span class="hljs-comment">// 程序在调用完第一个析构函数后崩溃，原因是 p2调用的是默认的拷贝构造函数，也就是相当于下面的代码：</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person &amp;p)<br>&#123;<br>    m_Age = p.m_Age;<br>    m_height = p.m_height;  <span class="hljs-comment">// 本行会导致指向堆区开辟的指针与原指针p1的m_height指向同一个地址，那么一个指针执行了释放操作后，就会导致另一个指针指向空。</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="28-vector相关"><a href="#28-vector相关" class="headerlink" title="28 vector相关"></a>28 vector相关</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h2><ul>
<li>默认构造</li>
<li>通过区间方式构造</li>
<li>指定n个元素及其值构造</li>
<li>拷贝构造</li>
<li>还有其它的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">include&lt;vector&gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 默认构造</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br>    <span class="hljs-comment">// 通过区间方式构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;<br><br>    <span class="hljs-comment">// 指定n个元素及其值构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br><br>    <span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a><strong>赋值操作</strong></h2><ul>
<li>用操作符 <code>=</code> 赋值</li>
<li>assign(begin, end);</li>
<li>assign(n, elem);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v);<br><br>    <span class="hljs-comment">// 使用操作符 = 赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;  <br>    v1 = v; <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">// assign(begin, end)赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    v2.<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">// assign(n, elem)赋值</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>    v3.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// 100 100 100 100 100 100 100 100 100 100</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h2><ul>
<li><code>empty();</code>		判断容器是否为空</li>
<li><code>capactiy()</code>     容器的容量</li>
<li><code>size()</code>            返回容器中元素的个数</li>
<li><code>resize(num)</code>   重新指定容器的长度为num，如果容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</li>
<li><code>resize(int num, elem)</code>   重新指定容器的长度为num，如果容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-comment">// empty();	// 判断容器是否为空</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// capacity()  // 返回容器的容量</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 10</span><br><br>    <span class="hljs-comment">// 重新指定容器的长度为num，如果容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 5</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4</span><br><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">8</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 0 0 0</span><br><br>	<span class="hljs-comment">// 重新指定容器的长度为num，如果容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度num的元素被删除</span><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;  <span class="hljs-comment">// 16</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl;  <span class="hljs-comment">// 8</span><br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 0 0 0 1 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p><code>push_back(ele)</code>		&#x2F;&#x2F; 尾部插入元素ele</p>
<p><code>pop_back()</code>				&#x2F;&#x2F; 删除最后一个元素</p>
<p><code>insert(const_iterator pos, ele)</code>		&#x2F;&#x2F; 迭代器指向位置pos插入元素ele</p>
<p><code>insert(const_iterator pos, int count, ele)</code> 	&#x2F;&#x2F; 迭代器指向位置pos插入count个元素ele</p>
<p><code>erase(const_iterator pos)</code>	&#x2F;&#x2F; 删除迭代器指向的元素</p>
<p><code>erase(const_iterator start, const_iterator end)</code>		&#x2F;&#x2F; 删除迭代器从start到end之间的元素</p>
<p><code>clear()</code> &#x2F;&#x2F; 删除容器中所有的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    v.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">88</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 88 0 1 2 3 4 5 6 7 8 </span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">99</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 88 0 1 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 100 88 0 1 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 100 88 0 1 100 100 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 88 0 1 100 100 2 3 4 5 6 7 8 99</span><br><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 100 88 1 100 100 2 3 4 5 6 7 8 99 </span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h2><p><code>at(int idx);</code> 	&#x2F;&#x2F;返回索引idx所指的数据</p>
<p><code>operator[];</code>		&#x2F;&#x2F;重载的中括号，返回索引idx所指的数据</p>
<p><code>front();</code>			&#x2F;&#x2F; 返回容器中第一个元素</p>
<p><code>back()</code> 				&#x2F;&#x2F; 返回容器中最后一个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector_Int</span>(v); <span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9 </span><br><br>    <span class="hljs-comment">//返回索引idx所指的数据</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 重载的中括号，返回索引idx所指的数据</span><br>    cout &lt;&lt; v[<span class="hljs-number">2</span>] &lt;&lt; endl; <span class="hljs-comment">// 2</span><br><br>    <span class="hljs-comment">// 返回容器中第一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">front</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// 返回容器中最后一个元素</span><br>    cout &lt;&lt; v.<span class="hljs-built_in">back</span>() &lt;&lt; endl; <span class="hljs-comment">// 9</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="互换容器"><a href="#互换容器" class="headerlink" title="互换容器"></a>互换容器</h2><p><code>swap(vec)</code> 	&#x2F;&#x2F; 将vec与本身的元素互换，用途可以收缩内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;before: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 16384, size: 10000</span><br><br>    v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;after resize: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 16384, size: 3</span><br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v).<span class="hljs-built_in">swap</span>(v);  <span class="hljs-comment">// vector&lt;int&gt;(v) 匿名对象  .swap(v) 容器交换，之后匿名对象的内存空间被自动释放</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;after swap: &quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;capacity: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;, size: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// capacity: 3, size: 3  </span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间"></a>预留空间</h2><p><code>reserve(int len);</code> 	容器预留len个元素长度，预留位置不初始化，元素不可访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开辟内存空间的次数</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])<br>        &#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl; <span class="hljs-comment">// num = 18;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开辟内存空间的次数</span><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>    &#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])<br>        &#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>     <br>    cout &lt;&lt; <span class="hljs-string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;  <span class="hljs-comment">// num = 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="30-野指针和悬空指针"><a href="#30-野指针和悬空指针" class="headerlink" title="30 野指针和悬空指针"></a>30 野指针和悬空指针</h1><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
<ul>
<li>野指针：指的是未初始化过的指针，未初始化就被调用<ul>
<li>产生原因：指针变量未初始化</li>
<li>解决方法：将指针变量初始化或者置空</li>
</ul>
</li>
<li>悬空指针：指针最初指向的内存已经被释放的一种指针<ul>
<li>产生原因：指针free或者delete之后没有及时置空</li>
<li>解决方法：释放操作后立即置空</li>
</ul>
</li>
</ul>
<h1 id="31-拷贝初始化和直接初始化"><a href="#31-拷贝初始化和直接初始化" class="headerlink" title="31 拷贝初始化和直接初始化"></a>31 拷贝初始化和直接初始化</h1><ul>
<li>直接初始化直接调用与实参匹配的构造函数</li>
<li>拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象上</li>
</ul>
<h1 id="32-赋值和初始化的区别"><a href="#32-赋值和初始化的区别" class="headerlink" title="32 赋值和初始化的区别"></a>32 赋值和初始化的区别</h1><p>简单理解：</p>
<ul>
<li>初始化就是在创建对象时赋值</li>
<li>赋值是创建对象后再赋值</li>
</ul>
<h1 id="33-虚函数和纯虚函数"><a href="#33-虚函数和纯虚函数" class="headerlink" title="33 虚函数和纯虚函数"></a>33 虚函数和纯虚函数</h1><p>强调一个概念：</p>
<ul>
<li>定义一个函数为虚函数是为了允许用基类的指针或者引用指向子类对象</li>
<li>定义一个函数为纯虚函数是为了实现一个接口，起到一个规范的作用</li>
</ul>
<p>虚函数是被virtual关键字修饰的函数，应在派生类中重写的成员函数，当某个虚函数通过指针或者引用调用时，编译器产生的代码直到运行时才能确定到底要调用哪个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 下面这段代码首先定义了一个Animal1，该类有一个speak() 函数，不是虚函数；之后定义了一个Cat继承Animal1类；然后定义了一个doSpeak1()函数，入参为Animal1类的引用，输出结果是 Animal Speak 而不是 Cat Speak</span><br><span class="hljs-comment">2. 定义了一个Animal2类，该类有一个speak() 函数，是虚函数，之后定义了一个Dog继承Animal2类；然后定义了一个doSpeak2()函数，入参为Animal2类的引用，输出结果是Dog Speak</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal1 Speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal2 Speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span>  Animal1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat Speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog Speak&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak1</span><span class="hljs-params">(Animal1&amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak2</span><span class="hljs-params">(Animal2&amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Cat cat;<br>    <span class="hljs-built_in">doSpeak1</span>(cat);<br><br>    Dog dog;<br>    <span class="hljs-built_in">doSpeak2</span>(dog);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//  输出结果</span><br>Animal1 Speak<br>Dog Speak<br></code></pre></td></tr></table></figure>

<p>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p><strong>纯虚函数</strong></p>
<p>在多态中，通常父类的虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名（参数列表）= 0；</code></p>
<p>当类有了一个纯虚函数，这个类也称为抽象类</p>
<p>抽象类特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p>引入原因：</p>
<ul>
<li><p>为了方便使用多态特性，我们常常需要在基类中定义虚函数。</p>
</li>
<li><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 报错，不允许使用抽象类类型Son对象，即Base为抽象类的话，其子类继承Base，如果不重写父类中的纯虚函数的话，自己也变成了抽象类，无法实例化</span><br>    Base * b = <span class="hljs-keyword">new</span> Son;<br>    b-&gt;<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ==========正确的写法============</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 父类指针指向子类对象</span><br>    Base * b = <span class="hljs-keyword">new</span> Son;<br>    b-&gt;<span class="hljs-built_in">func</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="34-友元"><a href="#34-友元" class="headerlink" title="34 友元"></a>34 友元</h1><p>友元的目的就是让一个函数或者类访问另一个类中私有成员，实现数据共享，节省开销</p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<p>注意点：</p>
<ul>
<li>友元关系不能被继承</li>
<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ul>
<p><strong>全局函数做友元：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Building * build)</span></span>;  <span class="hljs-comment">// 将func声明为友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Building * build)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; build-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; build-&gt;bedRoom &lt;&lt; endl; <span class="hljs-comment">// 报错，不可访问， 如果想让全局函数func访问Building类的私有成员，需要将func设置为友元函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Building build;<br>    <span class="hljs-built_in">func</span>(&amp;build);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>类做友元：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span>; <span class="hljs-comment">// 将Visit类作为Building的友元类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Visit</span>() <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>        building = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Building</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br>    Building * building;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;bedRoom &lt;&lt; endl;  <span class="hljs-comment">// 报错，不可访问，如果想访问需要将Visit类作为Building的友元类</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Visit visit;<br>    visit.<span class="hljs-built_in">visit</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>成员函数做友元</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Visit</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Visit</span>(); <span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>;<br>    Building * building;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Building</span>()<br>    &#123;<br>        livingRoom = <span class="hljs-string">&quot;living_room&quot;</span>;<br>        bedRoom = <span class="hljs-string">&quot;bed_room&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    string livingRoom;<br><br><span class="hljs-keyword">private</span>:<br>    string bedRoom;<br>&#125;;<br><br>Visit::<span class="hljs-built_in">Visit</span>() <span class="hljs-comment">// Visit的构造函数</span><br>&#123;<br>    building = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Building</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit &quot;</span> &lt;&lt; building-&gt;bedRoom &lt;&lt; endl;  <span class="hljs-comment">// 报错，不可访问，如果想访问需要将成员函数visit作为Building的友元函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Visit::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit2 &quot;</span> &lt;&lt; building-&gt;livingRoom &lt;&lt; endl;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;visit2 &quot; &lt;&lt; building-&gt;bedRoom &lt;&lt; endl; // 报错，不可访问，如果想访问需要将成员函数visit2作为Building的友元函数</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Visit visit;<br>    visit.<span class="hljs-built_in">visit</span>();<br>    visit.<span class="hljs-built_in">visit2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="36-重载、重写"><a href="#36-重载、重写" class="headerlink" title="36 重载、重写"></a>36 重载、重写</h1><ul>
<li>重载：指函数名相同，参数列表不同</li>
<li>重写：是指派生类重写基类的函数<ul>
<li>与基类有相同的参数个数</li>
<li>与基类有相同的参数类型</li>
<li>与基类有相同的返回值类型</li>
</ul>
</li>
</ul>
<h1 id="37-cout和printf有什么区别"><a href="#37-cout和printf有什么区别" class="headerlink" title="37 cout和printf有什么区别"></a>37 cout和printf有什么区别</h1><h1 id="38-public、protected和private访问权限"><a href="#38-public、protected和private访问权限" class="headerlink" title="38 public、protected和private访问权限"></a>38 public、protected和private访问权限</h1><ul>
<li>public的变量和函数在类的内部外部都可以访问。</li>
<li>protected的变量和函数只能在类的内部和其派生类中访问。</li>
<li>private修饰的元素只能在类内访问。</li>
</ul>
<table>
<thead>
<tr>
<th>访问权限</th>
<th>外部</th>
<th>派生类</th>
<th>内部</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>private</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 类内访问</span></span><br><span class="hljs-function">    </span>&#123;<br>        a = <span class="hljs-number">1</span>;<br>        b = <span class="hljs-number">2</span>;<br>        c = <span class="hljs-number">3</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;func called&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 类外只能访问func()和成员变量a</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a.a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="39-public、protected和private继承权限"><a href="#39-public、protected和private继承权限" class="headerlink" title="39 public、protected和private继承权限"></a>39 public、protected和private继承权限</h1><p><strong>public继承</strong></p>
<p>基类的公有成员成员和保护成员成员作为派生类的成员时，都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p>
<p><strong>protected继承</strong></p>
<p>基类的公有成员和保护成员都作为派生类的保护成员，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p>
<p><strong>private继承</strong></p>
<p>基类的公有成员和保护成员都作为派生类的私有成员，并不被它的派生类访问，而基类的私有成员仍然是私有的，不能被这个派生类及其子类访问</p>
<h1 id="40-什么情况下会调用拷贝构造函数"><a href="#40-什么情况下会调用拷贝构造函数" class="headerlink" title="40 什么情况下会调用拷贝构造函数"></a>40 什么情况下会调用拷贝构造函数</h1><ul>
<li>用类的一个实例化对象去初始化另外一个对象的时候</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>() &#123;&#125;;  <span class="hljs-comment">// 默认构造函数</span><br>	<span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)  <span class="hljs-comment">// 拷贝构造函数</span><br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;copy constructor is called&quot;</span> &lt;&lt; endl;<br>	&#125;;<br>	~<span class="hljs-built_in">A</span>() &#123;&#125;;  <span class="hljs-comment">// 析构函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useClassA</span><span class="hljs-params">(A a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	A a1;<br>	A a2 = a1;  <span class="hljs-comment">//调用拷贝构造函数,对应情况1</span><br>	<span class="hljs-built_in">useClassA</span>(a1);<span class="hljs-comment">//调用拷贝构造函数，对应情况2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="41-静态变量什么时候初始化"><a href="#41-静态变量什么时候初始化" class="headerlink" title="41 静态变量什么时候初始化"></a>41 静态变量什么时候初始化</h1><ul>
<li>全局变量、静态类成员变量在编译时进行前初始化；</li>
<li>局部变量中的静态变量在第一次调用时初始化。</li>
</ul>
<h1 id="42-数据类型所占的字节数"><a href="#42-数据类型所占的字节数" class="headerlink" title="42 数据类型所占的字节数"></a>42 数据类型所占的字节数</h1><table>
<thead>
<tr>
<th>类型</th>
<th>32位操作系统（字节数）</th>
<th>64位操作系统（字节数）</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<h1 id="43-const关键字的作用有哪些"><a href="#43-const关键字的作用有哪些" class="headerlink" title="43 const关键字的作用有哪些?"></a>43 const关键字的作用有哪些?</h1><ul>
<li>修饰变量。防止一个变量的值被改变</li>
<li>修饰指针。对指针来说，如果指针本身为const，那么指针便不能改变其指向</li>
<li>修饰形参。在一个函数声明中，const可以修饰形参，表示该参数在函数中不能被改变</li>
</ul>
<h1 id="44-什么是类的继承"><a href="#44-什么是类的继承" class="headerlink" title="44 什么是类的继承"></a>44 什么是类的继承</h1><ul>
<li>继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的成员属性和方法，被称为子类或者派生类，被继承的类被称为父类或者基类</li>
<li>子类对象可以当作父类对象使用</li>
</ul>
<p>如果子类中自己定义了析构函数，那么在销毁对象时会调用自己的析构函数。</p>
<p>如果子类中没有定义析构函数，那么子类会自动继承父类的析构函数，这样，子类在销毁对象时会先调用自己的析构函数，再调用父类的析构函数</p>
<h1 id="45-多态的底层原理"><a href="#45-多态的底层原理" class="headerlink" title="45 多态的底层原理"></a>45 多态的底层原理</h1><h1 id="46-值传递、指针传递、引用传递的区别和效率"><a href="#46-值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46 值传递、指针传递、引用传递的区别和效率"></a>46 值传递、指针传递、引用传递的区别和效率</h1><ul>
<li>值传递：有形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：本质上是值传递。向函数所属的栈拷贝指针，指针指向是实参的地址</li>
<li>引用传递：被调函数的形参也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">valuePass</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">valuePass</span>(num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 50，因为值传递不会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 指针传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pointerPass</span><span class="hljs-params">(<span class="hljs-type">int</span>* x)</span> </span>&#123;<br>    *x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">pointerPass</span>(&amp;num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 100，因为指针传递会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">referencePass</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    x = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">referencePass</span>(num);<br>    cout &lt;&lt; num;  <span class="hljs-comment">// 输出为 100，因为引用传递会改变原始变量的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在值传递中，函数得到参数的一个副本，在函数内部对副本的修改不会影响原始变量。而在引用传递和指针传递中，函数得到的是原始变量的引用或指针，因此函数内部对变量的修改会影响原始变量的值。</p>
<h1 id="47-形参与实参？"><a href="#47-形参与实参？" class="headerlink" title="47 形参与实参？"></a>47 形参与实参？</h1><ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 </li>
<li>实参和形参在数量上，类型上，顺序上应严格一致。</li>
<li>值传递时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束时形参被释放，实参内容不会改变。</li>
</ul>
<h1 id="48-创建对象时内存区发生了什么"><a href="#48-创建对象时内存区发生了什么" class="headerlink" title="48 创建对象时内存区发生了什么"></a>48 创建对象时内存区发生了什么</h1><p>C++中利用<code>new</code>操作符在堆区开辟内存</p>
<p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符<code>delete</code></p>
<p>语法：<code>new 数据类型</code></p>
<p>利用<code>new</code>创建的数据，会返回该数据类型对应类型的<strong>指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">// 创建一个整型变量，返回一个整型指针。在堆区开辟一块内存，用于存放10，在栈种开辟一块内存，存放指针，指向堆区的内存</span><br>    cout &lt;&lt; *a &lt;&lt; endl; <span class="hljs-comment">// 10， 对指针解引用，堆区内存种的值</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0x1e1600，	指针保存的值，即指针所指向的堆中的地址</span><br>	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针本身在栈中的地址</span><br>    <br>    <span class="hljs-keyword">delete</span> a;	<span class="hljs-comment">// delete 释放的是堆中的内存</span><br>    cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针本身在栈中所栈的内存没有变，也没有释放，</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0x1e1600， 指针所指向的堆中的内存地址没有变，只是现在被释放了</span><br>    <br>    a =<span class="hljs-literal">nullptr</span>;<br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 0  ，现在指针所指向的堆中的内存为0</span><br>    cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x61fe18， 指针所在的栈中的内存没有变，也没有释放，栈中的内存会在程序运行结束后系统自动释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="49-类成员初始化方式？"><a href="#49-类成员初始化方式？" class="headerlink" title="49 类成员初始化方式？"></a>49 类成员初始化方式？</h1><ul>
<li>赋值初始化，即构造函数内赋值，如果<code>x</code>和<code>y</code>是内置类型，二者没区别，如果是其它自定义类类型，在进入构造函数之前，会先调用该类的默认构造函数，再进行一次赋值的操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <br>    &#123;<br>        x = a;<br>        y = b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>列表初始化，纯粹的赋值操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="50-const-char-与string之间的关系"><a href="#50-const-char-与string之间的关系" class="headerlink" title="50 const char* 与string之间的关系"></a>50 const char* 与string之间的关系</h1><p><code>string</code>是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用<code>const char*</code>给<code>string</code>类初始化</p>
<p><code>string</code>可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间<code>(2*n)</code>，然后将原字符串拷贝过去，并加上新增的内容。</p>
<p>转换方式如下：转成<code>char*</code> 的时候都是用<code>char*</code> 指向一个字符数组，转成 <code>const char*</code>的时候，就是一个字符串</p>
<p><strong>string 转 const char</strong>*：使用<code>c_str()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* c = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure>

<p><em><em>const char</em> 转string</em>*：直接转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* c = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(c)</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>string 转 char</strong>*</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">char</span>* c = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(c, s.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure>

<p><strong>char*转 string</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* c = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(c)</span></span>;<br></code></pre></td></tr></table></figure>

<p><em><em>const char</em> 转 char</em>**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpc = <span class="hljs-string">&quot;abc&quot;</span>; <br><span class="hljs-type">char</span>* pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cpc)+<span class="hljs-number">1</span>]; <br><span class="hljs-built_in">strcpy</span>(pc,cpc);<br></code></pre></td></tr></table></figure>

<p><em><em>char</em> 转 const char</em>**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* pc = “abc”; <br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpc = pc;<br></code></pre></td></tr></table></figure>



<h1 id="51-什么是内存泄露，如何避免"><a href="#51-什么是内存泄露，如何避免" class="headerlink" title="51 什么是内存泄露，如何避免"></a>51 什么是内存泄露，如何避免</h1><p><strong>内存泄漏：</strong></p>
<p>一般常说的内存泄漏是指堆内存的泄漏。如果程序中分配了内存空间但未释放，这些内存空间将被程序持有，直到程序结束时才会被释放，这可能导致系统中的可用内存逐渐减少，最终耗尽系统资源。这称为内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memoryLeakExample</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 分配内存空间</span><br>    <span class="hljs-comment">// 这里发生了某些条件下的提前返回或异常，导致未释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>new</code> 运算符为 <code>ptr</code> 分配了内存，但在函数返回之前未使用 <code>delete</code> 运算符释放这块内存。如果函数在中间的某个点提前返回，那么这块内存将无法被释放，从而导致内存泄漏。</p>
<p><strong>避免内存泄漏</strong></p>
<ul>
<li>对象数组的释放一定要用<code>delete []</code></li>
<li>有<code>new</code>就有<code>delete</code>，有<code>malloc</code>就有<code>free</code>，保证它们一定成对出现</li>
</ul>
<h1 id="52-面向对象的三大特征"><a href="#52-面向对象的三大特征" class="headerlink" title="52 面向对象的三大特征"></a>52 面向对象的三大特征</h1><p>封装、继承、多态</p>
<p><strong>封装</strong></p>
<p>封装是指将对象的状态（数据）和行为（方法）捆绑在一起，通过接口对外部提供访问权限。对象的内部细节对外部是隐藏的，外部程序只能通过对象的公共接口来与对象进行交互。封装可以帮助保护对象的数据，防止外部直接访问对象的内部数据，提高了代码的可维护性和可重用性。</p>
<p><strong>继承</strong></p>
<p>让某种类型对象获得另一个类型对象的属性和方法。它可以使用现有类的所有功能，并且可以增加新的成员变量和成员函数</p>
<p>常见的继承有三种方式</p>
<p><strong>多态</strong></p>
<p>多态是指同一操作作用于不同的对象，可以产生不同的行为。即一个函数在不同的对象上拥有不同的行为。</p>
<p>多态有两种形式：</p>
<ul>
<li><p>静态多态，重载：是指函数名相同，参数列表不同</p>
</li>
<li><p>动态多态，覆盖（重写）：是指子类重新定义父类的虚函数。</p>
</li>
</ul>
<h1 id="53-成员初始化列表的概念，为什么用它会快一些？"><a href="#53-成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="53 成员初始化列表的概念，为什么用它会快一些？"></a>53 成员初始化列表的概念，为什么用它会快一些？</h1><p><strong>概念</strong></p>
<p>在类的构造函数中，不存在函数体内对成员赋值，而是在函数名的后面、花括号的前面使用<code>:</code>和成员初始化列表对成员赋值</p>
<p><strong>效率</strong></p>
<p>对于内置类型，效率没有差别</p>
<p>对于其它类型，使用成员初始化列表会少一次调用构造函数的过程，而在函数体内使用直接赋值会多一次调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;default constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>    &#123;<br>        value = a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        b = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>        c = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    A a;<br>    A b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br>a: <span class="hljs-number">1</span><br><span class="hljs-keyword">default</span> constructor<br>a: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>对于<code>a</code>，使用成员列表初始化，对a直接赋值</p>
</li>
<li><p>对于<code>b</code>，在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)</p>
</li>
<li><p>对于<code>c</code>，为基本类型，直接对<code>c</code>进行赋值</p>
</li>
</ul>
<h1 id="54-C-函数调用的压栈过程"><a href="#54-C-函数调用的压栈过程" class="headerlink" title="54 C++函数调用的压栈过程"></a>54 C++函数调用的压栈过程</h1><p><strong>代码层面</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; n &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> param1, <span class="hljs-type">int</span> param2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> var1 = param1;<br>	<span class="hljs-type">int</span> var2 = param2;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var1=%d,var2=%d&quot;</span>, <span class="hljs-built_in">f</span>(var1), <span class="hljs-built_in">f</span>(var2));<span class="hljs-comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//var1=1,var2=2</span><br><br></code></pre></td></tr></table></figure>

<p>（1）当函数入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p>
<p>（2）当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p>
<p>（3）当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再f()将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<p><strong>文字描述</strong></p>
<p>函数的调用过程</p>
<p>（1）从栈空间分配存储空间</p>
<p>（2）从实参的存储空间复制值到形参栈空间</p>
<p>（3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不会被销毁也不能被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p>
<h1 id="55-coredump怎么调试"><a href="#55-coredump怎么调试" class="headerlink" title="55 coredump怎么调试"></a>55 coredump怎么调试</h1><p>core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息</p>
<p><strong>产生coredump的情况：</strong></p>
<ul>
<li><p>数组越界</p>
</li>
<li><p>使用空指针</p>
</li>
<li><p>堆栈溢出（使用大量的局部变量）</p>
</li>
</ul>
<p><strong>使用gdb进行调试：</strong></p>
<ul>
<li>l(list) ，显示源代码，并且可以看到对应的行号；</li>
<li>b(break)x, x是行号，表示在对应的行号位置设置断点；</li>
<li>p(print)x, x是变量名，表示打印变量x的值</li>
<li>r(run), 表示继续执行到断点的位置</li>
<li>n(next),表示执行下一步</li>
<li>c(continue),表示继续执行</li>
<li>q(quit)，表示退出gdb</li>
</ul>
<h1 id="56-移动构造函数"><a href="#56-移动构造函数" class="headerlink" title="56 移动构造函数"></a>56 移动构造函数</h1><p><strong>移动构造函数的初衷：</strong></p>
<p>使用对象<code>a</code>初始化对象<code>b</code>后对象<code>a</code>就不在使用了，但是对象<code>a</code>的内存还在，如果是拷贝构造函数的话，是将对象<code>a</code>的内容复制一份到对象<code>b</code>中，那么能否直接使用对象<code>a</code>的内存呢，这样就避免了内存的重新分配，降低了构造的成本。</p>
<p><strong>规则：</strong></p>
<p>对于拷贝构造函数，是采用深拷贝，对于移动构造函数，采用浅拷贝，但是就会有一个问题，浅拷贝之后两个指针<code>a</code>、<code>b</code>指向同一块内存，如果在析构函数中把a释放掉，那么访问<code>b</code>的时候就会出现异常，解决方法就是将指针<code>a</code>置为<code>null</code>，这样在调用析构函数的时候，由于有判断指针是否为空的语句，析构<code>a</code>的时候并不会回收<code>a</code>指向的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">Person</span>()<br>&#123;<br>    <span class="hljs-comment">// 析构代码，将堆区开辟的数据做释放操作</span><br>    <span class="hljs-keyword">if</span>(m_height != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> m_height;<br>        m_height = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p>拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</p>
<p>move语句，就是将一个左值变成一个右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>():<span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>))&#123; cout &lt;&lt; <span class="hljs-string">&quot;construct!&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">demo</span>()&#123;&#125;<br><br>    <span class="hljs-comment">/// 拷贝构造</span><br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">const</span> demo &amp;rhs) : <span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*rhs.num))&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;copy construct!&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    <span class="hljs-comment">/// 移动构造（指针进行浅拷贝，内部重置num为null）</span><br>    <span class="hljs-built_in">demo</span>(demo &amp;&amp;rhs) : <span class="hljs-built_in">num</span>(rhs.num)&#123;<br>        rhs.num = <span class="hljs-literal">NULL</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move construct!&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *num;<br>&#125;;<br><br><span class="hljs-function">demo <span class="hljs-title">GetDemo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">demo</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    demo a = <span class="hljs-built_in">GetDemo</span>();  <span class="hljs-comment">// 普通构造</span><br>    <span class="hljs-function">demo <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;	<span class="hljs-comment">// 拷贝构造</span><br>    <span class="hljs-function">demo <span class="hljs-title">c</span><span class="hljs-params">(move(a))</span></span>; <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br>construct!     <br>copy construct!<br>move construct!<br></code></pre></td></tr></table></figure>



<h1 id="57-C-中将临时变量作为返回值时的处理过程"><a href="#57-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="57 C++中将临时变量作为返回值时的处理过程"></a>57 C++中将临时变量作为返回值时的处理过程</h1><p><strong>函数返回值存在的位置</strong></p>
<ul>
<li>在C语言中，函数返回值通常会被<strong>存储在寄存器中</strong>（如ax、eax等），而不是堆栈中。这样设计的目的是为了提高执行效率，避免频繁的堆栈操作。</li>
<li>在函数调用结束后，返回值<strong>仍然保留在寄存器中</strong>，并且在函数退出时不会被销毁。这意味着返回值可以被调用函数使用，即使临时变量已经被销毁。</li>
</ul>
<p><strong>临时变量的声明周期</strong></p>
<p>临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p><strong>函数返回值的使用</strong></p>
<p>如果需要返回值，一般使用赋值语句就可以。</p>
<h1 id="58-程序的内存模型"><a href="#58-程序的内存模型" class="headerlink" title="58 程序的内存模型"></a>58 程序的内存模型</h1><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将<strong>内存</strong>大方向划分为4个区域</p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<p>内存分区的意义：</p>
<p>不同区域存放的数据，赋予不同的生命周期，可以更灵活的进行编程</p>
<h2 id="2-程序运行前"><a href="#2-程序运行前" class="headerlink" title="2 程序运行前"></a>2 程序运行前</h2><p>在程序编译后，生成了<code>exe</code>可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p><strong>代码区：</strong></p>
<ul>
<li>存放CPU执行的机器指令</li>
<li>代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li>
<li>代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</li>
</ul>
<p><strong>全局区</strong></p>
<ul>
<li>存放全局变量、静态变量、字符串常量、const修饰的全局变量</li>
<li>该区域的数据在程序结束后由操作系统释放</li>
</ul>
<h2 id="3-程序运行后"><a href="#3-程序运行后" class="headerlink" title="3 程序运行后"></a>3 程序运行后</h2><p><strong>栈区</strong></p>
<p>由编译器自动分配释放，存放函数的形参，局部变量，返回值等</p>
<p>注意：尽量不要返回局部遍量的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> &amp;a;   <span class="hljs-comment">// warning: address of local variable &#x27;a&#x27; returned</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* b = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; *b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>堆区</strong></p>
<p>由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> *a = <span class="hljs-built_in">func</span>();<br>    cout &lt;&lt; *a &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="59-全局遍历和局部变量有什么区别"><a href="#59-全局遍历和局部变量有什么区别" class="headerlink" title="59 全局遍历和局部变量有什么区别"></a>59 全局遍历和局部变量有什么区别</h1><p><strong>生命周期不同：</strong>全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p><strong>使用方式不同：</strong>通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<h1 id="60-怎样判断两个浮点数是否相等"><a href="#60-怎样判断两个浮点数是否相等" class="headerlink" title="60 怎样判断两个浮点数是否相等"></a>60 怎样判断两个浮点数是否相等</h1><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错。</p>
<p>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值.</p>
<p>浮点数与0的比较也应该注意。与浮点数的表示方式有关</p>
<h1 id="61-方法调用的原理（栈，汇编）"><a href="#61-方法调用的原理（栈，汇编）" class="headerlink" title="61 方法调用的原理（栈，汇编）"></a>61 方法调用的原理（栈，汇编）</h1><h1 id="62-如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#62-如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="62 如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>62 如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<p>所以必须定义而非声明。</p>
<h1 id="63-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#63-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="63 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>63 继承机制中对象之间如何转换？指针和引用之间如何转换？</h1><ul>
<li><p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p>
</li>
<li><p>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p>
</li>
</ul>
<p>在C++中，基类的成员函数可以选择性地进行定义。通常情况下，如果基类的成员函数是纯虚函数，那么它必须在基类中进行声明，并且通常是没有函数体的。</p>
<p>然而，如果基类的成员函数不是纯虚函数，那么它可以在基类中提供具体的实现，也可以选择在派生类中进行覆盖或重载。如果在基类中提供了实现，派生类可以选择性地覆盖这些成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 基类成员函数的声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 虚函数可以没有具体的实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">anotherFunction</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 非虚函数可以在基类中提供具体实现</span><br>&#125;;<br><br><span class="hljs-comment">// 基类成员函数的定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::someFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 基类成员函数的实现</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::anotherFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 基类另一个成员函数的实现</span><br>&#125;<br><br><span class="hljs-comment">// 派生类的定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 派生类覆盖基类的虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 派生类提供的实现</span><br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>



<h1 id="64-C-中的组合？它与继承相比有什么优缺点？"><a href="#64-C-中的组合？它与继承相比有什么优缺点？" class="headerlink" title="64 C++中的组合？它与继承相比有什么优缺点？"></a>64 C++中的组合？它与继承相比有什么优缺点？</h1><p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// Engine 类的定义</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine carEngine; <span class="hljs-comment">// Car 类包含 Engine 类的对象作为成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员和方法</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>组合的优点：</strong></p>
<ul>
<li>当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</li>
<li>当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</li>
<li>当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</li>
</ul>
<p><strong>组合的缺点：</strong></p>
<ul>
<li><p>容易产生过多的对象。</p>
</li>
<li><p>为了能组合多个对象，必须仔细对接口进行定义。</p>
</li>
</ul>
<h1 id="65-函数指针"><a href="#65-函数指针" class="headerlink" title="65 函数指针"></a>65 函数指针</h1><p>函数指针是指向函数的指针变量。 </p>
<p>函数也是有地址的，函数指针指向函数的地址。</p>
<h1 id="66-结构体变量比较是否相等"><a href="#66-结构体变量比较是否相等" class="headerlink" title="66 结构体变量比较是否相等"></a>66 结构体变量比较是否相等</h1><p><strong>重载操作符 &#x3D;&#x3D;</strong></p>
<ul>
<li>元素一个一个比</li>
<li>指针直接比较，如果保存的是同一个地址，则相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span><br>&#123;<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span>* p;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> s &amp;rhs);<br>&#125;;<br><br><span class="hljs-type">bool</span> s::<span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> s &amp;rhs)<br>&#123;<br>	<span class="hljs-built_in">return</span> ((a == rhs.a) &amp;&amp; (b == rhs.b) &amp;&amp; p == (rhs.p));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span> s1, s2;<br>	s1.a = <span class="hljs-number">1</span>;<br>	s1.b = <span class="hljs-number">2</span>;<br>	s2.a = <span class="hljs-number">1</span>;<br>	s2.b = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p1 = &amp;a;<br>    <span class="hljs-type">int</span>* p2 = &amp;a;<br>    s1.p = p1;<br>    s2.p = p2;<br>	<span class="hljs-keyword">if</span> (s1 == s2)<br>		cout &lt;&lt; <span class="hljs-string">&quot;两个结构体相等&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">else</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;两个结构体不相等&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>两个结构体相等<br></code></pre></td></tr></table></figure>



<h1 id="67-memcmp和memset"><a href="#67-memcmp和memset" class="headerlink" title="67 memcmp和memset"></a>67 memcmp和memset</h1><p><strong>memcmp</strong></p>
<p>memcmp是比较内存区域<code>str</code>1和<code>str2</code>的前<code>count</code>个字节。该函数是按字节比较的，根据字节的<code>ascII</code>码值进行比较</p>
<p>ASCII码的大小规则：<strong>0<del>9&lt;A</del>Z&lt;a~z</strong></p>
<p>语法：<code>int memcmp(const void *str1, const void *str2, size_t n)</code></p>
<p>返回值：</p>
<ul>
<li>如果返回值 &gt; 0 ，则表示  str1 &gt; str2；</li>
<li>如果返回值 &lt; 0 ，则表示  str1 &lt; str2；</li>
<li>如果返回值 &#x3D; 0 ，则表示  str1 &#x3D; str2；</li>
</ul>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">char</span> str1[<span class="hljs-number">15</span>];<br>   <span class="hljs-type">char</span> str2[<span class="hljs-number">15</span>];<br>   <span class="hljs-type">int</span> ret;<br><br>   <span class="hljs-built_in">memcpy</span>(str1, <span class="hljs-string">&quot;abcdef&quot;</span>, <span class="hljs-number">6</span>);<br>   <span class="hljs-built_in">memcpy</span>(str2, <span class="hljs-string">&quot;ABCDEF&quot;</span>, <span class="hljs-number">6</span>);<br><br>   ret = <span class="hljs-built_in">memcmp</span>(str1, str2, <span class="hljs-number">5</span>);<br><br>   <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str2 小于 str1&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) <br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 小于 str2&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">else</span> <br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str1 等于 str2&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br>str2 小于 str1<br></code></pre></td></tr></table></figure>

<p><strong>memset</strong></p>
<p>作用：memset是一个初始化函数，作用是将某一块内存中的值设置为指定的值</p>
<p>声明：<code>void *memset(void *s, int c, size_t n);</code></p>
<ul>
<li>s指向要填充的内存块。</li>
<li>c是要被设置的值。c的实际范围应该在0~255，因为memset函数只能取c的后八位给所输入范围的每个字节。也就是说无论c多大只有后八位二进制是有效的。</li>
<li>n是要被设置该值的字符数。</li>
<li>返回类型是一个指向存储区s的指针。</li>
</ul>
<p>实例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(str,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-built_in">sizeof</span>(str));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)<br>    &#123;<br>        cout&lt;&lt;str[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(str): %d&quot;</span>, <span class="hljs-built_in">sizeof</span>(str));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(a));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a): %d&quot;</span>, <span class="hljs-built_in">sizeof</span>(a));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span> <span class="hljs-number">16843009</span><br><span class="hljs-built_in">sizeof</span>(a): <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>

<p>为什么输出结果是 16843009而不是预期的 1？</p>
<p>因为memset是以字节为单位进行赋值的，int一般占4个字节，1的二进制表示是 00000001，也就是对于每一个a中的元素，它的4个字节都被赋值成了00000001 ， 结果就变成了 00000001 00000001 00000001 00000001，转换为10进制就是16843009。如果用memset初始化非char型的数组要特别注意用法</p>
<p><strong>具体用法实例</strong></p>
<ul>
<li>初始化数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(str,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>清空结构体类型的变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stu</span><br>&#123;<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-type">int</span> cno;<br>&#125;Stu;<br>Stu stu1; <br><span class="hljs-built_in">memset</span>(&amp;stu1, <span class="hljs-number">0</span> ,<span class="hljs-built_in">sizeof</span>(Stu));<br><br>Stu stu2[<span class="hljs-number">10</span>]; <span class="hljs-comment">//数组</span><br><span class="hljs-built_in">memset</span>(stu2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Stu)*<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>



<h1 id="68-函数调用过程栈的变化，返回值和参数变量哪个先入栈"><a href="#68-函数调用过程栈的变化，返回值和参数变量哪个先入栈" class="headerlink" title="68 函数调用过程栈的变化，返回值和参数变量哪个先入栈"></a>68 函数调用过程栈的变化，返回值和参数变量哪个先入栈</h1><h1 id="69-重载运算符是什么"><a href="#69-重载运算符是什么" class="headerlink" title="69 重载运算符是什么"></a>69 重载运算符是什么</h1><p><strong>定义：</strong></p>
<p>重载运算符是通过对运算符的重新定义，使得其支持特定数据类型的运算操作。C++ 自带的运算符，最初只定义了一些基本类型的运算规则。当我们要在用户自定义的数据类型上使用这些运算符时，就需要定义运算符在这些特定类型上的运算方式</p>
<ul>
<li>引入重载运算符，是为了实现类的多态性</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>只能对现有的运算符进行重载，不能自行定义新的运算符</li>
<li>以下运算符不能被重载：<code>::</code>（作用域解析），<code>.</code>（成员访问），<code>.*</code>（通过成员指针的成员访问），<code>?:</code>（三目运算符）。</li>
</ul>
<p><strong>实现：</strong></p>
<p>有两种重载方式：重载为成员函数或非成员函数</p>
<ul>
<li>重载为成员函数：<code>Box operator+(const Box&amp;);</code>，隐含一个指向当前成员的<code>this</code>指针作为参数</li>
<li>重载为非成员函数：<code>Box operator+(const Box&amp;, const Box&amp;);</code></li>
</ul>
<h1 id="70-当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#70-当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="70 当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>70 当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ol>
<li><p>确定候选函数。候选函数有两个特征：</p>
<ul>
<li>与被调用的函数同名</li>
<li>其声明在调用点可见</li>
</ul>
</li>
<li><p>确定可行函数：考察本地函数调用提供的实参，然后从候选参数中选出能被这些实参调用的函数，可行函数也具备两个特征</p>
<ul>
<li>形参数量与提供的实参数量相同</li>
<li>每个实参类型与形参的类型相同，或者能转换成对应的形参的类型</li>
</ul>
</li>
<li><p>最佳匹配：逐一检查函数调用提供的实参，寻找实参类型和形参类型最匹配的那个参数。编译器将实参类型到形参类型的转化划分成几个等级（从 1 到 5 匹配度逐步降低）</p>
<ul>
<li>精确匹配，包括以下情况(它们具有相同且最高的匹配度)：<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型</li>
<li>向实参添加顶层const或者从实参中删除顶层const（形参的顶层cosnt是可以直接忽略掉的）</li>
</ul>
</li>
<li>通过const转化实现匹配(底层const的转换)</li>
<li>通过类型提升实现的匹配</li>
<li>通过算术类型转换实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ul>
</li>
</ol>
<h1 id="71-全局变量和static变量的区别"><a href="#71-全局变量和static变量的区别" class="headerlink" title="71 全局变量和static变量的区别"></a>71 全局变量和static变量的区别</h1><p>全局变量（外部变量）的说明之前再加上<code>static</code>就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。</p>
<p><strong>作用域不同：</strong></p>
<ul>
<li>全局变量：全局变量在整个程序文件内可见和可用，其他文件如果使用 extern 关键字声明后也可以访问。</li>
<li>静态变量：静态变量可以有多种作用域：<ul>
<li>当静态变量定义在函数内部时，它在函数调用结束后不会被销毁，但作用域只限于该函数内部。</li>
<li>当静态变量定义在全局范围内时，它与全局变量类似，但作用域仅限于定义它的文件，可以避免在其他源文件中引起错误</li>
</ul>
</li>
</ul>
<h1 id="72-普通函数和static函数的区别"><a href="#72-普通函数和static函数的区别" class="headerlink" title="72 普通函数和static函数的区别"></a>72 普通函数和static函数的区别</h1><p><strong>作用域不同</strong></p>
<ul>
<li>用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用</li>
<li>而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。</li>
</ul>
<p><strong>存在位置</strong></p>
<p>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<h1 id="73-普通成员与static成员的区别是什么？"><a href="#73-普通成员与static成员的区别是什么？" class="headerlink" title="73 普通成员与static成员的区别是什么？"></a>73 普通成员与static成员的区别是什么？</h1><p><strong>生命周期</strong></p>
<ul>
<li>静态成员变量从类被加载开始到类被卸载，一直存在；</li>
<li>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</li>
</ul>
<p><strong>共享方式</strong></p>
<ul>
<li>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</li>
</ul>
<p><strong>定义位置</strong></p>
<ul>
<li>普通成员变量存储在栈或堆中（存在于包含它们的对象中，取决于对象是怎么创建的，如果对象是作为局部对象创建，存在栈上，如果是通过new创建，存在堆上），而静态成员变量存储在静态全局区；</li>
</ul>
<p><strong>初始化位置</strong></p>
<ul>
<li>普通成员在类内初始化</li>
<li>静态成员变量在类外初始化</li>
</ul>
<p><strong>默认实参</strong></p>
<ul>
<li>可以使用静态成员变量作为默认实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> defaultValue;  <span class="hljs-comment">// 静态成员变量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> x = defaultValue)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The value is: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::defaultValue = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    MyClass obj2;<br><br>    obj1.<span class="hljs-built_in">myFunction</span>();  <span class="hljs-comment">// 将使用静态成员变量的默认值</span><br>    obj2.<span class="hljs-built_in">myFunction</span>(<span class="hljs-number">200</span>);  <span class="hljs-comment">// 显式提供参数值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>The value is: <span class="hljs-number">100</span><br>The value is: <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>



<h1 id="74-ifdef-endif代表着什么？"><a href="#74-ifdef-endif代表着什么？" class="headerlink" title="74 ifdef endif代表着什么？"></a>74 ifdef endif代表着什么？</h1><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
<p>形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ifdef 标识符  </span><br>程序段1  <br><span class="hljs-comment">#else  </span><br>程序段2  <br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure>

<p>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有</p>
<p>常见的预处理指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#空指令，无任何效果</span><br><span class="hljs-comment">#include包含一个源代码文件</span><br><span class="hljs-comment">#define定义宏</span><br><span class="hljs-comment">#undef取消已定义的宏</span><br><span class="hljs-comment">#if如果给定条件为真，则编译下面代码</span><br><span class="hljs-comment">#ifdef如果宏已经定义，则编译下面代码</span><br><span class="hljs-comment">#ifndef如果宏没有定义，则编译下面代码</span><br><span class="hljs-comment">#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</span><br><span class="hljs-comment">#endif结束一个#if……#else条件编译块</span><br><span class="hljs-comment">#error停止编译并显示错误信息</span><br></code></pre></td></tr></table></figure>



<h1 id="75-隐式转换，如何消除隐式转换？"><a href="#75-隐式转换，如何消除隐式转换？" class="headerlink" title="75 隐式转换，如何消除隐式转换？"></a>75 隐式转换，如何消除隐式转换？</h1><ul>
<li><p>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。</p>
</li>
<li><p>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，可以直接将一个子类的对象使用父类的类型进行返回。再比如，数值和布尔类型的转换，整数和浮点数的转换等。</p>
</li>
<li><p>基本数据类型的转换以取值范围作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
</li>
<li><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Entity</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> age)</span> : m_age(age)&#123;</span>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="76-C-如何处理多个异常的？"><a href="#76-C-如何处理多个异常的？" class="headerlink" title="76 C++如何处理多个异常的？"></a>76 C++如何处理多个异常的？</h1><p><strong>C++中的异常情况：</strong></p>
<ul>
<li>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。</li>
<li>运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li>
</ul>
<p><strong>C++异常处理机制：</strong></p>
<p>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> <br>&#123; <br>可能抛出异常的语句；（检查） <br>&#125; <br><span class="hljs-keyword">catch</span>（类型名[形参名]）<span class="hljs-comment">//捕获特定类型的异常 </span><br>&#123; <br><span class="hljs-comment">//处理1； </span><br>&#125; <br><span class="hljs-keyword">catch</span>（类型名[形参名]）<span class="hljs-comment">//捕获特定类型的异常 </span><br>&#123; <br><span class="hljs-comment">//处理2； </span><br>&#125; <br><span class="hljs-keyword">catch</span>（…）<span class="hljs-comment">//捕获所有类型的异常 </span><br>&#123; <br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="77-如何在不使用额外空间的情况下，交换两个数？有几种方法"><a href="#77-如何在不使用额外空间的情况下，交换两个数？有几种方法" class="headerlink" title="77 如何在不使用额外空间的情况下，交换两个数？有几种方法"></a>77 如何在不使用额外空间的情况下，交换两个数？有几种方法</h1><p>算术：有溢出风险</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = x + y;<br>y = x - y;<br>x = x - y;<br></code></pre></td></tr></table></figure>

<p>异或：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">x = x ^ y; <br>y = x ^ y;<br>x = x ^ y;<br></code></pre></td></tr></table></figure>



<h1 id="78-strcpy和memcpy的区别"><a href="#78-strcpy和memcpy的区别" class="headerlink" title="78 strcpy和memcpy的区别"></a>78 strcpy和memcpy的区别</h1><p><strong>操作对象不同</strong></p>
<ul>
<li>strcpy的两个操作对象均为字符串</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
<p><strong>复制的方法不同</strong></p>
<ul>
<li>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。</li>
<li>memcpy则是根据其第3个参数决定复制的长度</li>
</ul>
<p><strong>实现功能不同</strong></p>
<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>memcpy主要是内存块间的拷贝</li>
</ul>
<p><strong>memcpy</strong></p>
<p>声明：<code>void *memcpy(void*dest, const void *src, size_t n);</code></p>
<p>作用：由src指向地址为起始地址的连续n个字节的数据复制到以dest指向地址为起始地址的空间内。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将字符串复制到数组 dest 中</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-type">char</span> src[<span class="hljs-number">50</span>] = <span class="hljs-string">&quot;http://www.runoob.com&quot;</span>;<br>   <span class="hljs-type">char</span> dest[<span class="hljs-number">50</span>];<br> <br>   <span class="hljs-built_in">memcpy</span>(dest, src, <span class="hljs-built_in">strlen</span>(src)+<span class="hljs-number">1</span>);  <span class="hljs-comment">// +1 是因为src是c语言风格字符串，以&#x27;\0&#x27;结尾，这样可以保证完整复制</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dest = %s\n&quot;</span>, dest);<br><br>   <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br>dest = http:<span class="hljs-comment">//www.runoob.com</span><br></code></pre></td></tr></table></figure>



<p><strong>strcpy</strong></p>
<p>声明：<code>char* strcpy(char* dest, const char* src);</code></p>
<p>作用：把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>。</p>
<p>注意：如果目标数组<code>dest</code>不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p>
<p>个人理解：使用的时候相当于先把<code>dest</code>清空，再把<code>src</code>的内容复制到<code>dest</code>上，直到遇到<code>src</code>的<code>&#39;\0&#39;</code>为止</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> src[] = <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">char</span> dest[] = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, src); <span class="hljs-comment">// a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, dest); <span class="hljs-comment">// bbb</span><br><br>    <span class="hljs-built_in">strcpy</span>(dest, src);<br>   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, src); <span class="hljs-comment">// a</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>, dest); <span class="hljs-comment">// a</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="79-如果有一个空类，它会默认添加哪些函数"><a href="#79-如果有一个空类，它会默认添加哪些函数" class="headerlink" title="79 如果有一个空类，它会默认添加哪些函数"></a>79 如果有一个空类，它会默认添加哪些函数</h1><ul>
<li>缺省构造函数：<code>Empty(); </code></li>
<li>拷贝构造函数：<code>Empty(const Empty&amp;);</code></li>
<li>析构函数：<code>~Empty();</code></li>
<li>赋值运算符：<code>Empty&amp; operator=( const Empty&amp; );</code></li>
</ul>
<h1 id="80-C-中标准库是什么"><a href="#80-C-中标准库是什么" class="headerlink" title="80 C++中标准库是什么"></a>80 C++中标准库是什么</h1><p>C++ 标准库可以分为两部分：</p>
<p><strong>标准函数库</strong>：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p>
<ul>
<li>输入&#x2F;输出 I&#x2F;O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<p><strong>面向对象类库</strong>：这个库是类及其相关函数的集合。</p>
<ul>
<li>标准的 C++ I&#x2F;O 类</li>
<li>String 类</li>
<li>数值类</li>
<li>STL 容器类</li>
<li>STL 算法</li>
<li>STL 函数对象</li>
<li>STL 迭代器</li>
<li>STL 分配器</li>
<li>本地化库</li>
<li>异常处理类</li>
<li>杂项支持库</li>
</ul>
<h1 id="81-静态绑定和动态绑定"><a href="#81-静态绑定和动态绑定" class="headerlink" title="81 静态绑定和动态绑定"></a>81 静态绑定和动态绑定</h1><h1 id="82-如何设计一个计算仅单个子类的对象个数？"><a href="#82-如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="82 如何设计一个计算仅单个子类的对象个数？"></a>82 如何设计一个计算仅单个子类的对象个数？</h1><p>1、为类设计一个static静态变量count作为计数器；</p>
<p>2、类定义结束后初始化count;</p>
<p>3、在构造函数中对count进行+1;</p>
<p>4、 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p>
<p>5、设计赋值构造函数，在进行赋值函数中对count+1操作；</p>
<p>6、在析构函数中对count进行-1；</p>
<h1 id="83-成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#83-成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="83 成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>83 成员初始化列表会在什么时候用到？它的调用过程是什么？</h1><p><strong>非静态常量成员必须使用成员初始化列表进行初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base: %d&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>引用成员的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> &amp;t;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> &amp;t):<span class="hljs-built_in">t</span>(t)&#123;&#125;  <span class="hljs-comment">//必须使用初始化列表</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">22</span>;<br>    <span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(x)</span></span>;<br>    cout &lt;&lt; t1.t &lt;&lt; endl;<br>    x = <span class="hljs-number">33</span>;<br>    cout &lt;&lt; t1.t &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>初始化没有默认构造函数的成员对象</strong></p>
<p>类<code>B</code> 的数据成员<code>a</code>是类<code>A</code>的一个对象, 并且<code>A</code>没有默认构造函数，则<code>B</code>必须使用初始化列表来对<code>a</code>进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>A::<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> arg)  <br>&#123;  <br>  i = arg;  <br>  cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s Constructor called: Value of i: &quot;</span> &lt;&lt; i &lt;&lt; endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// 类B包含A的一个对象  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>  <br>&#123;  <br>  A a;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>B::<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x)   <span class="hljs-comment">//必须使用初始化列表  </span><br>&#123;  <br>  cout &lt;&lt; <span class="hljs-string">&quot;B&#x27;s Constructor called&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br><span class="hljs-comment">//输出结果：</span><br>A<span class="hljs-number">&#x27;</span>s Constructor called: Value of i: <span class="hljs-number">10</span><br>B<span class="hljs-number">&#x27;</span>s Constructor called<br></code></pre></td></tr></table></figure>

<p><strong>基类数据成员的初始化</strong></p>
<p>如果想要带参数的构造函数初始化基类，则子类必须使用初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>);<br>&#125;;  <br>  <br>A::<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> arg)  <br>&#123;  <br>  i = arg;  <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s Constructor called: Value of i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// Class B 继承自Class A  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : A  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>  <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>);  <br>&#125;;  <br>  <br>B::<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> x) :  <span class="hljs-built_in">A</span>(x)  <br>&#123; <span class="hljs-comment">//必须使用初始化列表  </span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;B&#x27;s Constructor called&quot;</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>  <span class="hljs-function">B <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<p><strong>当调用一个成员类的构造函数，而他拥有一组参数</strong></p>
<h1 id="84-静态-非静态、常量-变量初始化方式"><a href="#84-静态-非静态、常量-变量初始化方式" class="headerlink" title="84 静态&#x2F;非静态、常量&#x2F;变量初始化方式"></a>84 静态&#x2F;非静态、常量&#x2F;变量初始化方式</h1><p>初始化方式：成员列表初始化、定义时直接初始化、类内声明类外初始化、构造函数内初始化</p>
<p><strong>静态成员常量</strong>：定义时直接初始化、类内声明类外初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 类内声明类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><strong>静态成员变量</strong>：类内声明类外初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类内声明类外初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><span class="hljs-type">int</span> Base::m_num = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><strong>非静态成员常量</strong>：成员列表初始化、定义时直接初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//成员列表初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>非静态成员变量</strong>：成员列表初始化、定义时直接初始化、构造函数内初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 成员列表初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(): <span class="hljs-built_in">m_num</span>(<span class="hljs-number">1</span>)&#123;&#125;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num;<br>&#125;;<br><br><span class="hljs-comment">// 定义时直接初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数内初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        m_num = <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-type">int</span> m_num;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="85-在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#85-在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="85 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>85 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</h1><p>对比值传递，引用传参的好处：</p>
<ul>
<li>在函数内部可以对此参数进行修改</li>
<li>提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</li>
</ul>
<p>函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本</p>
<p>但是有以下的限制：</p>
<ul>
<li>不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁，没有意义</li>
<li>不能返回函数内部new分配的内存的引用，当函数执行完毕时，函数内部使用<code>new</code>分配的内存将会被释放，从而使得引用变为悬空引用</li>
</ul>
<h1 id="86-将引用作为函数参数有哪些好处？"><a href="#86-将引用作为函数参数有哪些好处？" class="headerlink" title="86 将引用作为函数参数有哪些好处？"></a>86 将引用作为函数参数有哪些好处？</h1><ul>
<li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li>
</ul>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<ul>
<li>传递引用给函数与传递指针的效果是一样的</li>
</ul>
<p>被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对实参的操作。</p>
<h1 id="87-数组和指针的区别"><a href="#87-数组和指针的区别" class="headerlink" title="87 数组和指针的区别"></a>87 数组和指针的区别</h1><p><strong>概念</strong></p>
<p>数组：存储连续多个相同类型的数据</p>
<p>指针：变量，存的是地址</p>
<p><strong>赋值</strong></p>
<p>同类型的指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</p>
<p><strong>存储方式</strong></p>
<p>数组：连续内存空间。</p>
<p>指针：就是一个变量，指向一个地址，可以指向任意类型的数据。</p>
<p><strong>sizeof</strong></p>
<p>数组的sizeof求的是占用的空间（字节）。</p>
<p>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</p>
<p><strong>传参</strong></p>
<p>作为参数时，数组名退化为常量指针</p>
<h1 id="88-如何阻止一个类被实例化？有哪些方法？"><a href="#88-如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="88 如何阻止一个类被实例化？有哪些方法？"></a>88 如何阻止一个类被实例化？有哪些方法？</h1><ul>
<li>将类定义为抽象基类，抽象类是不能被实例化的，只能被继承</li>
<li>将构造函数声明为private</li>
<li>抛出异常</li>
</ul>
<h1 id="89-如何禁止程序自动生成拷贝构造函数？"><a href="#89-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="89 如何禁止程序自动生成拷贝构造函数？"></a>89 如何禁止程序自动生成拷贝构造函数？</h1><p><strong>将这些函数声明为删除的函数，在函数参数的后面加上</strong>&#x3D;delete<strong>来指示出我们定义的删除的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 禁用默认的拷贝构造函数  </span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>;  <br>      <br>    <span class="hljs-comment">// 禁用默认的拷贝赋值函数  </span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>;  <br>  <br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>将这些函数声明为</strong>private**,并且不提供函数定义，如果只声明不定义，会产生链接错误，也就无法生成拷贝构造函数了**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;);  <span class="hljs-comment">// 声明私有拷贝构造函数  </span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp;);  <span class="hljs-comment">// 声明私有赋值运算符  </span><br>    <span class="hljs-comment">// 其他成员和方法  </span><br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="90-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#90-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="90 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>90 strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><p><strong>strcpy</strong></p>
<p>函数声明：<code>char* strcpy(char* strDest, const char* strSrc)</code></p>
<p><code>strcpy</code>是覆盖拷贝，将<code>strSrc</code>全部覆盖拷贝到<code>strDest</code>，也会把<code>&#39;\0&#39;</code>拷贝进去，且必须考虑<code>strDest</code>的空间够不够（<code>strDest</code>的空间必须 ≥ <code>strSrc</code>的空间）</p>
<p><strong>strncpy</strong></p>
<p>函数声明：<code>char *strncpy(char *dest, const char *src, size_t len);</code></p>
<ul>
<li>第一个参数是指向目标空间的起始地址 <code>char *dest</code></li>
<li>第二个参数是源字符串的起始地址 <code>char *src</code></li>
<li>第三个字符串是无符号整数 <code>len</code>，表示源字符串向目标字符串写入的字符数</li>
</ul>
<p>函数作用：表示源字符串向目标字符串拷贝<code>len</code>个字符</p>
<ul>
<li>如果源字符串长度小于<code>len</code>，那么目标空间会以<code>&#39;\0&#39;</code>填充到<code>len</code>个长度</li>
<li>如果源字符串长度大于等于<code>len</code>，那么将会只有<code>len</code>个字符填充到目标空间，且不会以<code>&#39;\0&#39;</code>结尾</li>
</ul>
<p>使用场景：</p>
<ul>
<li><p>源字符串长度 ＞ 目标字符串长度</p>
<ul>
<li>源字符串长度 &lt; <code>len</code></li>
</ul>
<p>错误，溢出，但可能有输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span> &#125;;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br>	<span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">5</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>源字符串长度 ≥ <code>len</code></li>
</ul>
<p>错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span> &#125;;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br>	<span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">3</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出</span><br>ab怈<br></code></pre></td></tr></table></figure>
</li>
<li><p>源字符串长度 ≤ 目标字符串长度</p>
<ul>
<li>源字符串长度 &lt; <code>len</code></li>
</ul>
<p>将 <code>src</code>字符串全部拷贝到目标空间中，超过<code>src</code>长度小于<code>len</code>的以 <code>&#39;\0&#39;</code>补充，剩余保持原状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span> &#125;;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br>	<span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">5</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">5</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">6</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">7</span>]);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br>abcd<br>a   <br>b   <br>c   <br>d   <br>    <br><span class="hljs-number">6</span>   <br><span class="hljs-number">7</span>   <br><span class="hljs-number">8</span> <br></code></pre></td></tr></table></figure>

<ul>
<li>源字符串长度 ≥ <code>len</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">char</span> str[] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span> &#125;;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src = <span class="hljs-string">&quot;abcd&quot;</span>;<br><br>	<span class="hljs-built_in">strncpy</span>(str, src, <span class="hljs-number">3</span>);<br>    str[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 手动加&#x27;\0&#x27;</span><br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">4</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">5</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">6</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, str[<span class="hljs-number">7</span>]);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</li>
</ul>
<p><code>strncpy</code>比<code>strcpy</code>更安全的原因如下：</p>
<ul>
<li>目标字符串大小限制：<code>strncpy</code>函数接受一个目标字符串的大小限制参数，这可以确保复制的字符数不会超过目标字符串的容量。因此，即使源字符串的长度超过了目标字符串的大小，也只会发生部分复制，从而避免了缓冲区溢出的问题。</li>
<li>源字符串长度不确定：在某些情况下，源字符串的长度是未知的，或者无法通过其他方式确定。使用<code>strncpy</code>函数可以避免在不知道源字符串长度的情况下使用<code>strcpy</code>导致的潜在风险。</li>
<li>内存安全性：由于<code>strncpy</code>可以指定复制的字符数，因此可以避免在目标字符串中复制不必要的字符，从而避免了潜在的内存越界问题。</li>
</ul>
<h1 id="91-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#91-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="91 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast"></a>91 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast</h1><h1 id="92-static-cast比C语言中的转换强在哪里？"><a href="#92-static-cast比C语言中的转换强在哪里？" class="headerlink" title="92 static_cast比C语言中的转换强在哪里？"></a>92 static_cast比C语言中的转换强在哪里？</h1><h1 id="93-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#93-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="93 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>93 成员函数里memset(this,0,sizeof(*this))会发生什么</h1><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就<code>memset(this, 0, sizeof *this);</code>将整个对象的内存全部置为0，但是下面场景是不能用的：</p>
<ul>
<li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常</li>
<li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存</li>
</ul>
<h1 id="94-回调函数及其作用"><a href="#94-回调函数及其作用" class="headerlink" title="94 回调函数及其作用"></a>94 回调函数及其作用</h1><h1 id="95-delete和delete-区别？"><a href="#95-delete和delete-区别？" class="headerlink" title="95 delete和delete[]区别？"></a>95 delete和delete[]区别？</h1><ul>
<li>delete只会调用一次析构函数。</li>
<li>delete[]会调用数组（如果是对象的数组）中每个元素的析构函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> *pAa = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> A[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> pAa;<br></code></pre></td></tr></table></figure>



<h1 id="96-为什么不能把所有的函数写成内联函数"><a href="#96-为什么不能把所有的函数写成内联函数" class="headerlink" title="96 为什么不能把所有的函数写成内联函数?"></a>96 为什么不能把所有的函数写成内联函数?</h1><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h1 id="97-size-t"><a href="#97-size-t" class="headerlink" title="97 size_t"></a>97 size_t</h1><p><code>size_t</code>是<strong>无符号</strong>的长整型，一般用来表示字节数的多少。常用于如sizeof返回值的类型。</p>
<p><strong>与<code>int</code>类型相比，主要的特点为</strong></p>
<ul>
<li><code>size_t</code>是无符号的，<code>int</code>是有符号的。</li>
<li><code>size_t</code>是一种跟具体的平台有关联的类型，会具体调整其能表示的范围，因此其可移植性会更好。</li>
<li><code>size_t</code>能保证可以存储任何类型理论上可能的对象的最大值，包括数组类型。而<code>int</code>类型则只能保证<strong>16</strong>位或 <strong>32</strong>位的长度，且<code>int</code>为有符号的类型，其能存储的范围就更小了。对于存储超过该范围的数值时，就会出现问题，而<code>size_t</code>则没有此问题。</li>
</ul>
<p>常见用法：</p>
<ul>
<li>当表示或计算字节数的大小时，用<code>size_t</code>，如计算 sizeof 返回值时。</li>
<li>当用于数组索引和循环计数时，推荐使用<code>size_t</code>。尤其对于循环中的索引值递减时，由于<code>int</code>可以为负值，<code>unsigned int</code>不可以为0，此时递减的循环很容易出问题</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++</div>
      <div>http://example.com/2024/03/28/C++/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>March 28, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>April 2, 2024</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/01/%E5%88%B7%E9%A2%98/" title="刷题">
                        <span class="hidden-mobile">刷题</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'en'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/en.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
